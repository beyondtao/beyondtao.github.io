[{"content":"Certainly! Below is a draft for your English blog post about managing state in SwiftUI, covering @State, @Binding, @ObservedObject, and more.\nUnderstanding State Management in SwiftUI: @State, @Binding, and @ObservedObject State management is one of the most essential aspects of building reactive UIs in SwiftUI. SwiftUI provides several powerful property wrappers to manage and share state across your views, each suited for different scenarios.\nIn this blog post, we\u0026rsquo;ll explore key state management techniques using @State, @Binding, @ObservedObject, and a few other property wrappers that can simplify how we manage basic types and objects in SwiftUI.\n1. @State: Managing Local State in a View @State is the simplest way to manage state within a single SwiftUI view. It works well for basic data types like Int, String, Bool, and others. SwiftUI automatically observes any changes to these state variables and re-renders the UI when needed.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ContentView: View { @State private var count: Int = 0 var body: some View { VStack { Text(\u0026#34;Count: \\(count)\u0026#34;) Button(action: { count += 1 }) { Text(\u0026#34;Increment\u0026#34;) } } } } Here, @State tells SwiftUI that the count variable is a source of truth for this view. Whenever count is updated, the view is redrawn to reflect the new value.\nBest for: Single view local state. However, @State can\u0026rsquo;t be used to share state between multiple views.\n2. @Binding: Sharing State Between Views When you need to share or modify state between parent and child views, @Binding comes in handy. It allows a child view to read and modify a piece of state owned by its parent.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct ParentView: View { @State private var count: Int = 0 var body: some View { VStack { Text(\u0026#34;Parent Count: \\(count)\u0026#34;) ChildView(count: $count) // Pass binding using $ } } } struct ChildView: View { @Binding var count: Int // Use @Binding to modify parent state var body: some View { Button(action: { count += 1 }) { Text(\u0026#34;Increment from Child\u0026#34;) } } } In this example, the count state is owned by the parent (ParentView), but the child (ChildView) can modify it through the @Binding mechanism.\nBest for: Passing state between parent and child views, allowing both to interact with the same data.\n3. @ObservedObject and @Published: Managing Complex Data Objects When you need to manage more complex data structures or share state across multiple views, @ObservedObject and @Published work together to notify views when object properties change.\n@ObservedObject: Used by views to observe changes in a data object. @Published: Marks properties within the data object to be automatically observed for changes. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CounterModel: ObservableObject { @Published var count: Int = 0 } struct ContentView: View { @StateObject var counter = CounterModel() // Owns the model instance var body: some View { VStack { Text(\u0026#34;Count: \\(counter.count)\u0026#34;) Button(action: { counter.count += 1 }) { Text(\u0026#34;Increment\u0026#34;) } } } } In this scenario, CounterModel is an ObservableObject, and the count property is marked with @Published. The ContentView observes the counter object, and SwiftUI will re-render the UI when the count property changes.\nBest for: Managing and sharing complex, multi-property data models across different views.\n4. @StateObject vs @ObservedObject You might wonder when to use @StateObject vs @ObservedObject. The distinction is simple:\n@StateObject: Used to create and own an ObservableObject within a view. This ensures the object is only initialized once during the lifecycle of the view. @ObservedObject: Used when the ObservableObject is created outside of the view and passed into it, so the view doesn\u0026rsquo;t own the object but observes changes to it. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ContentView: View { @StateObject var viewModel = MyViewModel() // Owns the ViewModel var body: some View { ChildView(viewModel: viewModel) // Pass to child view } } struct ChildView: View { @ObservedObject var viewModel: MyViewModel // Observes without owning var body: some View { Text(viewModel.someValue) } } In this case, ContentView creates the viewModel using @StateObject, while ChildView only observes it via @ObservedObject. This allows multiple views to react to the same shared data changes.\n5. @AppStorage: Persisting State Across App Sessions If you need to persist a basic data type between app sessions, @AppStorage allows you to store state directly in UserDefaults. This is ideal for things like user settings or preferences that need to be retained even when the app is closed and reopened.\nExample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct ContentView: View { @AppStorage(\u0026#34;userScore\u0026#34;) var userScore: Int = 0 // Persists in UserDefaults var body: some View { VStack { Text(\u0026#34;User Score: \\(userScore)\u0026#34;) Button(action: { userScore += 1 }) { Text(\u0026#34;Increment\u0026#34;) } } } } With @AppStorage, the userScore will be stored in UserDefaults under the key \u0026quot;userScore\u0026quot;, making it available even after the app is terminated and relaunched.\nBest for: Persistent storage of basic data types (e.g., Int, String, Bool) that need to be retained across app launches.\nConclusion State management is at the core of SwiftUI\u0026rsquo;s declarative approach to building UIs. By understanding the different tools available—@State, @Binding, @ObservedObject, and @AppStorage—you can choose the right technique based on your needs, whether you\u0026rsquo;re dealing with local state, sharing data between views, or persisting information across sessions.\nUse @State for simple, view-local state. Use @Binding to share and modify parent state in child views. Use @ObservedObject and @Published for complex models and data sharing. Use @AppStorage to persist basic values across app restarts. By leveraging these tools, you\u0026rsquo;ll be able to build more dynamic, reactive, and maintainable SwiftUI applications.\nFeel free to tweak or expand on this content to suit your style and blog audience!\n","date":"2024-09-27T18:00:33+02:00","permalink":"https://blog.iostao.com/2024/09/swiftui_statemanagement/","title":"State Management in SwiftUI: @State, @Binding, and @ObservedObject"},{"content":"EnvironmentObject And ObservableObject When your view structure is complex and has multiple layers of nesting, using @EnvironmentObject allows you to share state across the entire view hierarchy without having to manually pass ObservableObject at each layer. However, you don\u0026rsquo;t need to write @EnvironmentObject var viewModel: AppViewModel at each layer. You only need to declare it in the view that really needs to access the ViewModel.\nSuppose you have a multi-layer nested view structure as follows:\n1 2 3 4 5 6 ContentView ├── LeftView │ └── SubLeftView (does not need viewModel) ├── MiddleView (does not need viewModel) └── RightView └── SubRightView (need viewModel) In this example, SubRightView needs access to AppViewModel, but the middle layers MiddleView and SubLeftView do not. Therefore, you do not need to declare @EnvironmentObject on these middle layers, only in SubRightView(and LeftView if necessary).\nLet’s take an example of a macOS app with a three-column layout: left, middle, and right views. Only the right view’s child (sub-view) needs access to a shared AppViewModel, an ObservableObject that tracks the selected option. Here\u0026rsquo;s how you can manage this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 import SwiftUI // 1. Define an ObservableObject to manage app state class AppViewModel: ObservableObject { @Published var selectedOption: String? = nil } struct ContentView: View { @StateObject var viewModel = AppViewModel() // Initialize the ViewModel var body: some View { HStack(spacing: 0) { // Left view LeftView() .frame(width: 200) // Middle view, does not need access to the ViewModel MiddleView() .frame(width: 200) // Right view RightView() .frame(maxWidth: .infinity) } .environmentObject(viewModel) // Inject ViewModel into the environment .frame(maxWidth: .infinity, maxHeight: .infinity) } } struct LeftView: View { var body: some View { VStack { Text(\u0026#34;Left View\u0026#34;) SubLeftView() // Sub-view does not need ViewModel } } } // SubLeftView does not need the ViewModel struct SubLeftView: View { var body: some View { Text(\u0026#34;Sub Left View\u0026#34;) } } struct MiddleView: View { var body: some View { Text(\u0026#34;Middle View\u0026#34;) } } struct RightView: View { var body: some View { VStack { Text(\u0026#34;Right View\u0026#34;) SubRightView() // Sub-view that needs the ViewModel } } } // SubRightView needs access to the ViewModel struct SubRightView: View { @EnvironmentObject var viewModel: AppViewModel // Access the ViewModel here var body: some View { VStack { if let option = viewModel.selectedOption { Text(\u0026#34;You selected: \\(option)\u0026#34;) } else { Text(\u0026#34;No option selected\u0026#34;) } } .frame(maxWidth: .infinity, maxHeight: .infinity) .background(Color.gray.opacity(0.1)) // Background color for the right view } } @main struct MyApp: App { var body: some Scene { WindowGroup { ContentView() } } } Explanation of the Code AppViewModel: This is an ObservableObject that holds the shared state (selectedOption). It’s marked with @Published to notify SwiftUI to update views when this value changes.\nContentView: The root view uses @StateObject to instantiate the AppViewModel and injects it into the environment using .environmentObject(viewModel). This makes viewModel available to all views within this view hierarchy.\nLeftView and SubLeftView: These views do not need access to AppViewModel, so there’s no need to declare @EnvironmentObject here. They simply display static text.\nMiddleView: Like the left views, this middle view does not need access to the shared state, so there’s no @EnvironmentObject here either.\nRightView: The right view contains a sub-view (`S\n","date":"2024-09-15T22:29:08+01:00","permalink":"https://blog.iostao.com/2024/09/swiftui_observableobject/","title":"ObservableObject and EnvironmentObject in View of SwiftUI"},{"content":"SwiftUI Localization I need to implement manual language switching in the app settings, which requires additional coding for Swift Localizable.\nInterface: SwiftUI Language: Swift5.9 Xcode: 15 As you can see in the image, the text changes when the user selects a different language.\nOperation 1. Create Localizable files 2. Add Languages 3. Localization On the right side, click Localize... A pop-up window will appear. And then click Localize to continue.\nAppState.swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import Foundation import SwiftUI final class TaoAppState: ObservableObject { @AppStorage(\u0026#34;language\u0026#34;) var language = \u0026#34;en\u0026#34; } extension String { var localized: String { let res = UserDefaults.standard.string(forKey: \u0026#34;language\u0026#34;) let path = Bundle.main.path(forResource: res, ofType: \u0026#34;lproj\u0026#34;) let bundle: Bundle if let path = path { bundle = Bundle(path: path) ?? .main } else { bundle = .main } return NSLocalizedString(self, bundle: bundle, value: \u0026#34;\u0026#34;, comment: \u0026#34;\u0026#34;) } } ChanageLanguageView.swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import SwiftUI struct ChangeLanguageView: View { @EnvironmentObject private var appState: AppState private let languages = [ \u0026#34;English\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;German\u0026#34;: \u0026#34;de\u0026#34;, \u0026#34;中文\u0026#34;: \u0026#34;zh-Hans\u0026#34; ] var body: some View { VStack { List { ForEach(Array(languages.keys), id: \\.self) { v in LabeledContent(v) { Image(systemName: \u0026#34;checkmark.circle.fill\u0026#34;) .foregroundColor(.accentColor) .opacity(isSelected(v) ? 1 : 0) } .contentShape(Rectangle()) .onTapGesture { if isSelected(v) { return } appState.language = languages[v]! } } } Text(\u0026#34;hello\u0026#34;.localized) .font(.title) .fontWeight(.bold) .foregroundStyle(.blue) Spacer() } } private func isSelected(_ language: String) -\u0026gt; Bool { appState.language == languages[language] } } #Preview { ChangeLanguageView() .environmentObject(AppState()) } ","date":"2024-02-18T14:05:02+01:00","permalink":"https://blog.iostao.com/2024/02/swiftui_localizable/","title":"SwiftUI Localization with Xcode 15"},{"content":"Swift Datetime From Jpmtech\nI need to develop a calendar module, so I have collected some information online for reference.\nPreview Code: Demo Time: 2023/12/23 21:57:54\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 VStack { // print: Dec 23, 2023 Text(Date.now, format: .dateTime.month().day().year()) // print: Dec 23, 2023 -\u0026gt; (short: Dec) Text(Date.now.formatted(date: .abbreviated, time: .omitted)) // print: December 23, 2023 (long: December) Text(Date.now.formatted(date: .long, time: .omitted)) // print: Saturday, December 23, 2023 -\u0026gt; long: December, with the weekday Text(Date.now.formatted(date: .complete, time: .omitted)) // print: 2023/12/23 (show as the number) Text(Date.now.formatted(date: .numeric, time: .omitted)) // print: AD(Anno Domini ...0...2023) Text(Date.now.formatted(.dateTime.era())) // print: Q4 (spring, summer, autumn, winter) Text(Date.now.formatted(.dateTime.quarter())) // print: Weekday: Sat Text(\u0026#34;Weekday: \u0026#34; + Date.now.formatted(.dateTime.weekday())) // print: Two Digits year: 23 Text(\u0026#34;Two Digits year: \u0026#34; + Date.now.formatted(.dateTime.year(.twoDigits))) // print: Digits year: 2023 Text(\u0026#34;Digits year: \u0026#34; + Date.now.formatted(.dateTime.year())) // Demo Time: 2023/12/23 21:57:54 // print: Month: 12 Text(\u0026#34;Month: \u0026#34; + Date.now.formatted(.dateTime.month(.twoDigits))) // print: Month: Dec Text(\u0026#34;Month: \u0026#34; + Date.now.formatted(.dateTime.month(.abbreviated))) // print: Two Digits day: 23 Text(\u0026#34;Two Digits day: \u0026#34; + Date.now.formatted(.dateTime.day(.twoDigits))) // print: Oclock: 21 Text(\u0026#34;Oclock: \u0026#34; + Date.now.formatted(.dateTime.hour(.twoDigits(amPM: .wide)))) // print: Minutes: 57 Text(\u0026#34;Minutes: \u0026#34; + Date.now.formatted(.dateTime.minute())) // print: Seconds: 54 Text(\u0026#34;Seconds: \u0026#34; + Date.now.formatted(.dateTime.second())) // print: 21:57:54 GMT+1 (hour:min:sec GMT+1, Germany) Text(Date.now.formatted(date: .omitted, time: .complete)) // print: 21:57:54 (hour:min:sec) Text(Date.now.formatted(date: .omitted, time: .standard)) // print: 21:57 Text(Date.now.formatted(date: .omitted, time: .shortened)) // how many days from the first day of this year // print: The day from first: 357 Text(\u0026#34;The day from first: \u0026#34; + Date.now.formatted(.dateTime.dayOfYear())) // how many weeks from the first day of this year // print: The week fromo first day: 51 Text(\u0026#34;The week fromo first day: \u0026#34; + Date.now.formatted(.dateTime.week())) // the first letter of the month // J: January, February: F,..., December: D // print: First letter of the Month: D Text(\u0026#34;First letter of the Month: \u0026#34; + Date.now.formatted(.dateTime.month(.narrow))) } ","date":"2023-12-23T20:36:12+01:00","permalink":"https://blog.iostao.com/2023/12/swift_datetime/","title":"Swift Dates and Times"},{"content":"I\u0026rsquo;m currently developing an App, and I aim to realize multiple theme colors. Users will have the option to switch between themes such as red, orange, blue and others. Therefore, I\u0026rsquo;m documenting how this functionality is implemented here.\nFirst, let\u0026rsquo;s take a look at the demo to see the visual effects. Here, I\u0026rsquo;ve created a demo where clicking on different themes will cause the app to change its theme color accordingly.\nTheme Color Theme Code TaoAppTheme First, define an enum Theme (I did use the name: TaoAppTheme) and implement some methods inside:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import Foundation import SwiftUI enum TaoAppTheme: String, CaseIterable, Identifiable { var id: Self {self} case App_Theme_orange = \u0026#34;yellow\u0026#34; case App_Theme_green = \u0026#34;green\u0026#34; case App_Theme_blue = \u0026#34;blue\u0026#34; case App_Theme_cyan = \u0026#34;cyan\u0026#34; case App_Theme_red = \u0026#34;red\u0026#34; /// Haupt-Hintergrundfarbe static func bgPrimaryWhite() -\u0026gt; Color { return Color(\u0026#34;BgWhite\u0026#34;) } // static func bgPrimaryGray() -\u0026gt; Color { return Color(\u0026#34;BgGray\u0026#34;) } var color: Color { return themeColor() } func themeColor() -\u0026gt; Color { switch self { case .App_Theme_orange: return Color(\u0026#34;AppOrange\u0026#34;) case .App_Theme_green: return Color(\u0026#34;AppGreen\u0026#34;) case .App_Theme_blue: return Color(\u0026#34;AppBlue\u0026#34;) case .App_Theme_cyan: return Color(\u0026#34;AppCyan\u0026#34;) case .App_Theme_red: return Color(\u0026#34;AppRed\u0026#34;) } } static func nowTheme() -\u0026gt; TaoAppTheme { guard let theme:String = UserDefaults.standard.string(forKey: \u0026#34;TaoAppThemeKey\u0026#34;) else{ return .App_Theme_blue } guard let nowThemeType = TaoAppTheme(rawValue: theme) else{ return .App_Theme_blue } return nowThemeType } } TaoAppState Then, define an AppState to store the state values of the app.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Foundation import SwiftUI final class TaoAppState: ObservableObject { @Published var appTheme: TaoAppTheme = .App_Theme_blue init() { // das Thema erhalten appTheme = TaoAppTheme.nowTheme() } func setTheme(theme: TaoAppTheme){ UserDefaults.standard.setValue(theme.rawValue, forKey: \u0026#34;TaoAppThemeKey\u0026#34;) self.appTheme = theme print(\u0026#34;theme: \\(theme.rawValue)\u0026#34;) } } XXXApp.swift Finally, inject it at the entry(@main) point of the app.\n1 2 3 4 5 6 7 8 9 10 11 @main struct DoBillApp: App { @StateObject private var appState = TaoAppState() var body: some Scene { WindowGroup { ContentView() .environmentObject(appState) } } } Employ 1 @EnvironmentObject var appState:APPState View\u0026rsquo;s Theme\n1 2 Rectangle() .foregroundStyle(appState.appTheme.themeColor()) Click Button to change Theme\n1 2 3 4 5 6 Button(action: { //appState.setTheme(theme: theme) appState.setTheme(theme: . App_Theme_orange) }, label: { Text(\u0026#34;Change Theme\u0026#34;) }) Demo View 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import SwiftUI struct TaoHomeView: View { @EnvironmentObject var appState: TaoAppState @State private var themeIndex = 0 var body: some View { VStack { ForEach(TaoAppTheme.allCases) { theme in Button(action: { appState.setTheme(theme: theme) }, label: { Text(\u0026#34;Change Theme: \\(theme.rawValue)\u0026#34;) }) .buttonStyle(.borderedProminent) .buttonBorderShape(.capsule) .controlSize(.large) .tint(theme.color) } Rectangle() .foregroundStyle(appState.appTheme.themeColor()) .frame(height: 200) } } } #Preview { TaoHomeView() .environmentObject(TaoAppState()) } ","date":"2023-12-21T13:55:16+01:00","permalink":"https://blog.iostao.com/2023/12/swiftui_change_theme/","title":"How to change the App Theme"},{"content":"Swift static func == (lhs: XXX, rhs: XXX) -\u0026gt; Bool It\u0026rsquo;s been a long time since I last wrote code. While I was programming, I encountered something I don\u0026rsquo;t understand. Why is the symbol \u0026lsquo;==\u0026rsquo; used in function names?\u0026quot;\n1 static func == (lhs: Person, rhs: Person) -\u0026gt; Bool { After studying, I realized that \u0026ldquo;==\u0026rdquo; is simply the equality operator in programming, used to compare two values to see if they are equal. LOL!\nCode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person: Equatable { var name: String var age: Int init(name: String, age: Int) { self.name = name self.age = age } // Symbol \u0026#34;==\u0026#34; used in function // Here I have set two conditions: // if both the name and age are the same, // then they are the same person. static func == (lhs: Person, rhs: Person) -\u0026gt; Bool { return lhs.name == rhs.name \u0026amp;\u0026amp; lhs.age == rhs.age } } Example: 1 2 3 4 5 6 let p1 = Person(name: \u0026#34;David\u0026#34;, age: 18) let p2 = Person(name: \u0026#34;David\u0026#34;, age: 18) if p1 == p2 { print(\u0026#34;It\u0026#39;s the same person\u0026#34;) } Comparable same as == 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public protocol Comparable: Equatable { static func \u0026lt; (lhs: Self, rhs: Self) -\u0026gt; Bool static func \u0026lt;= (lhs: Self, rhs: Self) -\u0026gt; Bool static func \u0026gt;= (lhs: Self, rhs: Self) -\u0026gt; Bool static func \u0026gt; (lhs: Self, rhs: Self) -\u0026gt; Bool } extension Comparable { @inlinable public static func \u0026gt; (lhs: Self, rhs: Self) -\u0026gt; Bool { return rhs \u0026lt; lhs } @inlinable public static func \u0026lt;= (lhs: Self, rhs: Self) -\u0026gt; Bool { return !(rhs \u0026lt; lhs) } @inlinable public static func \u0026gt;= (lhs: Self, rhs: Self) -\u0026gt; Bool { return !(lhs \u0026lt; rhs) } } ","date":"2023-12-17T00:00:46+01:00","permalink":"https://blog.iostao.com/2023/12/swift_static_funclhs_rhs/","title":"Swift static func == (lhs: XXX, rhs: XXX) -\u003e Bool"},{"content":"iOS Widget Demo-06 Download.zip Give users the option to customize their widgets by adding a custom Intent definition to your project. (Developer Documentation)\nIf possible, please see the Article \u0026ldquo;iOS Widget 05\u0026rdquo; first.\nPreview Widget\u0026rsquo;s Preview with select.\nWidget - Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import Intents class IntentHandler: INExtension, ConfigurationIntentHandling, CustomConfigurationIntentHandling { override func handler(for intent: INIntent) -\u0026gt; Any { // This is the default implementation. If you want different objects to handle different intents, // you can override this and return the handler you want for that particular intent. return self } /// CustomConfigurationIntentHandling // provide [Parameter] OptionsCollection // in the CustomConfigurationIntent func provideSecondTypeOptionsCollection(for intent: CustomConfigurationIntent, with completion: @escaping (INObjectCollection\u0026lt;SecondExchange\u0026gt;?, Error?) -\u0026gt; Void) { // Create a collection with the array of characters. let collection = INObjectCollection(items: IntentHandler.secondTypes) // Call the completion handler, passing the collection. completion(collection, nil) } /// ConfigurationIntentHandling // provide [Parameter] OptionsCollection // in the ConfigurationIntent func provideExchangeOptionsCollection(for intent: ConfigurationIntent, with completion: @escaping (INObjectCollection\u0026lt;CustomExchange\u0026gt;?, Error?) -\u0026gt; Void) { // Create a collection with the array of characters. let collection = INObjectCollection(items: IntentHandler.exchanges) // Call the completion handler, passing the collection. completion(collection, nil) } public static var exchanges: [CustomExchange] { [ CustomExchange(identifier: \u0026#34;CNY\u0026#34;, display: \u0026#34;人民币\u0026#34;), CustomExchange(identifier: \u0026#34;USD\u0026#34;, display: \u0026#34;美元\u0026#34;), CustomExchange(identifier: \u0026#34;GBP\u0026#34;, display: \u0026#34;英镑\u0026#34;), CustomExchange(identifier: \u0026#34;EUR\u0026#34;, display: \u0026#34;欧元\u0026#34;), CustomExchange(identifier: \u0026#34;CAD\u0026#34;, display: \u0026#34;加拿大元\u0026#34;), CustomExchange(identifier: \u0026#34;HKD\u0026#34;, display: \u0026#34;港元\u0026#34;), CustomExchange(identifier: \u0026#34;MOP\u0026#34;, display: \u0026#34;澳门元\u0026#34;), CustomExchange(identifier: \u0026#34;THB\u0026#34;, display: \u0026#34;泰铢\u0026#34;), CustomExchange(identifier: \u0026#34;SGD\u0026#34;, display: \u0026#34;新加坡元\u0026#34;), ] } public static var secondTypes: [SecondExchange] { [ SecondExchange(identifier: \u0026#34;CNY\u0026#34;, display: \u0026#34;Yuan\u0026#34;), SecondExchange(identifier: \u0026#34;USD\u0026#34;, display: \u0026#34;Dollor\u0026#34;), SecondExchange(identifier: \u0026#34;GBP\u0026#34;, display: \u0026#34;Pound\u0026#34;), SecondExchange(identifier: \u0026#34;EUR\u0026#34;, display: \u0026#34;Euro\u0026#34;), ] } } ","date":"2022-11-08T14:35:21+08:00","permalink":"https://blog.iostao.com/2022/11/swiftui-widget-06/","title":"iOS Widget 06 - Making a Dynamic Configurable Widget for tow Intent"},{"content":"Demo-05 Download.zip Give users the option to customize their widgets by adding a custom Intent definition to your project. (Developer Documentation)\nIf possible, please see the Article \u0026ldquo;iOS Widget 02\u0026rdquo; first.\nExpect Widget Widget add New Type If you don\u0026rsquo;t need use the Siri, please don\u0026rsquo;t select the CheckBox.\nadd Target: Intents Extension Target Membership We need add the Target Membership for the files.\nImplementation Please remember the name of the Intents (the Number - \u0026ldquo;2\u0026rdquo;), in my Project the first Intent\u0026rsquo;s name is \u0026ldquo;Configuration\u0026rdquo;\nand the Parameter \u0026ldquo;exchange\u0026rdquo; (the Number - \u0026ldquo;4\u0026rdquo;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import Intents class IntentHandler: INExtension, ConfigurationIntentHandling { override func handler(for intent: INIntent) -\u0026gt; Any { // This is the default implementation. If you want different objects to handle different intents, // you can override this and return the handler you want for that particular intent. return self } // provide [Parameter] OptionsCollection // in the Intentdefinition func provideExchangeOptionsCollection(for intent: ConfigurationIntent, with completion: @escaping (INObjectCollection\u0026lt;CustomExchange\u0026gt;?, Error?) -\u0026gt; Void) { // Create a collection with the array of characters. let collection = INObjectCollection(items: IntentHandler.exchanges) // Call the completion handler, passing the collection. completion(collection, nil) } public static var exchanges: [CustomExchange] { [ CustomExchange(identifier: \u0026#34;CNY\u0026#34;, display: \u0026#34;人民币\u0026#34;), CustomExchange(identifier: \u0026#34;USD\u0026#34;, display: \u0026#34;美元\u0026#34;), CustomExchange(identifier: \u0026#34;GBP\u0026#34;, display: \u0026#34;英镑\u0026#34;), CustomExchange(identifier: \u0026#34;EUR\u0026#34;, display: \u0026#34;欧元\u0026#34;), CustomExchange(identifier: \u0026#34;CAD\u0026#34;, display: \u0026#34;加拿大元\u0026#34;), CustomExchange(identifier: \u0026#34;HKD\u0026#34;, display: \u0026#34;港元\u0026#34;), CustomExchange(identifier: \u0026#34;MOP\u0026#34;, display: \u0026#34;澳门元\u0026#34;), CustomExchange(identifier: \u0026#34;THB\u0026#34;, display: \u0026#34;泰铢\u0026#34;), CustomExchange(identifier: \u0026#34;SGD\u0026#34;, display: \u0026#34;新加坡元\u0026#34;), ] } } Result Widget Widget ","date":"2022-11-08T11:57:53+08:00","permalink":"https://blog.iostao.com/2022/11/swiftui-widget-05/","title":"iOS Widget 05 - Making a Dynamic Configurable Widget"},{"content":"1. Navigation Bar Hidden .navigationBarHidden(true) In SwiftUI Project when we write this code, the NavigationBar will be hidden, but the slip back will also be invalid. At this time, we can add Navigation Extension.\n2. Extension 1 2 3 4 5 6 7 8 9 extension UINavigationController: UIGestureRecognizerDelegate { override open func viewDidLoad() { super.viewDidLoad() interactivePopGestureRecognizer?.delegate = self } public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -\u0026gt; Bool { return viewControllers.count \u0026gt; 1 } } When we add the extension, then run the project, we will found we did resolve the problem. So easy.\n","date":"2022-10-12T20:56:39+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-navigation-slipback/","title":"SwiftUI NavigationBar Hidden, Slipe Back Problem"},{"content":" VStack: A view that arranges its subviews in a vertical line. HStack: A view that arranges its subviews in a horizontal line. ZStack: A view that overlays its subviews, aligning them in both axes. VStack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var body: some View { VStack { RoundedRectangle(cornerRadius: 35) .foregroundColor(.orange) .frame(width: 100, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.green) .frame(width: 100, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.cyan) .frame(width: 100, height: 100) } } // Please see the Effect: Img 01 Effect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Please see the Effect: Img 02 var body: some View { VStack(alignment:.trailing, spacing: 50) { RoundedRectangle(cornerRadius: 35) .foregroundColor(.orange) .frame(width: 150, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.green) .frame(width: 200, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.cyan) .frame(width: 100, height: 100) } } If the frame of the VStack is not set, the VStack will calculate its own size according to the size of the element.\nWe can see that the width of the VStack is equal to the width of the widest rectangle, and the height is equal to the height of 3 rectangles plus the size of spacing. (Effect: Img 03)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // (Effect: Img 03) var body: some View { VStack(alignment:.trailing, spacing: 50) { RoundedRectangle(cornerRadius: 35) .foregroundColor(.orange) .frame(width: 150, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.green) .frame(width: 200, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.cyan) .frame(width: 100, height: 100) } .background(Color.indigo) } Effect We can make the VStack size equal to the size of the parent node by setting the frame\u0026rsquo;s maxWidth and maxHeight to infinity. (Effect: Img 04)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // (Effect: Img 04) var body: some View { VStack(alignment:.trailing, spacing: 50) { RoundedRectangle(cornerRadius: 35) .foregroundColor(.orange) .frame(width: 150, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.green) .frame(width: 200, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.cyan) .frame(width: 100, height: 100) } .frame(maxWidth:.infinity, maxHeight: .infinity) .background(Color.indigo) } Set the frame and also set the alignment to control the position of the child elements in the VStack. And if you found the view withe the boundary, you can by setting edgesIgnoringSafeArea, the layout can be extended to the safe area area.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var body: some View { VStack(alignment:.trailing, spacing: 50) { RoundedRectangle(cornerRadius: 35) .foregroundColor(.orange) .frame(width: 150, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.green) .frame(width: 200, height: 100) RoundedRectangle(cornerRadius: 35) .foregroundColor(.cyan) .frame(width: 100, height: 100) } .frame(maxWidth:.infinity, maxHeight: .infinity, alignment: .bottomTrailing) .background(Color.indigo) } Effect HStack \u0026amp; ZStack HStack and ZStack and VStack are only in different directions. The other usages are basically the same as VStack.\nHStack is arranged horizontally.\nZStack is stacked on the Z axis.\n","date":"2022-10-11T16:11:39+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-layout-stack/","title":"SwiftUI Layout - VStack / HStack / ZStack"},{"content":" LazyHGrid Documents LazyVGrid Documents LazyVGrid and LazyHGrid, one is a vertical grid layout and the other is a horizontal grid layout. The new layout manager of iOS14, like LazyVGrid and LazyHStack with Lazy, indicating that Layout managers will only drawing the child elements when need to be displayed.\nLazyVGrid LazyVGrid fills the layout by specifying the number of columns.\n01 02 The filling order of LazyVGrid is from the top row by row, and when one row is filled, will fill the next row. It\u0026rsquo;s easy to understand from the alphabetical displayed in the above figure.\nThe Code of Left Picture\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var columns: [GridItem] = [ GridItem(.fixed(100)), GridItem(.fixed(100)), GridItem(.fixed(100)) ] var body: some View { // you can use colums array or directory write code in the lines. // LazyVGrid(columns: columns) { LazyVGrid(columns: [GridItem(.fixed(100)), GridItem(.fixed(100)), GridItem(.fixed(100))]){ ForEach(0 ..\u0026lt; 30){ index in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.03 * Double(index) , saturation: 1, brightness: 1)) .frame(height: 50) .overlay(Text(\u0026#34;\\(String(Unicode.Scalar(65 + index)!))\u0026#34;)) } } .padding() } The Code of Left Picture\n1 2 3 4 5 6 7 8 9 10 11 12 13 // The row spacing can be adjusted by setting the spacing of LazyVGrid var body: some View { LazyVGrid(columns: [GridItem(.fixed(100)), GridItem(.fixed(100)), GridItem(.fixed(100))], spacing: 30){ ForEach(0 ..\u0026lt; 30){ index in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.03 * Double(index) , saturation: 1, brightness: 1)) .frame(height: 50) .overlay(Text(\u0026#34;\\(String(Unicode.Scalar(127881 + index)!))\u0026#34;)) } } .padding() } Header and Footer LazyVGrid can make the Header and Footer hover at the top and bottom when scrolling by setting the PinnedViews type. Set the header and footer of Section through Section.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 VStack { ScrollView { LazyVGrid(columns: [GridItem(.fixed(100)), GridItem(.fixed(100)), GridItem(.fixed(100))], pinnedViews: [.sectionHeaders, .sectionFooters]){ ForEach(0 ..\u0026lt; 5){ index in Section(header: Text(\u0026#34;Header \\(index)\u0026#34;) .bold() .font(.title) .frame(maxWidth: .infinity, alignment: .leading) .background(Color.white), footer: Text(\u0026#34;Footer \\(index)\u0026#34;) .bold() .font(.title) .frame(maxWidth: .infinity, alignment: .leading) .background(Color.white) ) { ForEach(0 ..\u0026lt; 10){ idx in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.03 * Double(index * 10 + idx) , saturation: 1, brightness: 1)) .frame(height: 50) .overlay(Text(\u0026#34;\\(index * 10 + idx)\u0026#34;)) } } } } .padding() } } .clipped() 01 02 GridItem GridItem controls the width by the GridSize\nEnumeration Cases\ncase adaptive(minimum: CGFloat, maximum: CGFloat)\nMultiple items in the space of a single flexible item.\ncase fixed(CGFloat)\nA single item with the specified fixed size.\ncase flexible(minimum: CGFloat, maximum: CGFloat)\nA single flexible item.\nGeometryReader is a special View that can get coordinate size information.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var body: some View { LazyVGrid(columns: [GridItem(.flexible()), GridItem(.adaptive(minimum: 50), spacing: 0)]){ ForEach(0 ..\u0026lt; 30){ index in GeometryReader{ proxy in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.1 * Double(index) , saturation: 1, brightness: 1)) .overlay(Text(\u0026#34;\\(proxy.size.width)\u0026#34;)) } .frame(height: 50) } } .padding() } 1 2 3 4 5 6 7 8 9 10 var body: some View { LazyVGrid(columns: [GridItem(.flexible(), spacing: 10), GridItem(.flexible(), spacing: 100), GridItem(.flexible(), spacing: 50)]){ ForEach(0 ..\u0026lt; 30){ idx in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.0333 * Double(idx) , saturation: 1, brightness: 1)) .frame(height: 50) } } .padding() } We can see from the running effect that only the set space will be added to the right side of the grid.\nEffect Alignment Alignment: use this property to anchor the view’s relative position to the same relative position in the view’s assigned grid space. Similar to the usage of frame's Alignment.\n1 2 3 4 5 6 7 8 9 10 var body: some View { LazyVGrid(columns: [GridItem(.flexible(), alignment: .topLeading), GridItem(.flexible(), alignment: .bottomLeading), GridItem(.flexible(), alignment: .trailing)]) { ForEach(0 ..\u0026lt; 30, id: \\.self){ index in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.01 * Double(index * 10), saturation: 1, brightness: 1)) .frame(width: CGFloat((index % 3) + 1) * 20, height: CGFloat((index % 3) + 1) * 20) } } .padding() } Effect LazyHGrid LazyHGrid and LazyVGrid are simliar in uasge. LazyHGrid specified the number of rows, fill the specified number of rows from top to bottom, and then fills the second column.\nHow to achieve an irregular Effect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var body: some View { LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]){ ForEach(0 ..\u0026lt; 11){ idx in GeometryReader { r in RoundedRectangle(cornerRadius: 5) .foregroundColor(Color(hue: 0.1 * Double(idx) , saturation: 1, brightness: 1)) .frame(width: idx == 6 ? 2 * r.size.width + 10 : r.size.width ) } .frame(height: 100) if idx == 6 { Color.clear } } } .padding() } ","date":"2022-10-11T11:09:01+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-layout-lazygrid/","title":"SwiftUI Layout - LazyVGrid \u0026 LazyHGrid"},{"content":"From Apple Document If your app has a minimum deployment target of iOS 16, iPadOS 16, macOS 13, tvOS 16, or watchOS 9, or later, transition away from using NavigationView. In its place, use NavigationStack and NavigationSplitView instances.\nI need a list of Collections, and the custom Cell, then with NavigationStack link to the next View.\nDemo Download.zip\nCardView 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import SwiftUI struct CardView: View { let title: String let color: Color = .random var body: some View { VStack { RoundedRectangle(cornerRadius: 12).foregroundColor(color) Text(title) .font(.title2) } } } struct CardView_Previews: PreviewProvider { static var previews: some View { CardView(title: \u0026#34;Hello world\u0026#34;) } } extension Color { static var random: Color { return Color( red: .random(in: 0...1), green: .random(in: 0...1), blue: .random(in: 0...1) ) } } struct MockStore { static var cards = [ Card(title: \u0026#34;Sun\u0026#34;), Card(title: \u0026#34;Mercury\u0026#34;), Card(title: \u0026#34;Venus\u0026#34;), Card(title: \u0026#34;Earth\u0026#34;), Card(title: \u0026#34;Mars\u0026#34;), Card(title: \u0026#34;Jupiter\u0026#34;), Card(title: \u0026#34;Saturn\u0026#34;), Card(title: \u0026#34;Uranus\u0026#34;), Card(title: \u0026#34;Neptune\u0026#34;), Card(title: \u0026#34;Pluto\u0026#34;), Card(title: \u0026#34;Solar System\u0026#34;), Card(title: \u0026#34;Galaxy\u0026#34;), Card(title: \u0026#34;Universe\u0026#34;), Card(title: \u0026#34;Remote Antiquity\u0026#34;), Card(title: \u0026#34;Foreworld\u0026#34;), ] } struct Card: Identifiable, Hashable { let id = UUID() let title: String func hash(into hasher: inout Hasher) { hasher.combine(id) // hasher.combine(title) } } View NavigationStack ContentView 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import SwiftUI struct ContentView: View { //about GridItem https://developer.apple.com/documentation/swiftui/griditem/size-swift.enum var columns: [GridItem] = [ GridItem(.flexible(minimum: 140)), GridItem(.flexible()), GridItem(.flexible()), ] let cards: [Card] = MockStore.cards var body: some View { NavigationStack { ScrollView(.vertical, showsIndicators: false) { LazyVGrid(columns: columns, spacing: 16) { ForEach(cards) { card in NavigationLink(value: card) { CardView(title: card.title) .frame(height: 150) } .navigationDestination(for: Card.self) { card in Text(card.title) .foregroundColor(.orange) .font(.system(size: 100)) } } } } } } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } ","date":"2022-10-10T20:37:16+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-collection-navigationstack/","title":"SwiftUI Collection + NavigationStack"},{"content":"I did write a clock widget, but I found that there is a problem every time the clock is refreshed. eg. now is 17:42:25, the widget still is 17:41, maybe after 10 seconds, it can be refreshed with 17:42. I want just 17:43:00, it can be refreshed.\nDemo-04 Download.zip\nPreview Add Widget Display Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 struct DemoProvider: IntentTimelineProvider { func placeholder(in context: Context) -\u0026gt; DemoEntry { DemoEntry(date: Date(), configuration: ConfigurationIntent()) } func getSnapshot(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (DemoEntry) -\u0026gt; ()) { let entry = DemoEntry(date: Date(), configuration: configuration) completion(entry) } func getTimeline(for configuration: ConfigurationIntent, in context: Context, completion: @escaping (Timeline\u0026lt;DemoEntry\u0026gt;) -\u0026gt; ()) { // First refresh time: 2 seconds delay let firstDate = DemoProvider.getFirstEntryDate() // Second refresh time: When at the first full minute refresh let firstMinuteDate = DemoProvider.getFirstMinuteEntryDate() var entries: [DemoEntry] = [] entries.append(DemoEntry(date: firstDate, configuration: configuration)) entries.append(DemoEntry(date: firstMinuteDate, configuration: configuration)) // Generate a timeline consisting of five entries an hour apart, starting from the current date. for offset in 1 ..\u0026lt; 5 { guard let entryDate = Calendar.current.date(byAdding: .minute, value: offset, to: firstMinuteDate) else { continue } let entry = DemoEntry(date: entryDate, configuration: configuration) entries.append(entry) } let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline) } static func getFirstEntryDate() -\u0026gt; Date { let offsetSecond: TimeInterval = TimeInterval(2) var currentDate = Date() currentDate += offsetSecond return currentDate } // Get the time point of the first minute time point // eg: 14:10:00 static func getFirstMinuteEntryDate() -\u0026gt; Date { var currentDate = Date() let passSecond = Calendar.current.component(.second, from: currentDate) let offsetSecond: TimeInterval = TimeInterval(60 - passSecond) currentDate += offsetSecond return currentDate } } struct CYClockTime { var sec: Int var min: Int var hour: Int } struct DemoEntry: TimelineEntry { let date: Date let configuration: ConfigurationIntent func clockTime() -\u0026gt; CYClockTime { let date = self.date let calendar = Calendar.current let hour = calendar.component(.hour, from: date) let min = calendar.component(.minute, from: date) let sec = calendar.component(.second, from: date) print(\u0026#34;\\(hour) \\(min) \\(sec) || \\(self.date)\u0026#34;) return CYClockTime(sec: sec, min: min, hour: hour) } func clockHHss() -\u0026gt; String { let hour = String(format: \u0026#34;%.2d\u0026#34;, clockTime().hour) let min = String(format: \u0026#34;%.2d\u0026#34;, clockTime().min) return hour + \u0026#34; \u0026#34; + min } } 1 2 3 4 5 6 7 8 9 10 // Widget View struct DemoWidgetEntryView : View { var entry: DemoProvider.Entry let width = (UIScreen.main.bounds.width - 50) / 3 var body: some View { Text(\u0026#34;\\(entry.clockHHss())\u0026#34;) } } ","date":"2022-10-07T18:00:18+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-widget-04/","title":"iOS Widget 04 - Widget Clock Refresh"},{"content":"If you want to select a widget bundle based on some logic, example in App has 10 Widgets, but I just want to display two Widgets when man add the Widgets in the Desktop. You can do the following:\nDemo-03 Download.zip\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @main // Use the customized WidgetBundle as the initialization entry of the widget struct WidgetLauncher { static func main() { var isShowAll: Bool { // Put logic here false } // or can with other logic if isShowAll { CustomWidgetBundle.main() } else { CustomWidgetBundle1.main() } } } struct CustomWidgetBundle: WidgetBundle { @WidgetBundleBuilder var body: some Widget { Widget1() Widget2() Widget3() } } struct CustomWidgetBundle1: WidgetBundle { @WidgetBundleBuilder var body: some Widget { Widget4() Widget5() } } Targets ","date":"2022-10-07T17:16:25+08:00","permalink":"https://blog.iostao.com/2022/10/swiftui-widget-03/","title":"iOS Widget 03 - Dynamic Launcher Widgets"},{"content":"iOS Edit Widget Demo-02 Download.zip Give users the option to customize their widgets by adding a custom Intent definition to your project.\nThe Details Info you can read the Developer Documentation\nIn this article we just use the fixed values, if you want to obtain dynamic parameters, please see my article \u0026ldquo;iOS Widget 05\u0026rdquo;\nPreview Operate Go to Intentdefinition, and add a new Enum, you can follows the step in the images. Change the name like ContentType, and add some cases like image, time, text (also you can make name like type1, type2, type3).\n(My blog is not good, so you can enlarge the page to view the picture.(灬ꈍ ꈍ灬))\nFollow the steps.\nThen you can write code, please see the code of case .type2:. In here you can add the other Widgets. Please download my demo and see the effect. Thanks.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Widget View struct MainWidgetEntryView : View { var entry: Provider.Entry var body: some View { switch entry.configuration.type { case .image: Image(\u0026#34;wazi\u0026#34;) .resizable() .scaledToFill() case .time: Text(entry.date, style: .time) case .text: Text(\u0026#34;Text\u0026#34;) case .unknown: Text(\u0026#34;Default\u0026#34;) } } } ","date":"2022-10-07T16:35:19+21:00","permalink":"https://blog.iostao.com/2022/10/swiftui-widget-02/","title":"iOS Widget 02 - Making a Configurable Widget"},{"content":"Demo-01 Download.zip\nBuild iOS Widget Let\u0026rsquo;s start by building our simple App. Open up Xcode and create a new iOS App Project; make sure SwiftUI is selected in the Interface options and SwiftUI App is selected in the Life Cycle options.\nAnd then create a new target. File -\u0026gt; New -\u0026gt; Target. In the searchText input Widget, select Widget Extension and go to Next. Then will got a Activate “MainWidgetExtension” scheme?, select Activate.\ncreateApp create Target - - In the Left Bar we can see the Widget Target Code, and we can see the widget\u0026rsquo;s preview. Just change the body code, can update the Widget View.\nCode ","date":"2022-10-07T16:30:19+21:00","permalink":"https://blog.iostao.com/2022/10/swiftui-widget-01/","title":"iOS Widget 01 - Build Your First iOS Widget"},{"content":"Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import SwiftUI struct ChargeNormalView: View { private let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect() var width: CGFloat = 200 // you can comment on this line of code, so funny var color1 = #colorLiteral(red: 0.2078431487, green: 0.56745098062, blue: 0.5333333433, alpha: 1) var color2 = #colorLiteral(red: 0.6078431487, green: 0.06745098062, blue: 0.5333333433, alpha: 1) @State var percent: CGFloat = 0 var body: some View { let mutiplier = width / 44 let progress = 1 - percent / 100 return ZStack { Circle() .stroke(Color.black.opacity(0.1), style: StrokeStyle(lineWidth: 5 * mutiplier)) .frame(width: width, height: width) Circle() .trim(from: progress, to: 1) .stroke( LinearGradient(gradient: Gradient(colors: [Color(color1), Color(color2)]), startPoint: .topLeading, endPoint: .bottomTrailing), style: StrokeStyle(lineWidth: 5 * mutiplier, lineCap: .round, lineJoin: .round) ) .rotationEffect(Angle(degrees: 90)) .rotation3DEffect(Angle(degrees: 180), axis: (x: 1, y: 0, z: 0)) .frame(width: width, height: width) .shadow(color: Color(color1).opacity(0.1), radius: 3, x: 0, y: 3) Text(\u0026#34;\\(Int(percent))%\u0026#34;) .font(.system(size: 14 * mutiplier)) .fontWeight(.bold) .onReceive(timer) { time in if percent \u0026gt;= 100 { percent = 100 // need cancel timer self.timer.upstream.connect().cancel() } else { percent += 10 } print(\u0026#34;The time is now \\(time)\u0026#34;) } } } } Preview ","date":"2022-09-30T20:55:19+21:00","permalink":"https://blog.iostao.com/2022/09/swiftui-progress-circle/","title":"SwiftUI Circlar Progress Bar "},{"content":"How to realize flexible animation of pictures? It\u0026rsquo;s very simple to use SwiftUI now.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 var body: some View { ScrollView(showsIndicators: false) { VStack { GeometryReader { proxy in let global = proxy.frame(in: .global) Image(\u0026#34;wazi\u0026#34;) .resizable() .offset(y: global.minY \u0026gt; 0 ? -global.minY : 0) .frame(height: global.minY \u0026gt; 0 ? UIScreen.main.bounds.height / 3 + global.minY : UIScreen.main.bounds.height / 3) } .frame(height: UIScreen.main.bounds.height / 3) VStack(spacing: 10) { ForEach(0...10, id:\\.self) { num in Rectangle() .fill(.red.opacity(0.5)) .frame(height: 60) } } } } } ","date":"2022-09-23T18:54:07+08:00","permalink":"https://blog.iostao.com/2022/09/swiftui-animation-scale-image/","title":"SwiftUI Animation Scale Image"},{"content":"It has been proved that if a string in Text(\u0026ldquo;home) is passed as a text, it can only be interpreted as a localized keyword. If the variable is String type, it doesn\u0026rsquo;t occur. So the answer is to declare a variable of LocalizedStringKey type.\nThis is the unexpected code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct TabItem: Identifiable { var id = UUID() var name: String var icon: String var tab: TabEnum } var tabItems = [ TabItem(name: \u0026#34;home\u0026#34;, icon: \u0026#34;house\u0026#34;, tab: .home), ] ForEach(tabItems) { item in // string localizable not working in here // item.name is \u0026#34;home\u0026#34; Text(item.name) // but if write code like this, it\u0026#39;s ok Text(\u0026#34;home\u0026#34;) } We just need to replace String to LocalizedStringKey. Then we will found the result is OK. Just like this code:\n1 2 3 4 5 6 7 struct TabItem: Identifiable { var id = UUID() // declare LocalizedStringKey type will be ok~ ^_^ var name: LocalizedStringKey var icon: String var tab: TabEnum } ","date":"2022-09-20T19:56:35+08:00","permalink":"https://blog.iostao.com/2022/09/swiftui-string-localization-notwork/","title":"Why does string localization/internationalization not work in SwiftUI"},{"content":"Setting multiple tabbars in UIKit requires UITabBarController. But it\u0026rsquo;s implemented through TabView in the SwiftUI.\nIn this Article we will also introduce how to hide TabBar when view pushed.\nDemo Download.zip\nIn this Demo with other Codes, I\u0026rsquo;m also learning SwiftUI, in the ContentView, you can change code like this to see my Project Demo.\n1 2 3 4 5 6 7 8 struct ContentView: View { var body: some View { RootView() // NavigationView { // TabBarController() // } } } TabBar Animation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import SwiftUI struct TabBarContentView: View { @State private var selectedTab = 0 var body: some View { ZStack(alignment: .bottom) { TabView(selection: $currTab) { HomeView() .frame(maxWidth: .infinity, maxHeight: .infinity) .tag(TabEnum.home) ToolView() .frame(maxWidth: .infinity, maxHeight: .infinity) .tag(TabEnum.tool) TimerView() .frame(maxWidth: .infinity, maxHeight: .infinity) .tag(TabEnum.timer) MyView() .frame(maxWidth: .infinity, maxHeight: .infinity) .tag(TabEnum.my) } TabBarView(selectedTab: $currTab, safeEdgeInsets: proxy.safeAreaInsets) } // .safeAreaInset(edge: .bottom) { // Color.green.frame(height: 80) // } // .safeAreaInset(edge: .top) { // Color.green.frame(height: 104) // } } } TabBarView\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import SwiftUI struct TabBarView: View { @Binding var selectedTab: TabEnum var safeEdgeInsets: EdgeInsets var body: some View { VStack { Spacer() HStack { content } .padding(12) .background(Color(.black).opacity(0.8)) .background(.ultraThinMaterial) .mask(RoundedRectangle(cornerRadius: 24, style: .continuous)) .shadow(color: .red.opacity(0.8), radius: 20, x: 0, y: 20) .overlay( RoundedRectangle(cornerRadius: 24, style: .continuous) .stroke(.linearGradient(colors: [.white.opacity(0.5), .white.opacity(0)], startPoint: .topLeading, endPoint: .bottomTrailing)) ) .padding(.horizontal, 24) } .padding(.bottom, safeEdgeInsets.bottom == 0 ? 20 : safeEdgeInsets.bottom + 10) } var content: some View { ForEach(tabItems) { item in Button { withAnimation { selectedTab = item.tab } } label: { Image(systemName: item.icon) .frame(height: 36) .foregroundColor(.white) .opacity(selectedTab == item.tab ? 1 : 0.5) .background( VStack { RoundedRectangle(cornerRadius: 2) .fill(Color.accentColor) .frame(width: selectedTab == item.tab ? 30 : 0, height: 4) .offset(y: -4) .opacity(selectedTab == item.tab ? 1 : 0) Spacer() } ) } // tabBarItem Equal width .frame(maxWidth: .infinity) } } } struct TabBarView_Previews: PreviewProvider { static var previews: some View { TabBarView(selectedTab: .constant(.home), safeEdgeInsets: EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0)) } } struct TabItem: Identifiable { var id = UUID() var icon: String var tab: TabEnum } var tabItems = [ TabItem(icon: \u0026#34;house\u0026#34;, tab: .home), TabItem(icon: \u0026#34;bag.badge.plus\u0026#34;, tab: .tool), TabItem(icon: \u0026#34;alarm.waves.left.and.right\u0026#34;, tab: .timer), TabItem(icon: \u0026#34;person\u0026#34;, tab: .my), ] enum TabEnum: String { case home case tool case timer case my } Hide TabBar TabBar needs to be hidden when navigation from one page to the next interface. But the esisting SwiftUI doesn\u0026rsquo;t directly provide a method to hide TabBar. If the root view is a tabView, the tabBar will not be actively hidden when jumping to the next interface, So we need wrap TabView directly with NavigationView.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import SwiftUI struct ContentView: View { var body: some View { // ⭐️⭐️⭐️: if you use NavigationStack in the Project, please note here. // iOS 16, iPadOS 16, macOS 13, tvOS 16, or watchOS 9 if #available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *) { NavigationStack { TabBarController() } } else { NavigationView { TabBarController() } } } } ","date":"2022-09-18T17:58:16+08:00","permalink":"https://blog.iostao.com/2022/09/swiftui-use-tabview/","title":"How to Use TabView of SwiftUI"},{"content":"I found that the AppIcon of Xcode14 is more convenient. So I want to use SwiftUI to test it in the Xcode14.\nInterface: SwiftUI Language: Swift Xcode: 14 We can found that when we click the button, the icon changes.\nIn the picture we can see that there is only 1024*1024px in AppIcon of Xcode14. Wow, that\u0026rsquo;s so easily in the Xcode14. So now we only need to prepare a few 1024*1024px pictures. Just like this:\nBut if we want to use multiple AppIcons, we need modify the setting in the Build Setting. In the Search Bar filled the text: include all. Then we can see Key: Include All App Icon Assets, make it as Yes.\nThen we begin to write the code. All my code is in the picture. And you can also copy the code directory in the bottom.\nWhy did I add an alert in the last Text? When an error window pop up, you can customize the message content.\nIf your system is not in English, you will find that the pop-up message is always in English. So we need to set internationalization. In the TARGETS, then go to Info, add a Key: Localized resources can be mixed, Value: YES.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @State var isPresented = false var body: some View { VStack { Text(\u0026#34;Default\u0026#34;) .padding() .onTapGesture { UIApplication.shared.setAlternateIconName(\u0026#34;hehua\u0026#34;) } Text(\u0026#34;egg\u0026#34;) .padding() .onTapGesture { UIApplication.shared.setAlternateIconName(\u0026#34;egg\u0026#34;) } Text(\u0026#34;devil\u0026#34;) .padding() .onTapGesture { UIApplication.shared.setAlternateIconName(\u0026#34;devil\u0026#34;) } Text(\u0026#34;arrow\u0026#34;) .padding() .onTapGesture { UIApplication.shared.setAlternateIconName(\u0026#34;arrow\u0026#34;) } Text(\u0026#34;Error iCon\u0026#34;) .padding() .onTapGesture { UIApplication.shared.setAlternateIconName(\u0026#34;errName\u0026#34;) { error in isPresented = true } } .alert(isPresented: $isPresented) { let alert = Alert(title: Text(\u0026#34;Error\u0026#34;), message: Text(\u0026#34;Because without this Resource, please check\u0026#34;), dismissButton: .default(Text(\u0026#34;OK\u0026#34;))) return alert } } .padding() } ","date":"2022-09-10T23:03:17+08:00","permalink":"https://blog.iostao.com/2022/09/swiftui-appicon-changes/","title":"Dynamically Change the AppIcon"},{"content":"介绍 vue3 vue-cli@4.5 ts antd 一、安装 1.1 vue-cli@4 我这里使用的是vue-cli@4.5版本。 创建项目 main.js中会有部分不一样 1、首先卸载旧版本 （如果事先安装了 vue-cli 1.x 或者 vue-cli 2.x，要先卸载掉）\n$ npm uninstall vue-cli -g 2、安装Vue-cli\n$ npm install -g @vue/cli # 查看版本 $ vue --version @vue/cli 4.5.15 1.2 项目中的命令 这块为了方便以后查找，所以放到了上面。\n1.2.1 安装 antd 可以去 antd 官网查看如何安装 antd，文档中，右上角有版本选择。我这里选择的3.0， 如果你选择的是1.7版本，可能会没有后面的 @next。\n$ npm install ant-design-vue@next --save 1.2.2 引入 ts $ npm install --save-dev typescript $ npm install --save-dev @vue/cli-plugin-typescript 1.2.3 安装axios $ npm install --save axios $ npm install --save es6-promise 官方文档：\naxios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. 虽然 Axios 的文档说了支持 IE8，但文档最下面又说，前提是你的环境（浏览器）支持 promise，如果你不用关心浏览器兼容，那就不用安装 es6-promise。\n二、创建配置 2.1 执行创建命令 # vue会自动创建一个 项目名的文件夹，然后生成文件到这个文件夹中 $ vue create 项目名 2.1 pick a preset 选择 Manually select features 手动配置\n2.2 check the features 按照图中选项配置，点击空格选择选项。 Unit Testing 测试单元可以不选择\n2.3 选择vue版本 注意:如果老版本 没有更新 不会出来 vue 2 和 3 这个选项的。这个时候可以回到第一步，卸载重新安装vue。（这里选择3.x）\n2.4 细节配置 后面的步骤选项如果有经验的话可以直接按照上图配置。后面可以看到我填写的每一个选项。\n如果不明白可以跟着下面一步一步来。\n2.5 Use class-style component syntax? Yes 是否使用Class风格装饰器？\n选择Yes，即原本是：home = new Vue()创建vue实例，使用装饰器后：class home extends Vue{}\n2.6 Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes 使用Babel与TypeScript一起用于自动检测的填充?\n2.7 Use history mode for router? (Requires proper server setup for index fallback in production) Yes 路由使用历史模式?\n选择Yes，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。\n2.8 Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS (with dart-sass) 使用什么css预编译器？\nSass 和 Less 都使用的是标准的 CSS 语法，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。\nStylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名\nnode-sass是自动编译实时的 dart-sass需要保存后才会生效 2.9 Pick a linter / formatter config: 选择Eslint代码验证规则（我们选择ESLint + Standard config 标准配置） 2.10 Pick additional lint features: 选择什么时候进行代码规则检测（我们选择保存时进行检查） ❯◉ Lint on save // 保存时检测\n2.11 Pick a unit testing solution: Unit Testing 单元测试（我们选择Jest ） 2.12 Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files (您希望Babel, ESLint 配置的存放位置，我们选择在专用的配置文件中) ❯◉ In dedicated config files //在专用的配置文件中\n◯In package.json //在package.json\nSave this as a preset for future projects?(y/N) （是否保存配置 ） 可以选择Y ，如果选择保存，保存后下次构建项目的时候就可以直用这次的配置构建项目\n2.13 创建完成 2.14 运行项目 $ cd 项目目录 $ npm run serve 三、 把Axios 配置成 Vue插件 把 Axios 封装成 Vue 插件，可以直接在 Vue 组件里使用 this.xxx 的方式来调用。Axios本身并没有封装，所以这里我们自己来把它封装成 Vue 组件。\n第一次封装 这里是将 Axios 封装成组件，后面会上全部代码，包含拦截器功能，验证token失效，跳转页面。\nAxiosPlugin.js require('es6-promise').polyfill() //引入一次就行 import axios from 'axios' // 创建 axios 实例 // 这里 export 的原因是方便组件外使用 axios export const Axios = axios.create({ //baseURL: process.env.BASE_API, // node环境的不同，对应不同的baseURL // baseURL: 'http://localhost:8181',\twithCredentials: true, //允许携带cookie timeout: 1000 * 30, }) 如果使用跨域功能，这里不需要写 baseURL，我这里使用了跨域，所以这里注释掉了。\n比如我跨域的时候使用的是 /proxy。 那么我url 只需要写 /proxy/login这种方式即可。\n运行时，会自动替换 /proxy 为设置的接口域名。\nproxy: {/*处理跨域，本地代理转发*/ '/proxy': { target: 'http://localhost:8080', // 接口域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, //是否跨域 pathRewrite: { '^/proxy': '' } }, main.js 在 main.js中引入并 use，from 这里有个 . ，本地，不加好像会去仓库查找。\nimport Vue from 'vue' import AxiosPlugin from './plugins/AxiosPlugin' Vue.use(AxiosPlugin) 使用:\n//参数 let params = { 'account' : 'admin', 'password' : 'admin' } //网络请求 that.$http.post('/proxy/login', params).then(res =\u0026gt; { console.log(res) }).catch(error =\u0026gt; { }) 当然也可以通过 import 引用。不过封装成了组件，直接使用上面的方式就可以了\n// POST import { Axios } from 'xxx/xxx/AxiosPlugin' Axios.post(url, params) 完整封装 关于里面的 url 配置，请看上面的第一次封装介绍。\nAxiosPlugin.js require('es6-promise').polyfill() //引入一次就行 import axios from 'axios' // 创建 axios 实例 // 这里 export 的原因是方便组件外使用 axios export const Axios = axios.create({ // baseURL: 'http://localhost:8181', withCredentials: true, //允许携带cookie timeout: 1000 * 30,\t//超时时间， 毫秒级， 1000 * 多少秒就可以了 }) // 将 Axios 实例添加到 Vue 的原型对象上 export default { install(Vue) { Object.defineProperty(Vue.prototype, '$http', { value: Axios}) } } //POST 传参序列化，根据需求来。不一定用的到序列化 --\u0026gt; 在发送前做的操作 Axios.interceptors.request.use(config =\u0026gt; { console.log('发送请求前的操作') // 设置以 form 表单的形式提交参数，如果以 JSON 的形式提交表单，可忽略 //我这里使用的json数据，所以注释掉了 // if(config.method === 'post'){ // JSON 转换为 FormData // const formData = new FormData() // Object.keys(config.data).forEach(key =\u0026gt; formData.append(key, config.data[key])) // config.data = formData // } //这里用来做验证的。 //我这里是 uid 和 token放在了header里面请求验证。 if (localStorage.getItem('token')) { config.headers['uid'] = localStorage.getItem('uid') config.headers['token'] = localStorage.getItem('token') } return config }, error =\u0026gt; { alert(\u0026quot;错误的传参\u0026quot;, 'fail') return Promise.reject(error) }) // 返回状态判断 （添加响应拦截器） Axios.interceptors.response.use(res =\u0026gt; { //对响应数据做些判断，如果返回的状态码代表token失效 //跳转到 `/` 登录页。 其他的异常状态码，也可以在这里添加提示 if (res.data.code == 4001) { location.href = '/' }else if (res.data.code != 0) { alert(res.error_msg) return Promise.reject(res) } //这里直接返回的是 res.data，就是服务端返回来的数据内容。 //可以根据自己的需求，决定返回的是 res.data，还是 res return res.data }, error =\u0026gt; { console.log('封装的异常: ', error) if(error.response.status === 401) { // 401 说明 token 验证失败 // 可以直接跳转到登录页面，重新登录获取 token location.href = '/login' } else if (error.response.status === 500) { // 服务器错误 // do something return Promise.reject(error.response.data) } // 返回 response 里的错误信息 return Promise.reject(error.response.data) }) 调用 XX.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { name: \u0026#39;defaultName\u0026#39;, data() { return { } }, methods: { handleRequest() { //参数 let params = { \u0026#39;account\u0026#39; : \u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39; : \u0026#39;admin\u0026#39; } //网络请求 that.$http.post(\u0026#39;/proxy/login\u0026#39;, params).then(res =\u0026gt; { //我上面封装的返回的是 res.data //所以这里获取到的res其实是 res.data。使用的时候，直接获取数据就可以了 //比如 获取 code， res.code 即可 console.log(res) }).catch(error =\u0026gt; { }) }, } ","date":"2021-11-28T16:42:36Z","permalink":"https://blog.iostao.com/2021/11/vue-cli4-antd-ts-01/","title":"vue3/vue-cli@4.5 + ts + andt 创建项目"},{"content":"转载\n使用brew 安装node 首先先对 brew 进行检查 brew update brew doctor 创建目录，并修改权限 因为权限问题，我这里是手动创建的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 sudo mkdir /usr/local/Cellar sudo chown -R $(whoami) /usr/local/Cellar sudo mkdir /usr/local/opt sudo chown -R $(whoami) /usr/local/opt/ sudo mkdir /usr/local/opt/icu4c sudo chown -R $(whoami) /usr/local/opt/ sudo mkdir /usr/local/include sudo chown -R $(whoami) /usr/local/include/ sudo mkdir /usr/local/share sudo chown -R $(whoami) /usr/local/share 然后进行安装 brew link node brew uninstall node brew install node 我这里失败了啊 1 2 3 4 5 node -v dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.67.dylib Referenced from: /usr/local/bin/node Reason: image not found zsh: abort node -v 1 2 3 4 5 6 7 8 9 brew uninstall --force node brew uninstall icu4c \u0026amp;\u0026amp; brew install icu4c brew unlink icu4c \u0026amp;\u0026amp; brew link icu4c --force # 这里可能会提示设置 ~/.zshrc。 看底部 icu4c ~/.zshrc 这个模块 echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc # 如果执行了上面那条命令，需要更新资源文件 source ~/.zshrc brew install node icu4c ~/.zshrc If you need to have icu4c first in your PATH run:\n1 2 echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/sbin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc For compilers to find icu4c you may need to set:\n1 2 export LDFLAGS=\u0026#34;-L/usr/local/opt/icu4c/lib\u0026#34; export CPPFLAGS=\u0026#34;-I/usr/local/opt/icu4c/include\u0026#34; 常用命令 npm install \u0026lt;module\u0026gt; //安装 npm uninstall \u0026lt;module\u0026gt; //卸载 npm search \u0026lt;module\u0026gt; //搜索 npm update \u0026lt;module\u0026gt; //更新 npm npm 是node.js自带的功能。\n","date":"2021-01-24T14:43:16Z","permalink":"https://blog.iostao.com/2021/01/mac-brew-install-node_npm/","title":"brew 安装 node 及 npm用法"},{"content":"一、安装 Commitizen 工具 需要提前安装node。\n1. 安装 commitizen node 模块 npm install -g commitizen 2. 初始化 commitizen 的适配器 cz-customizable npm install -g cz-customizable 3. 安装生成log日志的模块 npm install -g conventional-changelog-cli 报错可以重新执行命令尝试一下\n1 2 3 4 5 6 7 8 9 10 npm ERR! code ECONNRESET npm ERR! network aborted npm ERR! network This is a problem related to network connectivity. npm ERR! network In most cases you are behind a proxy or have bad network settings. npm ERR! network npm ERR! network If you are behind a proxy, please make sure that the npm ERR! network \u0026#39;proxy\u0026#39; config is set properly. See: \u0026#39;npm help config\u0026#39; npm ERR! A complete log of this run can be found in: npm ERR! /Users/tao/.npm/_logs/2021-01-23T10_12_59_442Z-debug.log 二、使用 1. 生成 package.json # cd 到项目目录，执行命令 $ npm init #然后根据提示填写相关的项目信息 #完成后会生成package.json 2. 在 package.json中添加脚本 在 scripts中添加：\n$ \u0026quot;changelog\u0026quot;: \u0026quot;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026quot; 1 2 3 4 5 #不会覆盖以前的 Change log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动 $ conventional-changelog -p angular -i CHANGELOG.md -s # 生成所有发布的 Change log，会覆盖以前的 Change log $ conventional-changelog -p angular -i CHANGELOG.md -w -r -s 0 示例如下：\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; }, 这个脚本可以在通过在终端输入 npm run changelog 生成 CHANGELOG.md 日志文档。\n2. 加载node_modules依赖组件 (cz) $ commitizen init cz-conventional-changelog —save —save-exact 执行完以后，项目中就可以一律使用 git cz 代替 git commit来提交代码。\n同时会显示type选项来自动生成符合格式的 commit message。\n三、代码提交 git add . git cz\t//使用 git cz 代替之前的 git commit 代码提交流程 1.Select the type of change that you\u0026rsquo;re committing 选择改动类型\n2.What is the scope of this change (e.g. component or file name)? 填写改动范围\n3.Write a short, imperative tense description of the change: 写一个精简的描述\n4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述\n5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n\n6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n\n类型说明\nfeat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi- colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing tests or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: gulp, brocc oli, npm) ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, Browser Stack, SauceLabs) chore: Other changes that don\u0026rsquo;t modify src or test files revert: Reverts a previous commit 四、Jira 设置gitlab Network配置\n进入要配置的项目，点击设置。（这里和上面那个设置不同，这里是设置项目里的配置）\n往下滑动一点儿，有个保存。保存。保存。不要忘记保存。\n配置 Jira\n","date":"2021-01-23T18:49:03Z","permalink":"https://blog.iostao.com/2021/01/git-commitizen/","title":"Git Commitizen 规范化commit工具"},{"content":"转载来源\n1、删除旧的安装 1 2 3 sudo rm -rf /usr/local/Homebrew sudo rm -f /usr/local/bin/brew sudo rm -rf /usr/local/var/homebrew 2、创建新的安装目录 sudo mkdir /usr/local/Homebrew\n3、下载brew sudo git clone https://mirrors.ustc.edu.cn/brew.git /usr/local/Homebrew 地址可更换为清华源https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git。\n如提示没有git，可通过xcode-select \u0026ndash;install安装。\n4、创建执行文件链接 sudo mkdir /usr/local/bin sudo ln -s /usr/local/Homebrew/bin/brew /usr/local/bin/brew 5、创建brew-core目录 sudo mkdir -p /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core 6、下载brew-core sudo git clone https://mirrors.ustc.edu.cn/homebrew-core.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core 地址可更换为清华源https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git。\n7、权限配置 1 2 3 sudo mkdir -p /usr/local/var/homebrew sudo chown -R $(whoami) /usr/local/var/homebrew sudo chown -R $(whoami) /usr/local/Homebrew 8、执行更新 brew update 提示Already up-to-date即为成功。如有问题可通过brew doctor自检命令检查一下。\n9、设置环境变量\necho 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' \u0026gt;\u0026gt; ~/.zshrc 地址可更换为https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-bottles。 ","date":"2021-01-23T17:22:24Z","permalink":"https://blog.iostao.com/2021/01/mac-brew-install-national/","title":"使用国内源安装 Homebrew"},{"content":"这篇文章是很早以前转载的，这两天做了重新接触的时候，发现了自己碰到的一些问题，然后做了一下修改。\n本文前三部分都是介绍。从第四部分开始是如何安装和使用。\n一、介绍 Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n$ git commit -m \u0026quot;hello world\u0026quot; 上面代码的-m参数，就是用来指定 commit mesage 的。\n如果一行不够，可以只执行git commit，就会跳出文本编译器，让你写多行。\n$ git commit 基本上，你写什么都行，可参考如下文章：\nhttp://www.commitlogsfromlastnight.com\nhttp://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/\nhttp://whatthecommit.com\n但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。\n目前，社区有多种 Commit message 的写法规范(http://whatthecommit.com)。本文介绍Angular 规范（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。\n二、Commit message 的作用 格式化的Commit message，有几个好处。\n2.1 提供更多的历史信息，方便快速浏览。 比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。\n$ git log \u0026lt;last tag\u0026gt; HEAD --pretty=format:%s 2.2 可以过滤某些commit（比如文档改动），便于快速查找信息。 比如，下面的命令仅仅显示本次发布新增加的功能。\n$ git log \u0026lt;last release\u0026gt; HEAD --grep feature 2.3 可以直接从commit生成Change log。 Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。\n三、Commit message 的格式 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; // 空一行 \u0026lt;body\u0026gt; // 空一行 \u0026lt;footer\u0026gt; 其中，Header 是必需的，Body 和 Footer 可以省略。\n不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\n3.1 Header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 （1）type type用于说明 commit 的类别，只允许使用下面7个标识。\nfeat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。\n（2）scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n（3）subject subject是 commit 目的的简短描述，不超过50个字符。\n以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） 3.2 Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\nMore detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。 （1）使用第一人称现在时，比如使用change而不是changed或changes。 （2）应该说明代码变动的动机，以及与以前行为的对比。\n3.3 Footer Footer 部分只用于两种情况。\n3.1.1 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\nBREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 3.1.2 关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\nCloses #234 也可以一次关闭多个 issue 。\nCloses #123, #245, #992 3.4 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\nrevert: feat(pencil): add 'graphiteWidth' option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit ，其中的hash是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。\n四、Commitizen 安装 4.1 安装 commitizen node 模块 Commitizen是一个撰写合格 Commit message 的工具。 安装命令如下。\n$ npm install -g commitizen 4.2 初始化 commitizen 的适配器 cz-customizable $ npm install -g cz-customizable 4.3 安装生成log日志的模块 $ npm install -g conventional-changelog-cli 4.4 初始化 cd 到项目目录，执行命令以下命令，然后根据提示填写相关的项目信息\n完成后会在项目目录下生成package.json\n$ npm init 4.5 commitizen init 在项目目录里，运行下面的命令，使其支持Angular的 Commit Message 格式。\n$ commitizen init cz-conventional-changelog-cli —save —save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。\nLaoTao@taobotongdeMacBook-Pro:~/Documents/CIM/cim-ios$ git add . LaoTao@taobotongdeMacBook-Pro:~/Documents/CIM/cim-ios$ git cz cz-cli@2.5.0, cz-conventional-changelog@1.1.5 Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters. ? Select the type of change that you're committing: (Use arrow keys) ❯ feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug or adds a feature perf: A code change that improves performance (Move up and down to reveal more choices) 五、validate-commit-msg validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。\n它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。\n接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行。\n\u0026quot;config\u0026quot;: { \u0026quot;ghooks\u0026quot;: { \u0026quot;commit-msg\u0026quot;: \u0026quot;./validate-commit-msg.js\u0026quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。\n$ git add -A $ git commit -m \u0026quot;edit markdown\u0026quot; INVALID COMMIT MSG: does not match \u0026quot;\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt;\u0026quot; ! was: edit markdown 六、生成 Change log 6.1 生成 change log日志 如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。\n例1：https://github.com/karma-runner/karma/blob/master/CHANGELOG.md\n例2：https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md\n生成的文档包括以下三个部分。\nNew features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\nconventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。\n（这个工具我们上面的步骤有安装，这里只是再提示一下，已经安装的，执行第三步即可）\n$ npm install -g conventional-changelog-cli $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -s 0 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。\n如果你想生成所有发布的 Change log，要改为运行下面的命令。\n$ conventional-changelog -p angular -i CHANGELOG.md -w -r -s 0 有的文章里面，命令没有 -s ，每次执行只是在终端打印所有的日志，并没有在本地生成文件。这里需要注意一下。\n6.2 配置changelog生成命令 为了方便使用，可以将生成命令其写入package.json的scripts字段。\n1 $ \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; 示例如下：\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; }, 七、关于日志生成的问题 1 2 3 4 5 6 我自己碰到的问题，增量生成日志文件，发现每一次都会把所有的日志打印出来了。 研究了好久才发现，每一个版本需要设置一个tag才可以。 比如我master分支切出来一个 1.0.0 的分支，修改完合并到 master分支上。 这个时候我需要 git tag v1.0.0 (这个tag名字不能和 分支 1.0.0 相同，不然生成日志的时候会提示错误， 或者是tag名字相同，然后把1.0.0分支删除）。 等我2.0.0 合并的时候，生成log日志，就可以看到日志 文件中，会显示出不同版本的不同提交信息日志了。 ","date":"2020-12-31T11:46:29Z","permalink":"https://blog.iostao.com/2020/12/gitcommit-message-and-change-log/","title":"Git提交的正确姿势：Commit message 和 Change log 编写指南"},{"content":"一、校验数字的表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\u0026#34;*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1 2 3 4 5 6 7 8 9 10 11 12 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026amp;\u0026#39;,;=?$\\\u0026#34;等字符：[^%\u0026amp;\u0026#39;,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4 手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d{8}$ 4.1 var re = /^(1[3-9][0-9]{9})$/;//如： if (re.test(vmData.PHONE) === false) { alert(\u0026#34;手机号格式不正确\u0026#34;); return; } 5 电话号码(\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXXX-XXXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXXX\u0026#34;、\u0026#34;XXXXXXX\u0026#34;和\u0026#34;XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7 18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$ 8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 11 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 12 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 13 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式： 15 1.有四种钱的表示形式我们可以接受:\u0026#34;10000.00\u0026#34; 和 \u0026#34;10,000.00\u0026#34;, 和没有 \u0026#34;分\u0026#34; 的 \u0026#34;10000\u0026#34; 和 \u0026#34;10,000\u0026#34;：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\u0026#34;0\u0026#34;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以\u0026#34;10.\u0026#34;是不通过的,但是 \u0026#34;10\u0026#34; 和 \u0026#34;10.2\u0026#34; 是通过的：^[0-9]+(.[0-9]{2})?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 23 备注：这就是最终结果了,别忘了\u0026#34;+\u0026#34;可以用\u0026#34;*\u0026#34;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 25 中文字符的正则表达式：[\\u4e00-\\u9fa5] 26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 28 HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 31 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) ","date":"2020-06-21T08:06:44Z","permalink":"https://blog.iostao.com/2020/06/ios-js-regular/","title":"常用正则表达式大全--如：数字，字符等"},{"content":"一、安装依赖\nnpm install vue-quill-editor npm install quill\t(依赖项) npm install quill-image-drop-module (图片拖拽） 二、使用\n1、在 main.js 中引入 1 2 3 4 5 6 7 import Vue from \u0026#39;vue\u0026#39; import VueQuillEditor from \u0026#39;vue-quill-editor\u0026#39; import \u0026#39;quill/dist/quill.core.css\u0026#39; import \u0026#39;quill/dist/quill.snow.css\u0026#39; import \u0026#39;quill/dist/quill.bubble.css\u0026#39; Vue.use(VueQuillEditor) 2、封装组件 在 /src/components目录下创建 quill-editor.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;edit_container\u0026#34;\u0026gt; \u0026lt;quill-editor v-model=\u0026#34;content\u0026#34; ref=\u0026#34;myQuillEditor\u0026#34; :options=\u0026#34;editorOption\u0026#34; @blur=\u0026#34;onEditorBlur($event)\u0026#34; @focus=\u0026#34;onEditorFocus($event)\u0026#34; @change=\u0026#34;onEditorChange($event)\u0026#34;\u0026gt; \u0026lt;/quill-editor\u0026gt; \u0026lt;button v-on:click=\u0026#34;saveHtml\u0026#34;\u0026gt;保存\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data(){ return { content: `\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;`, editorOption: { // theme: \u0026#39;snow\u0026#39;, //主题 modules:{\t//工具栏设置 toolbar:[ [\u0026#39;bold\u0026#39;, \u0026#39;italic\u0026#39;, \u0026#39;underline\u0026#39;, \u0026#39;strike\u0026#39;], //加粗，斜体，下划线，删除线 [\u0026#39;blockquote\u0026#39;, \u0026#39;code-block\u0026#39;], //引用，代码块 // 标题，键值对的形式；1、2表示字体大小 [{ \u0026#39;header\u0026#39;: 1 }, { \u0026#39;header\u0026#39;: 2 }], [{ \u0026#39;list\u0026#39;: \u0026#39;ordered\u0026#39;}, { \u0026#39;list\u0026#39;: \u0026#39;bullet\u0026#39; }], //列表 [{ \u0026#39;script\u0026#39;: \u0026#39;sub\u0026#39;}, { \u0026#39;script\u0026#39;: \u0026#39;super\u0026#39; }], // 上下标 [{ \u0026#39;indent\u0026#39;: \u0026#39;-1\u0026#39;}, { \u0026#39;indent\u0026#39;: \u0026#39;+1\u0026#39; }], // 缩进 [{ \u0026#39;direction\u0026#39;: \u0026#39;rtl\u0026#39; }], // 文本方向 [{ \u0026#39;size\u0026#39;: [\u0026#39;small\u0026#39;, false, \u0026#39;large\u0026#39;, \u0026#39;huge\u0026#39;] }], // 字体大小 [{ \u0026#39;header\u0026#39;: [1, 2, 3, 4, 5, 6, false] }], //几级标题 [{ \u0026#39;color\u0026#39;: [] }, { \u0026#39;background\u0026#39;: [] }], // 字体颜色，字体背景颜色 [{ \u0026#39;font\u0026#39;: [] }], //字体 [{ \u0026#39;align\u0026#39;: [] }], //对齐方式 [\u0026#39;clean\u0026#39;], //清除字体样式 [\u0026#39;image\u0026#39;] // [\u0026#39;image\u0026#39;,\u0026#39;video\u0026#39;] //上传图片、上传视频 ] }, }, } },computed: { editor() { return this.$refs.myQuillEditor.quill; }, }, methods: { onEditorReady(editor) { // 准备编辑器 }, onEditorBlur(){}, // 失去焦点事件 onEditorFocus(val, editor){ console.log(val) // 富文本获得焦点时的内容 // editor.enable(false) // 在获取焦点的时候禁用 }, // 获得焦点事件 onEditorChange(){}, // 内容改变事件 saveHtml:function(event){ alert(this.content) } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /*#app {*/ /*font-family: \u0026#39;Avenir\u0026#39;, Helvetica, Arial, sans-serif;*/ /*-webkit-font-smoothing: antialiased;*/ /*-moz-osx-font-smoothing: grayscale;*/ /*text-align: center;*/ /*color: #2c3e50;*/ /*margin-top: 60px;*/ /*}*/ \u0026lt;/style\u0026gt; 3、页面中使用 在需要的页面中，引用封装的富文本组件，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;quill-editor-template\u0026gt;\u0026lt;/quill-editor-template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //*****这里的路径记得修改成自己封装的组件路径***** import quillEditorTemplate from \u0026#39;../../components/quill-editor\u0026#39; export default { name: \u0026#39;glygl\u0026#39;, components: { quillEditorTemplate, }, methods: {}, } \u0026lt;/script\u0026gt; 4、显示 页面刷新一下，应该就可以如下图正常显示了，如果有问题，检查一下代码 ","date":"2020-06-03T20:04:45Z","permalink":"https://blog.iostao.com/2020/06/vue-quill-editor/","title":"Vue基于vue-quill-editor富文本编辑器的使用"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 .el-dialog{ display: flex; flex-direction: column; margin:0 !important; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); } .el-dialog .el-dialog__body{ flex:1; overflow: auto; } ","date":"2020-05-31T19:47:51Z","permalink":"https://blog.iostao.com/2020/05/vue-dialog-center/","title":"使elementUI的dialog上下左右居中"},{"content":"从iOS 13系统开始，开启了App的深色模式的大门。因为AppStore审核指南提出：从2020年4月30日开始，所有提交至App Store的iPhone App都必须使用 iOS 13 SDK或更高版本来构建。以后的app都需要支持暗黑模式了。\n一、暗黑模式 1、 UIUserInterfaceStyle（页面模式的枚举） 1 2 3 4 5 6 @available(iOS 12.0, *) public enum UIUserInterfaceStyle : Int { case unspecified = 0 case light = 1 case dark = 2 } 2、暗黑模式监听： 1 2 3 4 5 6 7 ///监听模式的变化 override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) { super.traitCollectionDidChange(previousTraitCollection) if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) { //模式发生变化会回调这里 } } 3、获取当前模式 1 2 3 4 5 6 7 8 9 10 if self.traitCollection.userInterfaceStyle == .dark { // Dark print(\u0026#34;是dark模式、。。。\u0026#34;) } else if self.traitCollection.userInterfaceStyle == .light { // Light print(\u0026#34;是light模式、。。。\u0026#34;) } else { //unspecified print(\u0026#34;是unspecified模式、。。。\u0026#34;) } 二、创建动态颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 extension UIColor { /// 动态颜色 class func color(lightColor: UIColor, darkColor: UIColor) -\u0026gt; UIColor { if #available(iOS 13.0, *) { // UITraitCollection return UIColor { (traitCollection) -\u0026gt; UIColor in //我这里只有两种颜色，所以if，else就可以。如果需要，可以看下面的注释方法 if traitCollection.userInterfaceStyle == .dark { return darkColor } else { return lightColor } //switch traitCollection.userInterfaceStyle { //case .light: //\treturn lightColor //case .dark: //\treturn darkColor //case .unspecified: //\treturn lightColor //如果有需求，这里可以设置 //@unknown default: //\treturn lightColor //} } } return lightColor } } 三、Assets.xcassets Color set/ Image set 1、 设置动态图片。选择右侧第四个标签栏。在下面选择 Appearance，弹出的弹框里，可以根据需求选择 Any, Dark 或 Any, Light, Dary 模式。\n2、设置动态颜色，点击下方的加号，然后选择 Color Set。然后按照设置动态图片的方式，设置动态颜色即可 3、代码的使用 这里只记录颜色，图片的方式还是不变的。\n1 2 3 4 5 6 7 8 //Color Set是ios \u0026gt;= 11才能使用的，如果app仍然支持 iOS 11以下的，需要判断。 //如果支持版本 \u0026gt;= 11，不需要判断 if #available(iOS 11.0, *) {\tself.view.backgroundColor = UIColor(named: \u0026#34;lgl_test\u0026#34;) } else { ///设置低于iOS11系统下展示的颜色 self.view.backgroundColor = UIColor.red } ","date":"2020-05-28T20:26:58Z","permalink":"https://blog.iostao.com/2020/05/ios-dynamic-color/","title":"iOS 深浅模式 颜色 和 图片"},{"content":"安装插件 npm install axios npm install es6-promise 官方文档：\naxios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. 虽然 Axios 的文档说了支持 IE8，但文档最下面又说，前提是你的环境（浏览器）支持 promise，如果你不用关心浏览器兼容，那就不用安装 es6-promise。\n把Axios 配置成 Vue插件 把 Axios 封装成 Vue 插件，可以直接在 Vue 组件里使用 this.xxx 的方式来调用。Axios本身并没有封装，所以这里我们自己来把它封装成 Vue 组件。\n第一次封装 这里是将 Axios 封装成组件，后面会上全部代码，包含拦截器功能，验证token失效，跳转页面。\nAxiosPlugin.js require('es6-promise').polyfill() //引入一次就行 import axios from 'axios' // 创建 axios 实例 // 这里 export 的原因是方便组件外使用 axios export const Axios = axios.create({ //baseURL: process.env.BASE_API, // node环境的不同，对应不同的baseURL // baseURL: 'http://localhost:8181',\twithCredentials: true, //允许携带cookie timeout: 1000 * 30, }) 如果使用跨域功能，这里不需要写 baseURL，我这里使用了跨域，所以这里注释掉了。\n比如我跨域的时候使用的是 /proxy。 那么我url 只需要写 /proxy/login这种方式即可。\n运行时，会自动替换 /proxy 为设置的接口域名。\nproxy: {/*处理跨域，本地代理转发*/ '/proxy': { target: 'http://localhost:8080', // 接口域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, //是否跨域 pathRewrite: { '^/proxy': '' } }, main.js 在 main.js中引入并 use，from 这里有个 . ，本地，不加好像会去仓库查找。\nimport Vue from 'vue' import AxiosPlugin from './plugins/AxiosPlugin' Vue.use(AxiosPlugin) 使用:\n//参数 let params = { 'account' : 'admin', 'password' : 'admin' } //网络请求 that.$http.post('/proxy/login', params).then(res =\u0026gt; { console.log(res) }).catch(error =\u0026gt; { }) 当然也可以通过 import 引用。不过封装成了组件，直接使用上面的方式就可以了\n// POST import { Axios } from 'xxx/xxx/AxiosPlugin' Axios.post(url, params) 完整封装 关于里面的 url 配置，请看上面的第一次封装介绍。\nAxiosPlugin.js require('es6-promise').polyfill() //引入一次就行 import axios from 'axios' // 创建 axios 实例 // 这里 export 的原因是方便组件外使用 axios export const Axios = axios.create({ // baseURL: 'http://localhost:8181', withCredentials: true, //允许携带cookie timeout: 1000 * 30,\t//超时时间， 毫秒级， 1000 * 多少秒就可以了 }) // 将 Axios 实例添加到 Vue 的原型对象上 export default { install(Vue) { Object.defineProperty(Vue.prototype, '$http', { value: Axios}) } } //POST 传参序列化，根据需求来。不一定用的到序列化 --\u0026gt; 在发送前做的操作 Axios.interceptors.request.use(config =\u0026gt; { console.log('发送请求前的操作') // 设置以 form 表单的形式提交参数，如果以 JSON 的形式提交表单，可忽略 //我这里使用的json数据，所以注释掉了 // if(config.method === 'post'){ // JSON 转换为 FormData // const formData = new FormData() // Object.keys(config.data).forEach(key =\u0026gt; formData.append(key, config.data[key])) // config.data = formData // } //这里用来做验证的。 //我这里是 uid 和 token放在了header里面请求验证。 if (localStorage.getItem('token')) { config.headers['uid'] = localStorage.getItem('uid') config.headers['token'] = localStorage.getItem('token') } return config }, error =\u0026gt; { alert(\u0026quot;错误的传参\u0026quot;, 'fail') return Promise.reject(error) }) // 返回状态判断 （添加响应拦截器） Axios.interceptors.response.use(res =\u0026gt; { //对响应数据做些判断，如果返回的状态码代表token失效 //跳转到 `/` 登录页。 其他的异常状态码，也可以在这里添加提示 if (res.data.code == 4001) { location.href = '/' }else if (res.data.code != 0) { alert(res.error_msg) return Promise.reject(res) } //这里直接返回的是 res.data，就是服务端返回来的数据内容。 //可以根据自己的需求，决定返回的是 res.data，还是 res return res.data }, error =\u0026gt; { console.log('封装的异常: ', error) if(error.response.status === 401) { // 401 说明 token 验证失败 // 可以直接跳转到登录页面，重新登录获取 token location.href = '/login' } else if (error.response.status === 500) { // 服务器错误 // do something return Promise.reject(error.response.data) } // 返回 response 里的错误信息 return Promise.reject(error.response.data) }) 调用 XX.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { name: \u0026#39;defaultName\u0026#39;, data() { return { } }, methods: { handleRequest() { //参数 let params = { \u0026#39;account\u0026#39; : \u0026#39;admin\u0026#39;, \u0026#39;password\u0026#39; : \u0026#39;admin\u0026#39; } //网络请求 that.$http.post(\u0026#39;/proxy/login\u0026#39;, params).then(res =\u0026gt; { //我上面封装的返回的是 res.data //所以这里获取到的res其实是 res.data。使用的时候，直接获取数据就可以了 //比如 获取 code， res.code 即可 console.log(res) }).catch(error =\u0026gt; { }) }, } ","date":"2020-05-22T16:42:36Z","permalink":"https://blog.iostao.com/2020/05/vue-cli4-axios/","title":"vue/cli4 axios网路请求封装 以及 登录token失效跳转页面"},{"content":"我们开发会遇到类似于获取菜单这种情况，架构大体类似如下：\n人事管理 员工资历 员工奖惩 统计管理 统计列表 系统管理 我的设置 权限管理 角色列表 我这里用的是双层结构，我们搜索的时候用的是递归查询，所以理论上可以无限级添加（不考虑数据库的感受的话）。\n数据表如下：\n-- Table structure for tbl_auth_menu\n1 2 3 4 5 6 7 8 9 10 DROP TABLE IF EXISTS `tbl_auth_menu`; CREATE TABLE `tbl_auth_menu` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `pid` int(11) NOT NULL COMMENT \u0026#39;父级菜单id\u0026#39;, `name` char(20) NOT NULL COMMENT \u0026#39;菜单名单\u0026#39;, `sort` tinyint(4) DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;排序值\u0026#39;, `route` varchar(60) DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;跳转链接\u0026#39;, PRIMARY KEY (`id`), KEY `pid` (`pid`) ) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COMMENT=\u0026#39;权限管理_菜单表\u0026#39;; -- Records of tbl_auth_menu\n1 2 3 4 5 6 7 8 9 10 11 BEGIN; INSERT INTO `tbl_auth_menu` VALUES (14, -1, \u0026#39;人事管理\u0026#39;, 1, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (15, -1, \u0026#39;统计管理\u0026#39;, 2, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (16, -1, \u0026#39;系统管理\u0026#39;, 3, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (17, 14, \u0026#39;员工资料\u0026#39;, 1, \u0026#39;/user/info\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (18, 14, \u0026#39;员工奖惩\u0026#39;, 2, \u0026#39;/user/award\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (19, 15, \u0026#39;统计列表\u0026#39;, 1, \u0026#39;/statis/list\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (20, 16, \u0026#39;我的设置\u0026#39;, 1, \u0026#39;/sys/setting\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (21, 16, \u0026#39;权限管理\u0026#39;, 2, \u0026#39;/sys/auth\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (22, 16, \u0026#39;角色列表\u0026#39;, 3, \u0026#39;/sys/role\u0026#39;); COMMIT; 我这里第一级目录的 父菜单 id (pid)使用的是 -1, 因为 id 默认是从 0开始的，使用0的话，这个菜单有可能不是第一级目录，而是 pid = 0 的二级目录了\n父菜单 id = 0 子菜单 pid = 0 (pid=0，它就是二级目录了） 代码 文件 menu.go (使用 beego orm) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Menu struct { Id int `json:\u0026#34;id\u0026#34;` Pid int `json:\u0026#34;pid\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Sort int `json:\u0026#34;sort\u0026#34;` Route string `json:\u0026#34;route\u0026#34;` //这里是子菜单，结构是 menu数组，因为是menu类型，所以数据库不做处理 //用 orm:\u0026#34;-\u0026#34;注解 Children []*Menu `json:\u0026#34;children\u0026#34; orm:\u0026#34;-\u0026#34;`\t} func (m *Menu) TableName() string { return \u0026#34;auth_menu\u0026#34; } 在数据库层，注册模型 1 2 3 4 5 6 7 8 9 //注册 数据库的时候 //我这里数据库都使用了 tbl_ 前缀。 //所以上面的数据库, return auth_menu 表名, 但是实际上使用的时候是 tbl_auth_menu 表, 这里一定要注意， //写代码的时候，提示错误，数据库表 不存在这个的时候，记得来这里看看 func init() { orm.RegisterModelWithPrefix(\u0026#34;tbl_\u0026#34;, new(models.Menu), ) } 递归查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** 递归获取树形菜单 */ //func (m *Menu) GetMenu(pid int) []*TreeList { func GetMenu(pid int) []*Menu { o := orm.NewOrm() var menuList []*Menu //根据 pid 查询数据库 _, _ = o.QueryTable(\u0026#34;tbl_auth_menu\u0026#34;).Filter(\u0026#34;pid\u0026#34;, pid).OrderBy(\u0026#34;sort\u0026#34;).All(\u0026amp;menuList) //查询到结果后，遍历该层菜单 //查询都有哪些菜单是使用自己的id作为pid的， //也就是查询该菜单的子菜单，查询到后赋值就可以了 for _, v := range menuList { child := GetMenu(v.Id) v.Children = child } return menuList } api方法 1 2 3 4 5 6 7 8 9 // 获取所有部门 func (c *DepartmentController) GetAll() { //我方法写在了 models 包里，根据具体情况，引入包， //或者是同级包下，不写包名 // -1 为 第一级部门 的 parentId， departments := models.DepartmentGetAll(-1) c.Data[\u0026#34;json\u0026#34;] = util.NewRespMsg(0, \u0026#34;获取部门成功\u0026#34;, departments) c.ServeJSON() } ","date":"2020-05-18T11:51:10Z","permalink":"https://blog.iostao.com/2020/05/go-mysql-recursion/","title":"Golang实战系列：mysql数据库查询 -- 实现无限级菜单（beego orm)"},{"content":"操作前，我们先打开 App.vue，因为这里项目默认写了一些东西，我们要去掉，和下面一样即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 这一行一定要添加，不然其他页面展示不出来 --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;app\u0026#39;, components: { } } \u0026lt;/script\u0026gt; Login.vue 我们前面已经配置好了 登录 的接口，现在就可以写一个网路请求了，在Login.vue文件中操作 （这里基本都是代码粘贴复制 + 部分手写，所以最好是手动敲，可以检查一下是否有错误）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;script\u0026gt; //这里引入的是 /src/api/api.js import * as Api from \u0026#39;../api/api\u0026#39;\texport default { name: \u0026#39;\u0026#39;, data() { return { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, } }, //钩子方法 ，可以百度一下：vue的钩子方法 created: function() { //控制台可以查看打印的数据，这里用来演示的，可以去掉 console.group(\u0026#39;created 创建完毕状态===============》\u0026#39;); console.log(\u0026#34;%c%s\u0026#34;, \u0026#34;color:red\u0026#34;,\u0026#34;el : \u0026#34; + this.$el); //undefined %c 格式化占位符 - css格式化样式 console.log(\u0026#34;%c%s\u0026#34;, \u0026#34;color:red\u0026#34;,\u0026#34;data : \u0026#34; + this.$data); //已被初始化 console.log(\u0026#34;%c%s\u0026#34;, \u0026#34;color:red\u0026#34;,\u0026#34;message: \u0026#34; + this.message); //已被初始化 }, beforeMount: function () { console.group(\u0026#39;beforeMount挂载前状态 === === === === ===》\u0026#39;) }, mounted:function() { console.log(\u0026#39;mounted钩子方法============\u0026#39;) }, methods: {\t//自定义一些方法，比如点击登录按钮，方法就写在这里 toLogin: function () { let params = new URLSearchParams(); params.append(\u0026#39;username\u0026#39;, username); params.append(\u0026#39;password\u0026#39;, password); //Api 这个是上面 import * as Api 这里定义的。 //Api.login 在 api.js 里面定义了 login = params =\u0026gt; {} 这个 //一般返回的都是json数据， res. + 属性名就可以获取值了 Api.login(params).then(res =\u0026gt; { if (res.code == \u0026#39;0\u0026#39;) { console.log(res.data) } }, error =\u0026gt; { }); }, } } \u0026lt;/script\u0026gt; ","date":"2020-05-14T19:54:40Z","permalink":"https://blog.iostao.com/2020/05/vue-cli4-start-04/","title":"vue-cli@4 入门（四）"},{"content":"路由 在项目下，创建 vue文件。我们需要类似 localhost:8080/login 这种方式访问。这个时候就需要配置路由信息了。\n如：\nproject router index.js (这里配置路由信息) src views\t(这里是页面) About.vue Home.vue Login.vue Manage.vue 在 router 的 index.js中配置路由信息：\n里面有个 children: ，一般后台管理首页，左边是一个菜单栏，如下：\n首页 账号管理 推送管理 员工管理 业务管理 这里的每一个router，都写在首页的 children里面就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const Login = () =\u0026gt; import(/* webpackChunkName: \u0026#34;login\u0026#34; */ \u0026#39;../views/Login.vue\u0026#39;) const Manage = () =\u0026gt; import(/* webpackChunkName: \u0026#34;login\u0026#34; */ \u0026#39;../views/Manage.vue\u0026#39;) const Home = () =\u0026gt; import(/* webpackChunkName: \u0026#34;login\u0026#34; */ \u0026#39;../views/Home.vue\u0026#39;) const About = () =\u0026gt; import(/* webpackChunkName: \u0026#34;login\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Login\u0026#39;, component: Login }, { path: \u0026#39;/\u0026#39;, name: \u0026#39;Manage\u0026#39;, component: Manage, children: [{ path: \u0026#39;/home\u0026#39; , name: \u0026#39;首页\u0026#39;, component: Home, },{ path: \u0026#39;/about\u0026#39; , name: \u0026#39;关于\u0026#39;, component: About, }] }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;About\u0026#39;, // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =\u0026gt; import(/* webpackChunkName: \u0026#34;about\u0026#34; */ \u0026#39;../views/About.vue\u0026#39;) } ] ","date":"2020-05-14T18:25:48Z","permalink":"https://blog.iostao.com/2020/05/vue-cli4-start-03/","title":"vue-cli@4 入门（三）"},{"content":"根据上一篇文章，我们的项目已经可以运行了。为了开发方便，我们这里使用 element-UI。\n在操作之前，先简单介绍一下 npm run serve\n打开项目，在项目根目录下，有一个 package.json 文件。\n可以发现 scripts 下面， 有 serve, build 等命令。这里和我们运行 的 npm run serve相对应\nnpm run build 就是打包了。这里也可以自己拓展功能\n1 2 3 4 5 6 \u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;test:unit\u0026#34;: \u0026#34;vue-cli-service test:unit\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34; }, 安装element-UI 终端命令， cd 到项目的根目录\n$ cd projectName $ vue add element $ 然后输入 y 回车 # 为了方便，选择第一个全局引用：Fully import ? How do you want to import Element? (Use arrow keys) ❯ Fully import Import on demand # 选择 y ? Do you wish to overwrite Element's SCSS variables? (y/N) # 选择 zh-CN ? Choose the locale you want to load (Use arrow keys) ❯ zh-CN zh-TW af-ZA ar bg ca cs-CZ 等待安装结束，然后在项目src目录下 main.js中添加\nimport ElementUI from \u0026quot;element-ui\u0026quot;; //element-ui的全部组建 Vue.use(ElementUI); //使用elementUI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import \u0026#39;./plugins/element.js\u0026#39; # 这里添加就可以了 import ElementUI from \u0026#34;element-ui\u0026#34;; //element-ui的全部组建 Vue.use(ElementUI); //使用elementUI Vue.config.productionTip = false new Vue({ router, store, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 安装less依赖 npm install less less-loader --save-dev 如果提示错误：\nERROR Failed to compile with 1 errors 执行 npm install sass-loader -D Mac下修改目录 （Windows不清楚，应该类似，进入安装的程序目录） /Applications/IntelliJ IDEA.app/Contents/plugins/JavaScriptLanguage/languageService/eslint/bin 下的 eslint-plugin.js 25行为：\nthis.cliEngine = require(this.basicPath + \u0026quot;lib/cli-engine\u0026quot;).CLIEngine; vue.config.js 配置域名，跨域，新建项目的时候是没有这个文件的，需要自己创建一个。在项目根目录下创建 vue.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 module.exports = { //编译打包存放的目录默认dist outputDir: \u0026#39;dist\u0026#39;, // 如果你不需要使用eslint，把lintOnSave设为false即可 lintOnSave: false, // 设为false打包时不生成.map文件 productionSourceMap: false, assetsDir: \u0026#39;static\u0026#39;, /*css: { loaderOptions: { css: {}, postcss: { plugins: [ // 补全css前缀(解决兼容性) require(\u0026#34;autoprefixer\u0026#34;)(), // 把px单位换算成rem单位 require(\u0026#34;postcss-pxtorem\u0026#34;)({ rootValue: 32, // 换算的基数(设计图750的根字体为32) selectorBlackList: [\u0026#34;.van\u0026#34;, \u0026#34;.my-van\u0026#34;],// 要忽略的选择器并保留为px。 propList: [\u0026#34;*\u0026#34;], //可以从px更改为rem的属性。 minPixelValue: 2 // 设置要替换的最小像素值。 }) ] } } },*/ devServer: { port: 8089, proxy: {/*处理跨域，本地代理转发*/ \u0026#39;/proxy\u0026#39;: { target: \u0026#39;http://localhost:8080\u0026#39;, // 接口域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, //是否跨域 pathRewrite: { \u0026#39;^/proxy\u0026#39;: \u0026#39;\u0026#39; } }, \u0026#39;/video\u0026#39;: { target: \u0026#39;http://192.168.2.132:8081\u0026#39;, // 接口域名 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true, //是否跨域 pathRewrite: { \u0026#39;^/video\u0026#39;: \u0026#39;\u0026#39; } }, }, // 禁用主机检查 disableHostCheck: true } } axios 网络请求 由于axios是需要打包到生产环境中的，所以我们使用\u0026ndash;save来进行安装\nnpm install axios --save 加载 es6-promise\nnpm install --save es6-promise 一、直接使用\t在 main.js 中 插入以下内容，就可以全局通过 this.$axios调用\nimport axios from 'axios' Vue.prototype.$axios = axios npm i -g node-sass npm audit fix --force 二、进行封装使用\n在 src/api/ 目录下创建一个 public.js（自己起个名就好）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 require(\u0026#39;es6-promise\u0026#39;).polyfill() import axios from \u0026#39;axios\u0026#39; axios.defaults.withCredentials = true //跨域 axios.defaults.timeout = 60000 axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/x-www=form-urlencoded\u0026#39; export default { //get请求 requestGet (url, params = {}) { return new Promise((resolve, reject) =\u0026gt; { axios.get(url, params).then(res =\u0026gt; { resolve(res.data) }).catch(error =\u0026gt; { reject(error) }) }) }, //get请求不带参数 requestQuickGet (url) { return new Promise((resolve, reject) =\u0026gt; { axios.get(url).then(res =\u0026gt; { resolve(res.data) }).catch(error =\u0026gt; { reject(error) }) }) }, //post请求 requestPost (url, params = {}) { return new Promise((resolve, reject) =\u0026gt; { axios.post(url, params).then(res =\u0026gt; { resolve(res.data) }).catch(error =\u0026gt; { reject(error) }) }) }, //post请求 requestPostForm (url, params = {}) { return new Promise((resolve, reject) =\u0026gt; { axios.post(url, params, { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, }).then(res =\u0026gt; { resolve(res.data)//注意res是axios封装的对象，res.data才是服务端返回的信息 }).catch(error =\u0026gt; { reject(error) }) }) }, //put请求 requestPut (url, params = {}) { return new Promise((resolve, reject) =\u0026gt; { axios.put(url, params).then(res =\u0026gt; { resolve(res.data) }).catch(error =\u0026gt; { reject(error) }) }) }, //delete请求 requestDelete (url, params = {}) { return new Promise((resolve, reject) =\u0026gt; { axios.delete(url, params).then(res =\u0026gt; { resolve(res.data) }).catch(error =\u0026gt; { reject(error) }) }) }, exportExcel: function(url,form) { return axios({ // 用axios发送post请求 method: \u0026#39;get\u0026#39;, url: url, // 请求地址 data: form, // 参数 responseType: \u0026#39;blob\u0026#39;, // 表明返回服务器返回的数据类型 headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }) } } 在 src/api/ 目录下创建一个 api.js（自己起个名就好）\n//将前面封装的 axios 引入到 api.js 中 import http from './../api/public' //用户登录 // /proxy 这个是 跨域的时候配置的vue.config.js的跨域字符 /proxy //比如 localhost:8080/api/user/login 跨域写成 =\u0026gt; /proxy/api/user/login export const login = params =\u0026gt;{ return http.requestPost('/proxy/api/user/login',params) } ","date":"2020-05-12T08:14:30Z","permalink":"https://blog.iostao.com/2020/05/vue-cli4-start-02/","title":"vue-cli@4 入门（二）"},{"content":"因为最近要做一个管理后台，这里做一下记录。从入门到项目上手。适合初学\n安装 vue-cli@4 1、首先卸载旧版本 （如果事先安装了 vue-cli 1.x 或者 vue-cli 2.x，要先卸载掉）\nnpm uninstall vue-cli -g 2、安装Vue-cli\nnpm install -g @vue/cli 3、查看版本\n$ vue --version #显示差不多如下 @vue/cli 4.4.4 项目初始 1、创建项目\n#创建一个项目， projectName 项目名 $ vue create projectName 然后会提示\n- ? Please pick a preset: ◯ myproject (这个是我自己的模板，后面会提到如何生成模板） ◯ default ◉ Manually select features 选择 Manually select features 回车\n然后会有提示，空格选择选项。回车确定，选项按照我标记的选择就可以了\n? Check the features needed for your project: (Press \\ to select, \\ to toggle all, \\ to invert selection) ❯◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◉ Vuex ◉ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing --- 回车后，提示如下，输入 Y 回车 这里选择 n 的话，url会有# ? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) 选择 css， 我这里选择的是 less。看个人吧 Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys)\n❯ Sass/SCSS (with dart-sass) Sass/SCSS (with node-sass) Less Stylus 这里默认回车 ❯ ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier Lint on save 这里是保存模板。保存就可以了。随便选择一个。保存之后，下次创建项目的时候，就可以使用这个模板了\n后面就等待项目加载了。可能有点儿慢。如果项目使用 git，在.gitignore中 添加一行，取消依赖的加载。\nnode_modules/ 运行项目 加载完成，终端会提示下面的命令\n$ cd projectName $ npm run serve npm run serve就是以后项目运行的时候，运行的命令了\n","date":"2020-05-11T16:36:59Z","permalink":"https://blog.iostao.com/2020/05/vue-cli4-start-01/","title":"vue-cli@4 入门（一）"},{"content":"转载自 超级大柱子（简书）\ngo极简教程 阅读目录\nGo 文件操作 os库：文件\\文件夹创建,读取,移动,复制 io库 : 文件内容的写入,修改,拼接 基本文件操作 文件内容的读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { // 读取文件内容 file, _ := os.OpenFile(\u0026#34;./demo_unicode.html\u0026#34;, 2, 0666) fileByte1, _ = ioutil.ReadAll(file); // 读取文件内容，更简易的方法 fileByte2, _ := ioutil.ReadFile(\u0026#34;./demo_unicode.html\u0026#34;) // byte转string fileString := string(fileByte2) log.Println(fileString) } 文件的常规操作，复制以下代码进main.go, 执行后看看效果, 再逐行阅读代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 设定工作路径, 一般在项目刚开始设定一次即可, 不要在异步过程中修改工作路径 // 默认是程序执行的路径 os.Chdir(\u0026#34;./\u0026#34;) // 创建文件夹 os.MkdirAll(\u0026#34;./aa/bb/c1\u0026#34;, 0777)\t//os.ModePerm 就是0777 os.MkdirAll(\u0026#34;./aa/bb/c2\u0026#34;, 0777) // 创建文件 os.Create(\u0026#34;./aa/bb/c1/file.go\u0026#34;) // 移动文件 os.Rename(\u0026#34;./aa/bb/c1/file.go\u0026#34;, \u0026#34;./aa/bb/c2/file.go\u0026#34;) // 打开文件,得到一个 *File 对象, 用于后续的写入 file, _ := os.OpenFile(\u0026#34;./aa/bb/c2/file.go\u0026#34;, 2, 0666) // 写入文件内容 io.WriteString(file, ` package main func main(){ log.Println(\u0026#34;我是由程序写入的代码\u0026#34;) } `) // 也可以直接调用file里的函数写入内容 file.WriteString(\u0026#34;add string\u0026#34;) // 拷贝文件, 拷贝其实就是创建一个文件, 然后写入文件内容 src1, _ := os.Create(\u0026#34;./aa/bb/c1/file-copy1.go\u0026#34;) io.Copy(file, src1) // 把文件file, 写入src1文件 // 删除文件或文件夹 os.Create(\u0026#34;./aa/bb/c1/file-delete.go\u0026#34;) // 创建一个文件用于删除 os.RemoveAll(\u0026#34;./aa/bb/c1/file-delete.go\u0026#34;) } 文件覆盖判断 os.IsNotExist 当文件已存在时, 不管是os.Rename(), os.Create(), 还是io.WriteString() 都会对已存在的文件进行覆盖\\修改,\n如果需要安全的执行, 可以使用 os.Stat() 配合 os.IsNotExist() 做判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { os.MkdirAll(\u0026#34;aa\u0026#34;, 0777) // 创建了文件 testA, 并且写入了内容 testA, _ := os.Create(\u0026#34;aa/testA\u0026#34;) io.WriteString(testA, \u0026#34;the teatA\u0026#34;) // 如果需要安全判断, 可以使用 os.Stat 配合 os.IsNotExist if _, err := os.Stat(\u0026#34;aa/testA\u0026#34;); os.IsNotExist(err) { // 当文件不存在, 才执行创建 os.Create(\u0026#34;aa/testA\u0026#34;) } os.Chmod(\u0026#34;aa/testA\u0026#34;, 0777) } 遍历文件夹 遍历文件夹可以使用 ioutil库 的ioutil.ReadDir, 会得到一个数组, 数组元素有文件的属性,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { fs, _ := ioutil.ReadDir(\u0026#34;aa\u0026#34;) for _, v := range fs { // 遍历得到文件名 log.Println(v.Name()) log.Println(v.IsDir()) } } 权限 可以使用 os.Chmod() 修改文件权限\n1 2 // 所有人可读写权限 os.Chmod(\u0026#34;aa/testA\u0026#34;, 0666) 1 2 // 只读权限 os.Chmod(\u0026#34;aa/testA\u0026#34;, 0400) Linux权限参考 1 2 3 4 5 6 7 -rw------- (600) 只有拥有者有读写权限。 -rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。 -rwx------ (700) 只有拥有者有读、写、执行权限。 -rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。 -rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。 -rw-rw-rw- (666) 所有用户都有文件读、写权限。 -rwxrwxrwx (777) 所有用户都有读、写、执行权限。 ","date":"2020-03-22T19:23:51Z","permalink":"https://blog.iostao.com/2020/03/go-os-operation/","title":"Golang 文件操作"},{"content":" string转成int： int, err := strconv.Atoi(string) string转成int64： int64, err := strconv.ParseInt(string, 10, 64) int转成string： string := strconv.Itoa(int) int64转成string： string := strconv.FormatInt(int64,10) ","date":"2020-03-16T09:51:36Z","permalink":"https://blog.iostao.com/2020/03/go-type-format/","title":"golang 中string和int类型相互转换"},{"content":"准备 在CentOS 的某个目录下，创建下面的目录形式（也可以本地创建，用ftp上传） /data/fileserver/\ndata fileserver Dockerfile nginx.conf data/ Dockerfile 这里先写 Dockerfile 文件，注意文件名保持一致\n1 2 3 4 5 6 7 8 9 FROM hub.c.163.com/public/nginx:1.2.1 #从镜像中心下载镜像，如果本地已经存在，则使用本地的。这里使用的163镜像中心 MAINTAINER tao ## 作者，可以不写 #COPY nginx.conf /etc/nginx/nginx.conf #这里是将 Dockerfile 同级目录的 nginx.conf 拷贝到 /etc/nginx/nginx.conf # 但是这里吧，后期 nginx.conf 可能会修改，所以我注释掉了 # 我用的是 -v 映射，后期修改的时候，重启一下镜像就可以了 nginx.conf nginx.conf 完整文件\n这里为了方便 ，配置文件中直接使用的是 user root; 最好是新创建一个用户。设置好权限。使用另一个用户，安全性更高一些。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 8080; server_name localhost; charset utf-8; #access_log logs/host.access.log main; location / { #显示的根目录 测试文字 root /usr/share/nginx/html; autoindex on; #开启索引功能 autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb） autoindex_localtime on; # 显示本机时间而非 GMT 时间 } } 镜像+容器 cd 到 fileserver目录下，执行命令，生成一个新的镜像 $ docker build -t fileserver .\n生成并运行容器\ndocker run -itd --restart=always -p 8090:8080 --name fileserver -v /data/fileserver/data:/usr/share/nginx/html/ -v /data/fileserver/nginx.conf:/etc/nginx/nginx.conf fileserver 这里nginx配置的是8080端口，也就是 -p 8090:8080 后面的这个8080，这个是容器内服务的端口，对外没有影响。8090是我们外面映射的端口，远程访问就是用这个8090的端口\n","date":"2020-03-05T09:54:25Z","permalink":"https://blog.iostao.com/2020/03/linux-start-03/","title":"CentOS 使用 Docker 服务搭建 Nginx 文件服务器"},{"content":"搭建mysql + FTP服务 一、安装 mysql 从官方下载mysql 5.7镜像 $ docker pull mysql:5.7 查看下载的镜像\n$ docker image docker安装 Mysql，并映射本地文件目录/data/mysql/data $ docker run -itd --restart=always -p 3306:3306 --name mysql -v /data/mysql/data:/var/lib/mysql -v /data/mysql/etc:/etc/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 options Mean -i 以交互模式运行容器，通常与 -t 同时使用 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 d | 后台运行容器，并返回容器ID \u0026ndash;restart | always 重启docker后，会立即启动服务 -p | 端口映射 3306:3306 前面的端口，代表本机（也就是centOS的端口），后面的端口，是docker容器内部的端口，和外部端口不冲突。比如mysql -p 3306:3306, slave -p 3307:3306。centOS的端口，分别是3306, 3307。mysql容器内部是3306， slave容器内部也是3306 -v | 路径映射，将容器中的数据映射到硬盘磁盘上 \u0026ndash;name | 别名，方便操作 mysql:5.7 | 最后这个是镜像名+镜像版本，docker images查看对比一下就可以了 当然也可以从网易云镜像 或者其他镜像仓库下载镜像。需要登录，然后进入控制台，镜像仓库\n查看运行的容器\n$ docker ps 进入容器，测试\n# 进入mysql容器 # 这个mysql是上面创建容器的时候，--name起的别名。也可以用容器id $ docker exec -it mysql bash $ mysql -u root -p # 输入密码，即可查看本地是否登录成功 远程连接，要注意mysql账号是否开启了远程登录，没有的话，需要设置一下\n二、FTP服务 docker下载 vsftpd镜像 docker pull docker.io/fauria/vsftpd 安装 docker run -d -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -v /data:/home/vsftpd/用户名 -e FTP_USER=用户名 -e FTP_PASS=密码 -e PASV_ADDRESS=服务器ip -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 --name vsftpd --restart=always docker.io/fauria/vsftpd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -p 映射端口 21100-21110 //被动模式随机端口 -v 映射目录，我这里是需要把本地目录映射到这个用户下。 所以需要把用户名加上 该用户在FTP中的目录是 /home/vsftpd/用户名 所以 本地目录: /home/vsftpd/用户名 这里需要把服务器的端口打开，登录腾讯云/阿里云后台 -\u0026gt; 控制台 -\u0026gt; 安全组 -\u0026gt; 修改规则 -\u0026gt; 添加规则 来源 //协议端口 备注 0.0.0.0/0 tcp:20 20 端口 0.0.0.0/0 tcp:21 21 端口 0.0.0.0/0 tcp:22 22 ssh端口 0.0.0.0/0 tcp:21100-21110 21100-21110 这是一个端口范围 远程FTP连接测试就可以了，FTP客户端工具 FileZilla下载\n有连接不上的，点端口扫描，进行一下端口扫描，看看服务端口是否关闭，如果关闭状态，去控制台添加一下规则，将端口打开。\n","date":"2020-02-25T13:12:10Z","permalink":"https://blog.iostao.com/2020/02/linux-start-02/","title":"CentOS 服务器 + mysql + vsftpd服务"},{"content":"docker网络命令 查看网络命令帮助 docker network help \u0026ndash; 各种网络命令Command \u0026ndash; connect Connect a container to a network 将一个容器连接到一个网络 create Create a network 创建一个网络 disconnect Disconnect a container from a network 从网络断开一个容器 inspect Display detailed information on one or more networks 在一个或多个网络上显示详细信息 ls List networks 网络列表 prune Remove all unused networks 删除所有未使用的网络 rm Remove one or more networks 删除一个或多个网络 docker查看命令 ###查看容器详细信息 docker inspect [容器id]\n查看容器端口信息 docker port [容器id] docker网络模式 从1.7.0版本开始，Docker正式把网络跟存储这两个部分的功能实现都以插件化的形式剥离出来，允许用户通过指令来选择不同的后端实现。这也就是Docker希望构建围绕着容器的强大生态系统的一些积极尝试。剥离出来的独立网络项目叫做libnetwork, libnetwork中的网络模型（Container Networking Model, CNM）十分简洁，可以让上层的大量应用容易最大程度上不去关心底层实现。\ndocker的常用的网络模式 ###bridge模式 简单来说：就是穿马甲，打着宿主机的旗号，做自己的事情。Docker的默认模式，它会在docker容器启动时候，自动配置好自己的网络信息，同一宿主机的所有容器都在一个网络下，彼此间可以通信。类似于我们vmware虚拟机的桥接模式。利用宿主机的网卡进行通信，因为涉及到网络转换，所以会造成资源消耗，网络效率会低。\n端口映射\n宿主机 公网ip:198.x.x.x ---\u0026gt; 容器ip: 172.17.0.x docker network create --driver [网络类型][网络名称] #参数 create 创建一个网络 --driver 指定网络类型 #命令演示 docker network create --driver bridge bridge-test host模式：简单来说，就是鸠占鹊巢，用着宿主机的东西，干自己的事情。容器使用宿主机的ip地址进行通信。特点：容器和宿主机共享网络\n容器使用宿主机的ip地址进行对外提供服务，本身没有ip地址。\ncontainer模式：新创建的容器间使用，使用已创建的容器网络，类似一个局域网。特点：容器和容器共享网络\nnone模式：这种模式最纯粹，不会帮你做任何网络配置，可以最大限度的定制化。不提供网络服务，容器启动后无网络链接。\noverlay模式：容器彼此不在同一个网络，而且能互相通信。\n自定义网段与网关 #自定义网段与网关 #查看关羽网段和网关的相关命令 docker network create --help --gateway strings IPv4 or IPv6 Gateway for the master subnet 主子网的IPv4或IPv6网关 --subnet strings\tSubnet in CIDR format that represents a network segment 表示网络段的CIDR格式的子网 #查看刚刚创建的网络信息 docker network inspect bridge-test docker network create --driver bridge --gateway 172.99.0.1 --subnet 172.99.0.0/16 bridge-test","date":"2019-07-19T14:37:55Z","permalink":"https://blog.iostao.com/2019/07/docker-net-shell/","title":"docker网络命令与基本查看命令"},{"content":"参数说明和示例 参数 说明 示例 addbr \u0026lt;bridge\u0026gt; 创建网桥 brctl addbr br10 delbr \u0026lt;bridge\u0026gt; 删除网桥 brctl delbr br10 addif \u0026lt;bridge\u0026gt; \u0026lt;device\u0026gt; 将网卡接口接入网桥 brctl addif br10 eth0 show \u0026lt;bridge\u0026gt; 查询网桥信息 brctl show br10 stp \u0026lt;bridge\u0026gt; {on | off} 启用禁用STP brctl stp br10 off/on showstp \u0026lt;bridge\u0026gt; 查看网桥STP信息 brctl showstp br10 setfd \u0026lt;bridge\u0026gt; \u0026lt;time\u0026gt; 设置网桥延迟 brctl setfd br10 10 showmacs \u0026lt;bridge\u0026gt; 查看mac信息 brctl showmacs br10 ","date":"2019-06-22T10:54:12Z","permalink":"https://blog.iostao.com/2019/06/linux-brctl-shell/","title":"Linux brclt 命令"},{"content":"转载自Ca0Gu0\nLinux 登陆服务器敲命令太多,某时候确实不便，但是如果使用脚本就会简便很多\n脚本下载 so.zip\n一、说明 支持密码和密钥两种格式 用户名和密码都是写文件的 二、配置 密码文件配置:\n序号:IP:端口:用户:密码:说明 1:192.168.88.128:22:root:toor:虚拟机web服务器\n密钥文件放在keys文件夹下,密码位置写成密钥文件名,文件名必须以.pem结尾\n如下所示：\n1:104.194.71.144:26999:root:WaFHwZm1AM3L5:搬瓦工 2:47.94.208.55:8080:root:aliyun.pem:阿里云 3:104.194.71.144:3306:ca0gu0:toor:虚拟机mysql数据库服务器 4:103:192.168.88.4:22:root:sellercube:本地开发服务器 ","date":"2019-04-05T11:55:55Z","permalink":"https://blog.iostao.com/2019/04/linux-shell-ssh/","title":"Linux Shell ssh登录脚本"},{"content":"CentOS 服务器 + Docker 1、可以通过阿里云、腾讯云购买一个服务器\n2、自己搭建一个本地服务器\n（我们这里以云服务器为例）\n一、登录服务器 ssh root@服务器ip -p 22 因为每次登录都需要输入一行带有ip的命令，比较麻烦。所以这里我用的脚本登录，每次登录的时候很方便，也方便管理多个服务器。\nLinux Shell ssh登录脚本 二、Cent OS操作 这里先记录一条命令 \u0026ndash; 开启，重启，停止命令 (这里以ftp服务命令为例）\nsudo systemctl start vsftpd sudo systemctl restart vsftpd sudo systemctl stop vsftpd 把yum包更新到最新\n$sudo yum update 安装各种服务 本人这里使用的是docker容器服务，mysql，redis，vsftpd服务，以及项目部署都是使用的docker。所以这里先安装 docker\ndocker最低支持的内核好像是3.0\n查看版本以及内核\n$ uname -a # 下面是输入命令后，返回的信息 Linux VM_0_7_centos 3.10.0-1062.9.1.el7.x86_64 #1 SMP Fri Dec 6 15:49:49 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装Docker容器服务 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\nyum install -y yum-utils device-mapper-persistent-data lvm2 安装 docker\nyum install docker -y 启动Docker\n启动Docker,设置开机启动, sudo systemctl start docker sudo systemctl enable docker #停止Docker sudo systemctl stop docker 验证是否安装成功\nsudo docker info 配置 docker 加速器\ncurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io Docker 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #查找Docker Hub上的镜像 $ docker search imageName/ID #获取Docker Hub上的镜像 $ docker pull ImageName/ID #显示本地主机上的镜像列表 $ docker images #运行本地主机上的镜像 $ docker run ImageName/ID #列出正在运行的容器 $ docker ps #查看正在运行容器的网络端口映射情况 $ docker port ContainerID #查看正在运行容器的内部正在进程运行 $ docker top ContainerID #查看正在运行容器的内部底层信息 $ docker inspect ContainerID #停止正在运行容器 $ docker stop ContainerID/ #重启已经停止的容器 $ docker start ContainerID #删除不需要的容器（必须在容器已经停止的情况下） $ docker rm ContainerimageID #移除本地镜像，移除前需要把该镜像下所有的容器删除 $ docker rmi ImageName/ID #登录docker $ docker login #运行ubuntu:16.04镜像并创建容器和启动bash终端 $ docker run -t -i ubuntu:16.04 /bin/bash #重命名容器名 $ docker rename wonderful_kepler Ubuntu16.04 #构建镜像 $ docker commit -m=\u0026#34;has update\u0026#34; -a=\u0026#34;SpiffyEight77\u0026#34; ff5d623e2d61 spiffyeight77/ubuntu:16.04 #提交镜像到docker hub 需要登录 $ docker push spiffyeight77/ubuntu 部分参数说明\n1 2 3 4 5 6 7 8 9 10 11 12 -d: 守护模式 后台运行 -p: 是容器内部端口绑定到指定的主机端口 -P: 是容器内部端口随机映射到主机的高端口 -f : 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出 -l : 查询最后一次创建的容器 -t : 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -i : 则让容器的标准输入保持打开 -m:提交的描述信息 -a: 指定镜像作者 --rm: 停止容器后移除容器 ff5d623e2d61: 容器ID spiffyeight77/ubuntu:16.04: 指定要创建的目标镜像名 编写 Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 不会写Dockerfile的话请自行Google FROM alpine:latest #使用了镜像大小体积只有5MB的alpine镜像 WORKDIR / #设置工作路径 ADD main / #把上文编译好的main文件添加到镜像里 EXPOSE 3000 #暴露容器内部端口 ENTRYPOINT [\u0026#34;./main\u0026#34;] #入口 ","date":"2019-02-20T12:22:27Z","permalink":"https://blog.iostao.com/2019/02/linux-start-01/","title":"CentOS 第一步"},{"content":"转载自简书\n1、AUAudioSession 概述 苹果官方图 可以看到AVAudioSession就是用来管理多个APP对音频硬件设备（麦克风，扬声器）的资源使用。\n举例一下AVAudioSession可以做这些事情\n设置自己的APP是否和其他APP音频同时存在，还是中断其他APP声音 在手机调到静音模式下，自己的APP音频是否可以播放出声音 电话或者其他APP终端自己APP的音频的事件处理 指定音频输入和输出的设备（比如是听筒输出声音，还是扬声器输出声音） 是否支持录音，录音同时是否支持音频播放 2、AVAudioSession Category AVAudioSession的接口比较简单。APP启动的时候会自动帮激活AVAudioSession，当然我们可以手动激活，代码如下：\n//导入头文件 #import \u0026lt;AVFoundation/AVFoundation.h\u0026gt; //AVAudioSession是一个单例类 AVAudioSession *session = [AVAudioSession sharedInstance]; //AVAudioSessionCategorySoloAmbient是系统默认的category [session setCategory:AVAudioSessionCategorySoloAmbient error:nil]; //激活AVAudioSession [session setActive:YES error:nil]; 可以看到设置session这里有两个参数，category和options\nCatogory iOS下目前有七种，每种Category都对应是否支持下面四种能力\nInterrupts non-mixable apps audio: 是否打断不支持混音播放的APP Silenced by the Silent switch: 是否会响应手机静音键开关 Supports audio input: 是否支持音频录入 Supports audio output: 是否支持音频播放 下面用图表来直观的看下每种category具体的能力集\nCategory 是否允许音频播放/录音 是否打断其他不支持混音APP 是否会被静音键或锁屏键静音 AVAudioSessionCategoryAmbient 只支持播放 否 是 AVAudioSessionCategoryAudioProcessing 不支持播放，不支持录制 是 否 AVAudioSessionCategoryMultiRoute 支持播放，支持录制 是 否 AVAudioSessionCategoryPlayAndRecord 支持播放，支持录制 默认YES，可以重写为NO 否 AVAudioSessionCategoryPlayback 只支持播放 默认YES,可以重写为NO 否 AVAudioSessionCategoryRecord 只支持录制 是 否（锁屏下仍可录制） AVAudioSessionCategorySoloAmbient 只支持播放 是 是 AVAudioSessionCategoryAmbient，只支持音频播放。这个 Category，音频会被静音键和锁屏键静音。并且不会打断其他应用的音频播放。\nAVAudioSessionCategorySoloAmbient，这个是系统默认使用的 Category，只支持音频播放。音频会被静音键和锁屏键静音。和AVAudioSessionCategoryAmbient不同的是，这个会打断其他应用的音频播放\nAVAudioSessionCategoryPlayback，只支持音频播放。你的音频不会被静音键和锁屏键静音。适用于音频是主要功能的APP，像网易云这些音乐app，锁屏后依然可以播放。\n需要注意一下，选择支持在静音键切到静音状态以及锁屏键切到锁屏状态下仍然可以播放音频 Category 时，必须在应用中开启支持后台音频功能，详见 UIBackgroundModes。\nAVAudioSessionCategoryRecord，只支持音频录制。不支持播放。\nAVAudioSessionCategoryPlayAndRecord，支持音频播放和录制。音频的输入和输出不需要同步进行，也可以同步进行。需要音频通话类应用，可以使用这个 Category。\nAVAudioSessionCategoryAudioProcessing，只支持本地音频编解码处理。不支持播放和录制。\nAVAudioSessionCategoryMultiRoute，支持音频播放和录制。允许多条音频流的同步输入和输出。（比如USB连接外部扬声器输出音频，蓝牙耳机同时播放另一路音频这种特殊需求）\n我们也可以通过AVAudioSession的属性来读取当前设备支持的Category ``` @property(readonly) NSArray\u0026lt;NSString *\u0026gt; *availableCategories;\n``` 这样可以保证设备兼容性\n设置Category的代码实例如下：\n``` NSError *setCategoryError = nil; BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:\u0026amp;setCategoryError]; if (!success) { //这里可以读取setCategoryError.localizedDescription查看错误原因 } ``` 3、AVAudioSession Mode\u0026amp;\u0026amp;Options 刚刚介绍的Category定义了七种主场景，实际开发需求中有时候需要对Category进行微调整，我们发现这个接口还有两个参数Mode和Options。\n``` /* set session category and mode with options */ - (BOOL)setCategory:(NSString *)category mode:(NSString *)mode options:(AVAudioSessionCategoryOptions)options error:(NSError **)outError API_AVAILABLE(ios(10.0), watchos(3.0), tvos(10.0)); ``` AVAudioSession Mode 我们通过读取下面这条属性获取当前设备支持的Mode\n1 @property(readonly) NSArray\u0026lt;NSString *\u0026gt; *availableModes; iOS下有其中mode 来定制我们的Category行为：\n模式 兼容的Category 场景 AVAudioSessionModeDefault All 默认模式 AVAudioSessionModeVoiceChat AVAudioSessionCategoryPlayAndRecord VoIP AVAudioSessionModeGameChat AVAudioSessionCategoryPlayAndRecord 游戏录制，GKVoiceChat自动设置 AVAudioSessionModeVideoRecording AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord 录制视频 AVAudioSessionModeMoviePlayback AVAudioSessionCategoryPlayback 视频播放 AVAudioSessionModeMeasurement AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback 最小系统 AVAudioSessionModeVideoChat AVAudioSessionCategoryPlayAndRecord 视频通话 下面逐一介绍下每个Mode\nAVAudioSessionModeDefault，默认模式,与所有的 Category 兼容\nAVAudioSessionModeVoiceChat，适用于VoIP 类型的应用。只能是 AVAudioSessionCategoryPlayAndRecord Category下。在这个模式系统会自动配置AVAudioSessionCategoryOptionAllowBluetooth 这个选项。系统会自动选择最佳的内置麦克风组合支持语音聊天。\nAVAudioSessionModeVideoChat，用于视频聊天类型应用，只能是 AVAudioSessionCategoryPlayAndRecord Category下。适在这个模式系统会自动配置 AVAudioSessionCategoryOptionAllowBluetooth 和 AVAudioSessionCategoryOptionDefaultToSpeaker 选项。系统会自动选择最佳的内置麦克风组合支持视频聊天。\nAVAudioSessionModeGameChat，适用于游戏类应用。使用 GKVoiceChat 对象的应用会自动设置这个模式和 AVAudioSessionCategoryPlayAndRecord Category。实际参数和AVAudioSessionModeVideoChat一致\nAVAudioSessionModeVideoRecording，适用于使用摄像头采集视频的应用。只能是 AVAudioSessionCategoryPlayAndRecord 和 AVAudioSessionCategoryRecord 这两个 Category下。这个模式搭配 AVCaptureSession API 结合来用可以更好地控制音视频的输入输出路径。(例如，设置 automaticallyConfiguresApplicationAudioSession 属性，系统会自动选择最佳输出路径。\nAVAudioSessionModeMeasurement，最小化系统。只用于 AVAudioSessionCategoryPlayAndRecord、AVAudioSessionCategoryRecord、AVAudioSessionCategoryPlayback 这几种 Category。\nAVAudioSessionModeMoviePlayback，适用于播放视频的应用。只用于 AVAudioSessionCategoryPlayback 这个Category。\nAVAudioSession Options 我们还可以使用options去微调Category行为，如下表\nOption Option功能说明 兼容的 Category AVAudioSessionCategoryOptionMixWithOthers 支持和其他APP音频 mix AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute AVAudioSessionCategoryOptionDuckOthers 系统智能调低其他APP音频音量 AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute AVAudioSessionCategoryOptionAllowBluetooth 支持蓝牙音频输入 AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryOptionDefaultToSpeaker 设置默认输出音频到扬声器 AVAudioSessionCategoryPlayAndRecord 调优我们的Category 通过Category和合适的Mode和Options的搭配我们可以调优出我们的效果，下面举两个应用场景:\n用过高德地图的都知道，在后台播放QQ音乐的时候，如果导航语音出来，QQ音乐不会停止，而是被智能压低和混音，等导航语音播报完后，QQ音乐正常播放，这里我们需要后台播放音乐，所以Category使用AVAudioSessionCategoryPlayback，需要混音和智能压低其他APP音量，所以Options选用 AVAudioSessionCategoryOptionMixWithOthers和AVAudioSessionCategoryOptionDuckOthers\n代码示例如下：\n1 2 3 4 5 BOOL isSuccess = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback withOptions: AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryOptionDuckOthers error:\u0026amp;setCategoryError]; 又或者我希望AVAudioSessionCategoryPlayAndRecord这个Category默认的音频由扬声器播放，那么可以调用这个接口去调整Category\n1 2 3 4 - (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError 通过选择合适和Category，mode和options，就可以调优音频的输入输出，来满足日常开发需求（需要注意的是Category，mode，option是搭配使用的，而不是简单组合，也就是说某种Category支持某些mode和option，从上面的表中也可以看出这一点）\n4. 音频中断处理 其他APP或者电话会中断我们的APP音频，所以相应的我们要做出处理。 我们可以通过监听AVAudioSessionInterruptionNotification这个key获取音频中断事件\n回调回来Userinfo有键值：\nAVAudioSessionInterruptionTypeKey： AVAudioSessionInterruptionTypeBegan: 表示中断开始 AVAudioSessionInterruptionTypeEnded: 表示中断结束 中断开始：我们需要做的是保存好播放状态，上下文，更新用户界面等 中断结束：我们要做的是恢复好状态和上下文，更新用户界面，根据需求准备好之后选择是否激活我们session。\n选择不同的音频播放技术，处理中断方式也有差别，具体如下:\nSystem Sound Services：使用 System Sound Services 播发音频，系统会自动处理，不受APP控制，当中断发生时，音频播放会静音，当中断结束后，音频播放会恢复。\nAV Foundation framework：AVAudioPlayer 类和 AVAudioRecorder 类提供了中断开始和结束的 Delegate 回调方法来处理中断。中断发生，系统会自动停止播放，需要做的是记录播放时间等状态，更新用户界面，等中断结束后，再次调用播放方法，系统会自动激活session。\nAudio Queue Services, I/O audio unit：使用aduio unit这些技术需要处理中断，需要做的是记录播放或者录制的位置，中断结束后自己恢复audio session。\nOpenAL：使用 OpenAL 播放时，同样需要自己监听中断。管理 OpenAL上下文，用户中断结束后恢复audio session。\n需要注意的是：1. 有中断开始事件，不一定对应有中断结束事件，所以需要在用户进入前台，点击UI操作的时候，需要保存好播放状态和对Audio Session管理，以便不影响APP的音频功能。2.音频资源竞争上，一定是电话优先。3. AVAudioSession同样可以监听外设音频状态，比如耳机拔入拔出。这里不做累述\n5. AVAudioSession总结 AVAudioSession的作用就是管理音频这一唯一硬件资源的分配，通过调优合适的AVAudioSession来适配我们的APP对于音频的功能需求。切换音频场景时候，需要相应的切换AVAudioSession。\n","date":"2018-07-27T11:10:43Z","permalink":"https://blog.iostao.com/2018/07/ios-avaudiosession/","title":"iOS-AVAudio"},{"content":"iPhone设备的屏幕尺寸有多种,屏幕的分辨率也有多种,如下表 设备 屏幕尺寸(英寸) 设计分辨率(点) 屏幕分辨率 说明 iPhone4/4s 3.5 320 * 480 640 * 960 Retain显示屏,326ppi iPhone5/5s/5c/SE 4.0 320 * 568 640 * 1136 Retain显示屏,326.ppi iPhone6/6s/7 4.7 375 * 667 750 * 1334 Retain HD显示屏,326.ppi iPhone6P/6sP/7P/8P 5.5 414 * 736 1242 * 2208 Retain HD显示屏, 401ppi iPhone X 5.8 375 * 812 1125 * 2436 Retain HD显示屏, 458ppi ","date":"2018-05-29T15:17:30Z","permalink":"https://blog.iostao.com/2018/05/ios-iphone-device/","title":"iPhone不同设备屏幕尺寸和分辨率"},{"content":"HTML样式、链接、表格 一、样式 1、标签 \u0026lt;style\u0026gt;: 样式定义 \u0026lt;link\u0026gt;: 资源引用 2、属性 `rel=\u0026quot;stylesheet\u0026quot;:外部样式表 (stylesheet只是其中之一) type=\u0026quot;text/css\u0026quot;:引入文档的类型 margin-left: 边距` 1、三种样式表插入方法\n外部样式表:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href= \u0026quot;mystyle.css\u0026quot;\u0026gt;\n内部样式表:\n\u0026lt;style type= \u0026quot;text/css\u0026quot;\u0026gt; body {background-color: red} p {margin-left: 20px} \u0026lt;/style\u0026gt;\n内联样式表:\n\u0026lt;p style= \u0026quot;color: red\u0026gt;\n二、HTML 链接 1、链接数据 文本链接 图片链接 2、属性 href属性：指向另一个文档的链接 name属性：创建文档内的链接 3、img标签属性\nalt：替换文本属性 width：宽 height：高 三、HTML 表格 1、 \u0026lt;table\u0026gt;\t定义表格 \u0026lt;caption\u0026gt;\t定义表格标题 \u0026lt;th\u0026gt;\t定义表格的表头 \u0026lt;tr\u0026gt;\t定义表格的行 \u0026lt;td\u0026gt;\t定义表格的单元 \u0026lt;thead\u0026gt;\t定义表格的页眉 \u0026lt;tbody\u0026gt;\t定义表格的主体 \u0026lt;tfoot\u0026gt;\t定义表格页脚 \u0026lt;col\u0026gt;\t定义表格的列属性 1、没有边框的表格 2、表格中的表头 3、空单元格 4、带有标题的表格 5、表格内的标签 6、单元格边距 7、单元格间距 8、表格内的背景颜色和图像 9、单元格内容排列 10、跨行和跨列单元格 L04_HTML5列表、块和布局 HTML5列表的使用 1、标签 \u0026lt;ol\u0026gt;\t有序列表 \u0026lt;ul\u0026gt;\t无序列表 \u0026lt;li\u0026gt;\t列表项 \u0026lt;dl\u0026gt;\t列表 \u0026lt;dt\u0026gt;\t列表项 \u0026lt;dd\u0026gt;\t描述 1、无序列表\n使用标签：\u0026lt;ul\u0026gt;、\u0026lt;li\u0026gt; 属性：\tdisc、circle、square 2、有序列表\n使用标签：\u0026lt;ol\u0026gt;、\u0026lt;li\u0026gt; 属性：\tA、a、l、i、start 3、嵌套列表\n使用标签：\u0026lt;ul\u0026gt;、\u0026lt;ol\u0026gt;、\u0026lt;li\u0026gt; 4、自定义列表\n使用标签：\u0026lt;dl\u0026gt;、\u0026lt;dt\u0026gt;、\u0026lt;dd\u0026gt; HTML块 1、HTML块元素\n快元素在显示时，通常会以新行开始 如：\u0026lt;h1\u0026gt;、\u0026lt;p\u0026gt;、\u0026lt;ul\u0026gt; 2、HTML内联元素\n内联元素通常不会以新行开始 如：\u0026lt;b\u0026gt;、\u0026lt;a\u0026gt;、\u0026lt;img\u0026gt; 3、HTML 元素\n\u0026lt;div\u0026gt;元素也被称为块元素，其主要是组合HTML元素的容器 4、HTML 元素\n\u0026lt;span\u0026gt;元素是内联元素，可作为文本的容器 HTML布局 1、使用元素布局 2、使用元素布局 ","date":"2017-03-11T10:35:56Z","permalink":"https://blog.iostao.com/2017/03/html-style-link-table/","title":"HTML样式、链接、表格"},{"content":"4.1 JavaScript基础教程 课程概要\nJavaScript介绍 JavaScript实现 JavaScript输出 JavaScript语法 JavaScript注释 JavaScript变量 JavaScript数据类型 4.1.1 JavaScript介绍 1、JavaScript介绍 1、JavaScript是互联网上最流行的脚本语言，这门语言可用于web和HTML，更可广泛用于服务器、pc端、移动端。\n2、JavaScript脚本语言：\nJavaScript是一种轻量级的编程语言 JavaScript是可插入HTML页面的编程代码 JavaScript插入HTML页面后，可由所有的浏览器执行 2、JavaScript实现 1、JavaScript用法：\nHTML中的脚本必须位于标签之间\n脚本可被放置在HTML页面的和部分中\n2、JavaScript标签：\n在HTML中插入JavaScript，使用之间书写代码\n3、JavaScript使用限制：\n在HTML中，不限制脚本数量\n通常会把脚本放置与标签中，以不干扰页面内容\n3、JavaScript输出 1、JavaScript通常用来操作HTML\n2、文档输出：\ndocument.write(\u0026quot;\u0026lt;p\u0026gt;this is my web page!\u0026lt;/p\u0026gt;\u0026quot;); 4.1.2 JavaScript语法和注释 1、JavaScript语句：\nJavaScript语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。\n2、分号：\n语句之间的分割是分号（;）\n注意：分号是可选项，有时候是看不到分号隔开的。\n3、JavaScript代码：\n按照编写顺序依次执行\n4、标识符\nJavaScript标志符必须以字母、下划线或美元符号开始\nJavaScript关键字\n5、JavaScript对大小写敏感\n6、空格\n7、代码换行\n8、保留字\n*** *** *** *** abstract else intanceof super boolean enum int switch break export interface synchronized byte extends let this case false long throw catch final native throws char finally new transient class float null true const for package try continue function private typeof debugger goto protected var default if public void delete implements return volatile do import short while double in static with JavaScript注释 1、单行注释：\n// 2、多行注释：\n/**/ 4.1.3 变量和数据类型 1、变量是用来储存信息的“容器”\n例： var x = 10; var y = 10.1; var z = \u0026quot;Hello\u0026quot;; 2、数据类型\n字符串（String） 数字（Number） 布尔（Boolean） 数组（Array） 对象（Object） 空（null） 未定义 可以通过赋值为null的方式清除变量 4.2 JavaScript语法详解 课程概要\nJavaScript运算符 JavaScript条件语句 JavaScript循环语句 JavaScript跳转语句 4.2.1 JavaScript运算符 1、算数运算符\n+、-、*、/、++、-- 2、赋值运算符\n=、+=、-=、*=、/=、%= 3、字符串操作\n4、比较运算符\n==、===、!=、!==、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;= 5、逻辑运算符\n\u0026amp;\u0026amp;、||、! 6、条件运算符\n例: x\u0026lt; 10? \u0026quot;x比10小\u0026quot; : \u0026quot;x比10大\u0026quot; 4.2.3 if(){} else 4.2.4 switch 4.2.5 循环语句 for循环 4.2.6 循环语句 while循环 4.2.7 跳转语句 break continue 4.3 JavaScript函数 课程概要\n了解函数 定义函数 函数调用 带参数的函数 带返回值的函数 4.3.1 了解函数 1、函数：\n函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。\n4.3.2 定义函数 1、定义函数\nfunction 函数名() { 函数体； （代码块） } 2、注意：\nJavaScript对大小写十分敏感，所以这里的function必须小写。在函数调用时，也必须按照函数的相同名称来调用函数。\n4.3.3 函数调用 1、函数调用：\n函数在定义好之后，不能自动执行，需要进行调用\n2、调用方式：\n在script\u0026gt;标签内调用 在HTML文件中调用 4.3.4 带参数的函数 1、函数参数：\n在函数的调用中，也可以传递值，这些值被称为参数\n例： demo(arg1, arg2); 2、参数的个数可以为任意多，每个参数通过“ , ”隔开\n3、注意：\n参数在传递时，其顺序必须一致\n4、参数意义：\n通过传递参数的个数以及参数的类型不同完成不同的功能\n4.3.5 带返回值的函数 1、返回值：\n有时，我们需要将函数的值返回给调用它的地方\n通过return语句就可以实现\n注意：在使用return语句时，函数停止执行，同时返回值\n4.3.6 局部变量和全局变量 4.4 JavaScript异常处理和事件处理 课程概要\n异常捕获 事件处理 4.4.1 异常捕获 1、异常：\n当JavaScript引擎执行JavaScrpit代码时，发生了错误，导致程序停止运行\n2、异常抛出：\n当异常产生，并且将这个异常生成一个错误信息\n3、异常捕获：\ntry { 发生异常的代码块; }catch(err) { 错误信息处理； } 4、Throw语句：\n通过throw语句创建一个自定义错误\n4.4.2 JavaScript事件 1、什么是事件；\n事件是可以被JavaScript侦测到的行为\n2、主要事件：\n事件 描述 onClick 单击事件 onMouseOver 鼠标经过事件 onMouseOut 鼠标移出事件 onChange 文本内容改变事件 onSelect 文本框选中事件 onFocus 光标聚集事件 onBlur 移开光标事件 onLoad 网页加载事件 onUnload 关闭网页事件 ","date":"2017-03-09T15:07:25Z","permalink":"https://blog.iostao.com/2017/03/html-javascript-elements/","title":"JavaScript 基础教程"},{"content":"3.7 CSS动画\u0026ndash;页面特效 课程概要\n2D、3D转换 过渡 动画 多列 1、“2D、3D转换” 1、通过CSS3转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸\n转换是使元素改变形状、尺寸和位置的一种效果\n可以使用2D、3D来转换元素\n2、2D转换方法:\ntranslate() rotate() scale() skew() matrix() 3、3D转换方法\nrotateX() rotateY() 2、过渡 1、通过使用CSS3，可以给元素添加一些效果\n2、CSS3过渡是元素从一种样式转换成另一种样式\n动画效果的CSS 动画执行的时间 3、属性\n属性 描述 transition 设置四个过渡属性 transition-property 过渡的名称 transition-duration 过渡效果花费的时间 transition-timing-function 过渡效果的时间曲线 transition-delay 过渡效果开始时间 3、动画 1、通过CSS3，也可以进行创建动画\n2、CSS3的动画需要遵循@keyframes规则\n规定动画的时长 规定动画的名称 4、多列 1、在CSS3中，可以创建多列来对文本或者区域进行布局 2、属性：\ncolumn-count column-gap column-rule 5、HTML与CSS的实例效果 ","date":"2017-03-07T15:06:23Z","permalink":"https://blog.iostao.com/2017/03/html-css-animation/","title":"3.7 CSS动画--页面特效"},{"content":"3.4 CSS定位 概要\nCSS定位 CSS浮动 3.4.1 CSS定位 1、CSS定位 改变元素在页面上的位置\n2、CSS定位机制 普通流：元素按照其在HTML中的位置顺序决定排布的过程 浮动 绝对布局 3、CSS定位属性： 属性 描述 position 把元素放在一个静态的、相对的、绝对的、或固定的位置中 top 元素向上的偏移量 left 元素向左的偏移量 right 元素向右的偏移量 bottom 元素向下的偏移量 overflow 设置元素溢出其区域发生的事情 clip 设置元素显示的形状 vertical-align 设置元素垂直对齐方式 z-index 设置元素的堆叠顺序 1、CSS position属性：\nposition属性 static relative absolute fixed 3.4.2 CSS定位-浮动 1、浮动：\nfloat属性可用的值：\nleft：元素向左浮动 right：元素向右浮动 none：元素不浮动 inherit：从父级继承浮动属性 2、clear属性：\n去掉浮动属性（包括继承来的属性）\nclear属性值：\nleft、right：去掉元素向左、向右浮动 both：左右两侧均去掉浮动 inherit：从父级继承来clear的值 3.4.3 CSS定位-浮动的应用 3.5 CSS选择器 概要\n元素选择器 选择器分组 类选择器详解 ID选择器详解 属性选择器详解 后代选择器 子元素选择器 相邻兄弟选择器 元素选择器 1、最常见的选择器就是元素选择器，文档的元素就是最基本的选择器\n例如： h1{]、a{} 选择器分组 1、例如：\nh1、h2{} 2、通配符\n* {} 类选择器 1、类选择器允许以一种独立与文档元素的方式来指定样式\n例如： .class {} 2、结合元素选择器\n例如： a.class{} 3、多类选择器\nID选择器： ID选择器类似于类选择器，不过也有一些重要差别\n例如： #id{} 2、类选择器和ID选择器区别\nID只能在文档中使用一次，而类可以多次使用 ID选择器不能结合使用 当使用js时候，需要用到id 属性选择器 1、简单属性选择\n例如： [title]{} 2、根据具体属性值选择\n除了选择拥有某些的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素\n例如： a[href=\u0026quot;http://blog.devtao.com\u0026quot;] {} 3、属性和属性值必须完全匹配 4、根据部分属性值选择\n后代选择器 1、后代选择器：\n后代选择器可以选择作为某元素后代的元素\n子元素选择器 1、与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素\n例如： h1\u0026gt;strong {}; 相邻兄弟选择器 可选择紧接在另一个元素后的元素，且二者有相同父元素\n例如： h1 + p {}; 3.6.1 CSS常用操作 概要\n对齐操作 尺寸操作 分类操作 导航栏 图片操作 1、对齐操作 1、使用margin属性进行水平对齐 2、使用position属性进行左右对齐 3、使用float属性进行左右对齐\n3.6.2 分类 1、尺寸操作\n属性 描述 height 设置元素高度 line-height 设置行高 max-height 设置元素最大高度 max-width 设置元素最大宽度 min-width 设置元素最小宽度 min-height 设置元素最小高度 width 设置元素宽度 2、分类操作\n属性 描述 clear 设置一个元素的侧面是否允许其他的浮动元素 cursor 规定当指向某元素之上时显示的指针类型 display 设置是否及如何显示元素 float 定义元素在哪个方向浮动 position 把元素放置到一个静态的、相对的、绝对的、固定的位置 visibility 设置元素是否可见或不可见 3.6.3 导航栏 1、垂直导航栏\n2、水平导航栏\n3.6.4 图片操作 ","date":"2017-03-05T15:13:57Z","permalink":"https://blog.iostao.com/2017/03/html-css-position/","title":"3.4 CSS定位 + 3.5 + 3.6"},{"content":"3.3 CSS盒子模型 课程概要 CSS盒子模型概述 CSS内边距 CSS边框 CSS外边距 CSS外边距合并 3.3.1 CSS盒子模型-概述 1、盒子模型的内容范围包括\nmargin（外边距）、border（边框）、padding（内边距）、content部分组成 height、width 3.3.2 CSS盒子模型-内边距 1、内边距\n内边距在content外，边框外 2、内边距属性\n属性 描述 padding 设置所有边距 padding-bottom 设置底边距 padding-left 设置左边距 padding-right 设置右边距 padding-top 设置上边距 3.3.3 CSS盒子模型-边框 1、CSS边框：\n我们可以创建出效果出色的边框，并且可以应用于任何元素\n2、边框的样式：\nborder-style: 定义了10个不同的非继承样式，包括none\n3、边框的单边样式：\nstyle border-top-style border-left-style border-right-style border-bottom-style 4、边框的宽度：\nborder-width 5、边框单边的宽度：\nstyle border-top-width border-left-width border-right-width border-bottom-width 6、边框的颜色：\nborder-color 7、边框单边的颜色\nstyle border-top-color border-left-color border-right-color border-bottom-color 8、CSS3边框\nCSS3边框 说明 border-radius 圆角边框 box-shadow 边框阴影 border-image 边框图片 box-shadow 背景阴影右移移动像素、下移移动像素、背景阴影透明度、颜色 3.3.4 CSS盒子模型-外边距 1、外边距：\n围绕在内容边框的区域就是外边距，外边距默认为透明区域\n外边距接受任何长度单位、百分数值\n2、外边距常用属性\n属性 描述 margin 设置所有边距 margin-bottom 设置底边距 margin-left 设置左边距 margin-right 设置右边距 margin-top 设置上边距 3.3.5 CSS盒子模型-外边距合并 1、外边距合并：\n外边距合并就是一个叠加的概念\n3.3.6 CSS盒子模型-盒子模型应用 极客学院官网效果\n","date":"2017-03-04T15:01:17Z","permalink":"https://blog.iostao.com/2017/03/html-css-box/","title":"3.3 CSS盒子模型"},{"content":"3.2 CSS基础样式讲解 概要 CSS介绍 CSS基础语法 CSS高级语法 CSS派生选择器 CSSid选择器 CSS类选择器 CSS属性选择器 3.2.1 CSS基础-介绍及语法 CSS概述：\nCSS指层叠样式表 CSS样式表极大地提高了工作效率 1、CSS基础-介绍及语法 1、基础语法： 1、\nselector { property: value } 例： h1 {color:red; font-size:14px;} 属性大于1个之后，属性之间用分号隔开\n如果值大于1个单词，则需要加上引号：\np {font-family: \u0026quot;sans serif\u0026quot;} 2、CSS高级语法： 1、选择器分组\nh1, h2, h3, h4, h5, h6 {color:red}; 2、继承：\nbody { color:green; } 3、CSS基础-派生选择器 1、派生选择器：\n通过依据元素在其位置的上下文关系来定义样式\n3、CSS基础-id选择器 1、id选择器：\nid选择器可以为标有id的HTML元素制定特定的样式\nid选择器以 \u0026ldquo;#\u0026rdquo; 来定义\n2、id选择器和派生选择器\n目前比较常用的方式是id选择器常常用用建立派生选择器\n4、类选择器 1、类选择器\n类选择器以一个点显示\n2、clas也可以用作派生选择器\n5、属性选择器 1、属性选择器：\n对带有指定属性的HTML元素设置样式\n2、属性和值选择器\n","date":"2017-03-03T15:13:57Z","permalink":"https://blog.iostao.com/2017/03/html-css-style/","title":"3.2 CSS基础样式讲解"},{"content":"3.1 CSS3基础 一、CSS入门基础 1、背景 CSS允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果\n属性 | 描述 --------------------- | ---------------------------- background-attachment | 背景图像是否固定或者随着页面的其余部分滚动 background-color | 设置元素的背景颜色 background-image | 设置图片的背景图片 background-position | 设置背景图片的起始位置 background-repeat | 设置背景图片是否及如何重复 2、文本 CSS文本属性可定义文本外观\n通过文本属性，可以改变文本的颜色、字符间距、对齐方式、装饰文本、对文本缩进\n属性 描述 color 文本颜色 direction 文本方向 line-height 行高 letter-spacing 字符间距 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-transform 元素中的字母 unicode-bidi 设置文本方向 white-space 元素中空白的处理方式 word-spacing 字间距 CSS3文本效果 text-shadow: 向文本添加阴影\nword-wrap:\t规定文本的换行规则\n3、字体 CSS字体属性定义文本的字体系列、大小、加粗、风格和变形\n属性 描述 font-family 设置字体系列 font-size 设置字体的尺寸 font-style 设置字体风格 font-variant 以小型大写字体或正常字体显示文本 font-weight 设置字体的粗细 4、链接 1、CSS链接的四种状态 a:link\t普通的、未被访问的链接 a:visited 用户已访问的链接 a:hover\t鼠标指针位于链接的上方 a:active\t链接被点击的时刻 2、常见的链接样式： text-decoration属性大多用于去掉链接中的下划线\n5、列表 CSS列表属性允许你放置、改变列表标志，或者将图像作为列表项标志\n属性 描述 list-style 简写列表项 list-style-image 列表项图像 list-style-position 列表标志位置 list-style-type 列表类型 6、表格 1、CSS表格：\nCSS表格属性可以帮助我们极大的改善表格的外观 2、表格边框 3、折叠边框 4、表格宽高 5、表格文本对齐 6、表格内边距 7、表格颜色\n7、轮廓 1、轮廓主要是用来突出元素的作用\n属性 描述 outline 设置轮廓属性 outline-color 设置轮廓的颜色 outline-style 设置轮廓的样式 outline-width 设置轮廓的宽度 ","date":"2017-03-02T14:08:54Z","permalink":"https://blog.iostao.com/2017/03/html-css-elements/","title":"3.1 CSS3基础"},{"content":"HTML5框架、背景和实体-框架 HTML框架 背景、颜色 HTML实体 HTML框架 1、 框架标签（frame）\n框架对于页面的设计有着很大的作用\n2、框架集标签（）\n框架集标签定义如何将窗口分割为框架 每一个frameset定义一系列行或列 rows/cols的值规定了每行或每列占据屏幕的面积 3、常用标签\nnoresiez: 固定框架大小 cols: 列 rows: 行 4、内联框架\niframe （经常使用） XHTML介绍 XHTML简介 XHTML元素 XHTML属性 一、什么是XHTML? XHTML指的是可扩展超文本标记语言 XHTML与HTML4.01几乎是相同的 XHTML是更严格更纯净的HTML版本 XHTML是以XML应用的方式定义的THML XHTML得到所有主流浏览器的支持 2、为什么使用XHTML?\n为了代码的完整性和良好性\n3、文档声明\nDTD:规定了使用通用标记语言的网页语法\n4、三种XHTML文档类型\nSTRICT（严格类型） TRANSITIONAL（过渡类型） FRAMESET（框架类型） 5、\nXHTML 1.0 Strict: \u0026lt;!DOCTYPE htmlPUBLIC \u0026quot;-//W3C//DTD XHTML 1.0 Strict//EN\u0026quot; \u0026quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026quot;\u0026gt; 该DTD包含所有HTML元素和属性，但不包括展示性的和弃用的元素（比如font）。不允许框架集（Framesets）。\n1、XTML元素语法\nXHTML元素必须正确嵌套 XHTML元素必须始终关闭 XHTML元素必须小写 XHTML文档必须有一个根元素 二、XHTML属性 1、XHTML属性语法规则\nXHTML属性必须使用小写 XHTML属性值必须用引号包围 XHTML属性最小化也是禁止的 ","date":"2017-03-01T09:13:57Z","permalink":"https://blog.iostao.com/2017/03/html-framework-bg/","title":"HTML5框架、背景和实体-框架"},{"content":"【SpriteKit】 在iOS7中内置了新的SpriteKit框架，该框架主要用来开发2D游戏。是开发iOS和OS X 下的2D游戏引擎，可以使用OC或者Swift来进行开发。目前已经支持的内容包括：精灵、很酷的特效（例如视频、滤镜和遮罩），并且还集成了物理库等许多东西。首先指出在iOS中开发2D游戏SpriteKit并不是唯一的选择，我们先来看看SpriteKit的特点和优缺点：\n1.特点： （1）提供了游戏引擎必备的图形渲染和动画API，可以通过这些API让精灵动起来； （2）使用传统的渲染和动画，允许在渲染每一帧之前处理该帧； （3）提供了声音播放； （4）提供的物理引擎； （5）与Xcode集成，可以更容易的创建基于Sprite Kit的游戏工程，调试也很方便； （6）可以使用Swift语言；\n2.优点： （1）它是内置到iOS中的，因此并不需要下载额外的库或者其他的外部依赖，并且它是由苹果开发的，所以对他的支持和更新我们可以放心； （2）它内置的工具支持纹理和粒子； （3）它可以让你做一些其他框架难以做到的事情，例如把视频当做精灵一样处理，或者使用很酷的图形效果和遮罩。 3.缺点： （1）如果使用了SpriteKit，那么你将被iOS生态圈绑架，导致很难把游戏移植到Android等其他平台； （2）SpriteKit现在还处于初始阶段，提供的内容还不够丰富，例如Cocos2D，暂不支持自定义的OpenGL代码；\n【SceneKit】 SceneKit(SK)是WWDC12推出的OS X平台的cocos 3D渲染引擎框架。支持粒子效果，物理模拟，脚本事件，多程渲染，支持iOS平台。SceneKit整合了Core Image，Core Animation之类的图形框架，现在还整合进了SpriteKit。 SceneKit是基于OpenGL构建的。\n【Metal】 在iOS8中，苹果发布了一个新的接口叫做Metal，它是一个支持GPU加速的3D绘图API。Metal和OpenGL ES类似，也是一个底层API，负责和3D绘图硬件交互。可惜的是，Metal不是跨平台的。\n","date":"2016-12-18T22:08:49Z","permalink":"https://blog.iostao.com/2016/12/ios-spritekit-scenekit/","title":"iOS SpriteKit/SceneKit/Metal浅析"},{"content":"\n内存和活动管理选项( memory and activity management options)是今年苹果在OS发布的新技术(包括 OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0).这个包括用.initiallyInactive在非活动的状态启动一个队列,或者为你的线程设置一个自动释放属性(.autoreleaseInherit, .autoreleaseNever, .autoreleaseWorkItem)\nswift 3中对C层级的GCD的API进行了彻头彻尾的改变。本文将从实际使用场景来了解一下新的api使用。\ndispatch_async 一个常见的场景就是在一个全局队列进行一些操作后切换到主线程配置UI。现在是这么写：\nDispatchQueue.global().async { // code DispatchQueue.main.async { // 主线程中 } } global()是一个有着默认参数的静态函数：\nclass DispatchQueue : DispatchObject { public class var main: DispatchQueue public class func global(qos: DispatchQoS.QoSClass = default) -\u0026gt; DispatchQueue } sync\n如果想同步执行操作，和async类似，调用sync就可以了：\nDispatchQueue.global().sync { // 同步执行 } 优先级：DispatchQoS 我们知道，GCD 的默认队列优先级有四个：\nDISPATCH_QUEUE_PRIORITY_HIGH DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND 现在则改为了QoSClass枚举\npublic enum QoSClass { case background case utility case `default` case userInitiated case userInteractive case unspecified public init?(rawValue: qos_class_t) public var rawValue: qos_class_t { get } } 这些命名比原先的更加友好，能更好表达这个操作的意图。\n和原有的对应关系是：\nDISPATCH_QUEUE_PRIORITY_HIGH: .userInitiated DISPATCH_QUEUE_PRIORITY_DEFAULT: .default DISPATCH_QUEUE_PRIORITY_LOW: .utility DISPATCH_QUEUE_PRIORITY_BACKGROUND: .background 创建队列 DispatchQueue的默认初始化方法创建的就是一个同步队列，如果要创建并发的队列，在attributes中声明concurrent。\n// 同步队列\nlet serialQueue = DispatchQueue(label: \u0026quot;queuename\u0026quot;) // 并发队列\nlet concurrentQueue = DispatchQueue(label: \u0026quot;queuename\u0026quot;, attributes: .concurrent) 推迟时间后执行\n原先的dispatch_time_t现在由DispatchTime对象表示。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。\nlet delay = DispatchTime.now() + DispatchTimeInterval.seconds(60)DispatchQueue.main.asyncAfter(deadline: delay) { // 延迟执行} 这里也可以直接加上一个秒数。\nlet three = DispatchTime.now() + 3.0 因为DispatchTime中自定义了+号。\npublic func +(time: DispatchTime, seconds: Double) -\u0026gt; DispatchTime DispatchGroup\n如果想在dispatch_queue中所有的任务执行完成后再做某种操作可以使用DispatchGroup。原先的dispatch_group_t由现在的DispatchGroup对象代替。\nlet group = DispatchGroup() let queueBook = DispatchQueue(label: \u0026quot;book\u0026quot;) queueBook.async(group: group) { // 下载图书 } let queueVideo = DispatchQueue(label: \u0026quot;video\u0026quot;) queueVideo.async(group: group) { // 下载视频 } group.notify(queue: DispatchQueue.main) { // 下载完成 } DispatchGroup会在组里的操作都完成后执行notify。\n如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用wait\ngroup.wait() DispatchWorkItem\n使用DispatchWorkItem代替原来的dispatch_block_t。 在DispatchQueue执行操作除了直接传了一个() -\u0026gt; Void类型的闭包外，还可以传入一个DispatchWorkItem。\npublic func sync(execute workItem: DispatchWorkItem) public func async(execute workItem: DispatchWorkItem) DispatchWorkItem的初始化方法可以配置Qos和DispatchWorkItemFlags，但是这两个参数都有默认参数，所以也可以只传入一个闭包。\npublic init(qos: DispatchQoS = default, flags: DispatchWorkItemFlags = default, block: @escaping @convention(block) () -\u0026gt; ()) let workItem = DispatchWorkItem { // TODO: } DispatchWorkItemFlags枚举中assignCurrentContext表示QoS根据创建时的context决定。\n值得一提的是DispatchWorkItem也有wait方法，使用方式和group一样。调用会等待这个workItem执行完。\nlet myQueue = DispatchQueue(label: \u0026quot;my.queue\u0026quot;, attributes: .concurrent) let workItem = DispatchWorkItem { sleep(1) print(\u0026quot;done\u0026quot;) } myQueue.async(execute: workItem) print(\u0026quot;before waiting\u0026quot;) workItem.wait() print(\u0026quot;after waiting\u0026quot;) barrier\n假设我们有一个并发的队列用来读写一个数据对象。如果这个队列里的操作是读的，那么可以多个同时进行。如果有写的操作，则必须保证在执行写入操作时，不会有读取操作在执行，必须等待写入完成后才能读取，否则就可能会出现读到的数据不对。在之前我们用dipatch_barrier实现。 现在属性放在了DispatchWorkItemFlags里。\nlet wirte = DispatchWorkItem(flags: .barrier) { // write data}let dataQueue = DispatchQueue(label: \u0026quot;data\u0026quot;, attributes: .concurrent) dataQueue.async(execute: wirte) 信号量\n为了线程安全的统计数量，我们会使用信号量作计数。原来的dispatch_semaphore_t现在用DispatchSemaphore对象表示。 初始化方法只有一个，传入一个Int类型的数。\nlet semaphore = DispatchSemaphore(value: 5) // 信号量减一 semaphore.wait() //信号量加一 semaphore.signal() dispatch_once在swift 3中已经被废弃了。\n简单的建议就是一些初始化场景就用懒加载吧。\n// Examples of dispatch_once replacements with global or static constants and variables. // In all three, the initialiser is called only once. // Static properties (useful for singletons). class Object { static let sharedInstance = Object() } // Global constant. let constant = Object() // Global variable. var variable: Object = { let variable = Object() variable.doSomething() return variable }()","date":"2016-10-30T15:45:13Z","permalink":"https://blog.iostao.com/2016/10/swift3-gcd-dispatch-async/","title":"Swift3中dispatch_once废弃的解决办法"},{"content":"#### Lektion 21 AufeinerParty 在派对中\r301.Ich fuehle mich wirklich wohl hier.我真的玩得很开心。\r302.Es ist zu voll,um zur Kueche zu kommen.人太多,很难挤到厨房那边去。\n303.Kennen Sie irgendjemanden auf dieser Party?在这聚会上,您认识什么人吗? 304.Ich moechte mich hier amuesieren.我会在这儿玩得很开心的。\r305.Warum bleiben wir nicht fuer eine halbe Stunde hier,um zu gucken,ob sonst noch\rjemand kommt? 我们为什么不在这儿呆上半个小时左右,看看有什么别的人来。 306.Ich glaube ,dass wir kein Bier mehr haben.我想我们没有啤酒了。 307.Hat jemand diesen Kerl eingeladen?有谁邀请那个人了吗? 308.Diese Partys sind immer so gut.这些聚会总是很受欢迎。\r309.Es sind heute Abend zu viele aeltere Studenten hier.今晚这里有太多的年纪大的学生 了。\r310.Soll ich hingehen,und mit diesem Maedchen sprechen?我应该过去和那个女孩说话 吗?\r311.Kannst du mir sagen,wo das Badezimmer ist?你能告诉我洗手间在哪儿吗?\r312.Ich glaube,einige Leute verlassen uns,um zu einer anderen Party zu gehen.我想有些 人要离开去参加另一个聚会了。\r313.Du solltest langsamer trinken.你应该慢点喝。\r314.Ich bin muede ,deshalb gehe ich nach Hause.我累了,所以我要回家了。\r315.Es sind immer die glechen Gesichter auf dieser Partys.这些聚会上,总是些老面孔。\r#### Lektion 22 Im Krankenhaus 在医院\r316.Sein Bein ist verletzt.他的腿受伤了。\r317.Der Arzt schaut gerade nach ihm.医生正在给他诊治。\r318.Wissen Sie etwas ueber seinen Zustand?您知道他现在的情况吗?\r319.Ich dachte,dass es ernster sein koennte.我以为可能会更严重些。\r320.Ihre Mutter befindet sich jetzt in einem stabilen Zustand.您母亲现在的病情稳定了。 321.WelcheHand schmerzt?您哪只手痛?\r322.Wie lange ist es so angeschwollen wie jetzt?肿成这样多久了?\r323.Koennen Sie Ihren Aermel aufkrempeln,damit ich einen Blick darauf werfe?您能把袖子卷起来让我看看吗?\r324.Haben Sie eine Krankenversicherung?您有医疗保险吗?\r325.Haben Sie eine Herzerkrankung?您有心脏病史吗?\r326.Wir haben im Augenblick keine Ersatzbetten.我们现在没有床位。\r327.Die Schmerzen sind vorwiegend im unteren Teil des Rueckens.疼痛主要在背部的下\r面。\r328.Tutes weh,wenn ich so mache?我这有您疼吗?\r329.Ich schreibe Ihnen einen Rezept aus.我给您开个药方。\r330.Sie sollten das Bein fuer einige Wochen schonen.您的那条腿要休息几个星期。\r#### Lektion 23 Auf der Post 在邮局\r331.Es ist nicht sehr interessant, in der Schlange auf dem Postamt zu warten.在邮局排队可不是什么好玩的事情。\r332,Ich muss diese Sachen fuer meinen Chef verschichen.我必须帮我老板把这东西邮寄了。\r333.Ich habe nur einen Brief an meine Mutter.只是封给我妈妈的信。\r334.Ich muss dieses Paket per Luftpost verschiken. 我必须航空邮寄这包裹。 335.Ich erwarte ein Paket,das schon vor zwei Wochen hier gewesen sein sollte.\r我在等一个包裹,这个包裹两个星期就应该到了。\r336.Wie viel mehr kostet Eilpost?特快专递要多花多少钱?\r337.Kann ich dieses Paket versichern?这包裹能保险吗?\r338.Ich muss meine Postadresse aendern.我需要更改我的邮件地址。 339.Dieses Paket wiegt 11 Unzen.这件包裹重 11 盎司。\r340.Das ist der Briefkasten fuer Post in andere Staedte.那是外地信件邮箱。 341.Wie viel kostet ein Briefmarkenheft?一本集邮册多少钱? 342.Bekomme ich hier eine Postkarte?这儿有明信片吗?\r343.Gibt es einen Leiter,mitdem ich sprechen kann?我能找位主管谈谈吗? 344.Ich mag diese neuen Briefmarken.我喜欢这些新邮票。\r345.Kann ich hier einen Pass beantragen?我能在这申请护照吗?\r#### Lektion 24 In der Bank\r346.Ist dies die richtige Stelle,um ein Konto zu eroeffnen?是在这里开户吗?\r347.Ich moechte ein Bankkonto eroeffnen.我需要开个银行账户。\r348.Ist es ein Scheckkonto oder ein Sparkonto?是支票账户还是储蓄账户?\r349.Mir wurde gesagt,dass ich zu wenig Kapital habe.我被告知存款不足。\r350.Wie hoch sind Ihre Zinsen fuer das Wohnungsdarlehen?您的住房贷款的利率是多少?\r351.Koenen Sie mir helfen,ein Auto zu finanzieren?您能帮我贷款买车吗?\r352.Wie ist mein gegenwaertiger Kontostand?我现在的余额是多少?\r353.Meine Geldkarte funktioniert nicht mehr.我的银行卡失效了。\r354.Sie brauchen keinen Pass fuer Routinegeschaefte.日常事务您不需要护照。\r355.Ich kann mich nicht an meine Kontonummer erinnern.我记不起我的账号了。 356.Gibt es eine minimalen Kontostand,der fuer ein Konto benoetigt wird?这个账户有最\r低余额限制吗?\r357.Ich moechte Reisechecks.我想要旅行支票。\r358.Ich habe ein gemeinsame Konto mit meiner Frau.我和我妻子有一个联名账户。 359.Kann ich eine Quittung dafuer haben?能给我开个收据吗?\r360.Ihr Konto ist ueberzogen.您的账户透支了。\r#### Lektion 25 In Restaurant und Hotel 在餐馆,旅馆\r361.Ich werde ein Steak essen.我来一份牛排。\r362.Wie moechten Sie Ihr Steak gebraten?您的牛排要几分熟? 363.Mein Kompliment ist an den Chef.我要称赞厨师。\r364.Wasist Ihre heutige Spezialitaet?您今天的招牌菜式什么? 365.Moechten Sie noch etwas Kaffee?要不要再来点咖啡? 366.Haben Sie heute Abend reserviert?您今晚预定了桌位吗? 367.Kann ich einen Blick in die Speisekarte werfen?我能看看菜单吗? 368.Moechten Sie einen Nachtisch haben?您要甜点吗?\r369.Willkommenim Komfort-Hotel.欢迎来到康复德旅店。\r370.Ich brauche ein Zweibettzimmer 我要一件双人房。\r371.Wir erlauben keine Haustiere im unseren Raeumen.我们房间不允许宠物入内。 372.Moechten Sie ein Einzelzimmer oder Doppelzimmer?您要单人房还是双人房? 373.Der Aufzug ist am Ende der Halle.电梯在大厅尽头。\r374.Ich habe kein Heisswasser in meinem Zimmer.我的房间没有热水。\r375.Ich brauche ein Taxizum Flughafen.我需要一辆出租车去机场。\r#### Lektion 26 Im Buero 在办公室\r376.Nehmen Sie bitte Platz.请坐。\r377.Washalten Sie von Arbeiten am Wochenende?您觉得周末上班怎么样?\r378.Der Yachthandel verlaeuft in dieser Zeit des Jahres schleppend.一年中的这个时候 ,游艇市场很低靡。\r379.Sie haben keinen Umsatz in den letzten 3 Wochen gemacht.过去的 3 个星期里,您一笔销售业务也没有做成。\r380.Ich versuche,Ihnen zu helfen.我会尽量帮你。\r381.Wie funktioniert dieses Faxgeraet?这台传真机怎么用?\r382.Kommt der Service,um den Fotokopierer zu reparieren?修理人员来修复印机了吗? 383.Ich mache eine Pause und trinke einen Kaffee.我要休息一下,去喝点咖啡 . 384.Diese Rechnung muss sofort bezahlt werden.这些账单要马上付。\r385.Ich habe gehoerte,dass einige Mitarbeiter in diesem Quartal entlassen werden.我听说这个季度要裁一些人。\r386.Die Absaetze sind in diesen Monat gestiegen.这个月销售上升很快。\r387.Ich habe die Dokumente auf meinem Schreibtisch gelassen.我把文件放在桌子上了。 388.Wir muessen die Kosten in diesem Buero senken.我们办公室必须削减开支了。 389.Ist die Post von heute abgeschickt?邮件今天都寄出了吗?\r390.Kann jemand das Telefongespraechannehmen?有谁能去接一下电话吗?\r#### Lektion 27 Ander Bushaltestelle,Flughafen und Bahnhof 在车站,机场和火车站\r391.Wissen Sie, welcher Bus zum Stadion faehrt?您知道哪一路车去体育馆吗?\r392.Es muesste eine Bushaltestelle direkt am Stadion geben.在体育馆应该有一站的。 393.WissenSie,welcherBuszumTheaterfaehrt? 您知道哪一路车去剧院吗? 394.Essindungaehr3Haltestellenvonhier,vielleicht15Minuten.离这儿大约 3站,也许\r15 分钟。\r395.Unser Bus verspaetet sich.我们的车晚了。\r396.Wie viel kostet die Buskarte?车票多少钱?\r397.Darf ich Ihre Fahrkarte sehen,bitte?能看看您的车票吗?\r398.Wannlandet Ihr Flugzeug?您的航班什么时候着陆?\r399.Woist der Flugsteig fuer diesen Flug?这班飞机的登机口在哪?\r400.Das wird ein langer Flug werden.要飞很长时间。\r401.Die Ankunftszeit hat sich wegen des schlechten Wetters verzoegert.由于天气不好 ,到达时间延误了。\r402.Darf ich Ihren Pass sehen ?我能看看您的护照吗?\r403.Das ist der lezte Aufruf,in den Zug einzusteigen.那是最后一次上车通知了。 404.Ich hoffe,dass ich einen Fensterplatz erhalte.我希望我有靠窗口的座位。 405.Ich habe meine Fahrkarten ueber das Telefongekauft.我通过电话订的票。\r#### Lektion 28 Sport treiben 做体育运动\r406.Es ist wichtig fuer mich,gesund zu sein.身体健康对我很重要。 407.Meine Muskeln fuehlen sich taub an.我感觉肌肉麻木。 408.Ich bin erschoepft.我累坏了。\r409.Es ist abends zu voll im Gymnastikraum.晚上健身房里太拥挤了。\r410.Ich werde mich in der Sauna entspannen.我要去泡桑拿,放松一下。\r411.Wie viele Aufgaben muessen Sie noch erledigen?您还要再做多少锻炼?\r412.Wie haeufig treiben Sie Sport?您多久锻炼一次?\r413.Er ist Freuerwehrmann ,deshalb muss er haeufig trainieren.他是个消防队员,所以他\r必须经常锻炼。\r414.Ich muss eine kurze Pause machen.我必须休息一下。\r415.Als ich gelaufen bin ,habe ich meinen Knoechel verdreht.我跑步的时候扭到了脚踝。 416.Das war ein gutes Spiel ,das wir gemacht haben.我们的比赛很有趣。\r417.Er spielt zu rauh.他比赛时动作太粗野了。\r418.Wir koennen dieses Spiel noch gewinnen.我们还能赢得这场比赛。\r419.Dieser Schiedsrichter ist blind.那个裁判简直是瞎了眼。\r420.Werhat den Ball?谁拿到了球?\r#### Lektion 29 Inder Buchhandlung 在书店\r421.Ich suche nach Reisefuehrern.我在找旅游方面的书。\r422.Gibt es ein besonderes Buch,das Sie suchen?您在找什么特定的书吗?\r423.Ich wollte sehen,welche Buecher Sie ueber das Thema haben.我想看看你们有什么关于那方面的书。\r424.Dieses Buch ist im Augenblick bei kleinen Jungen sehr beliebt.现在这本书很受小男孩们欢迎。\r425.Dies ist ein Klassiker.这是本经典名著。\r426.Ich moechte dieses Buch umtauschen.我想换这本书。\r427,Koennen Sie dieses Buch als Geschenk einpacken?您能把这本书作为礼品包装一下\r吗?\r428. Wir rufen Sie an,wenn Ihr Buch angekommen ist.您的书到了,我们就会给您打电话。 429.Mein Freund hat mir geholfen,dieses Buch zu schreiben.我的朋友帮我写了这本书。 430.Ich habe gute Rezensionen ueber diesen Roman gelesen.我读过一些很不错的关于那\r部小说的评论。\r431.Es ist schwer,eingutes Buch ueber die chinesische Sprache zu finden.很难找到一本好的汉语方面的书。\r432.Haben Sie irgendwelche Strassenatlanten?你们这里有没有道路交通图册? 433.Warumist dieses Buch in der Psychologieabteilung?为什么这本书在心理学专区? 434.Haben Sie die Erstausgabe dieses Buches?你们有这本书的第一版吗?\r435.Es gibt hier einige fremdsprachige Zeitschriften.他们这里有一些国外杂志。\r#### Lektion 30 Zuhause 在家里\r436.Immer telefonierst du stundenlang mit deiner Mutter.你总是和您妈妈打电话,一打\r就是几个小时。\r437.Ich bin nicht angekleidet.我还没有穿好衣服。\r438.Es sieht dort wirklich unordentlich aus.那儿真是一团糟。\r439.Ich brauche Sie ,um mir einen Gefallen zu tun.我需要你再帮我一个忙。\r440.Du bist dran,den Rasen zu maehen.该轮到你除草了。\r441.Ich fuehre den Hund nach draussen.我把狗带出去遛一遛。\r442.Du musst den Fussboden heute Nachmittag wischen.你今天下午必须扫地。 443.Das Licht im Kuehlschrank ist kaputt.冰箱的灯坏了。\r444.Die Zahnpasta ist fast leer.牙膏快要用完了。\r445.Ich moechte mich nach der Arbeit nur entspannen und fernsehen.下班后我只想看电\r视,放松放松。\r446.Wasgibt es heute Abend zum Abendessen?今天晚餐吃什么?\r447.Ich moechte heute Abend nicht kochen.我今晚不想做饭。\r448.Ich habe einen langen Mittagsschlaf gehalten.我一个下午的大部分时间都在打盹。 449.Deine Eltern kommen morgen zum Abendessen.你父母明天来吃晚饭。\r450.Hast du unsere neuen Nachbarn von gegenueber getroffen?你遇到我们街对面的新\r邻居吗?\r#### Lektion 31 Schule und Ausbildung 学校与教育\r451.An welcher Hochschule sollte ich im Herbst studieren?秋季我该去哪一所大学?\r452.Meine Fachrichtung ist Geschichte.我学的是历史专业。\r453.Kannst du mir sagen,wo das Wohnheim ist?你能告诉我宿舍在哪儿吗?\r454.Ich besuche im diesem Semester ausserplanmaessige Veranstaltungen.这学期我选修\r了一些额外的课程。\r455.HastduProbleminChemie? 你在化学方面有困难吗?\r456.Ich mache mir keine Sorgen wegen dieses Tests我并不担心这次考试。.\r457.Die Preise der Lehrbuecher sind nach oben gestiegen.课本的价格上涨了。 458.Unsere Klasse hat eine Versammlung nach dem Mittagessen.午餐后我们班要开一个\r会。\r459.Der neue Professor ist sehr streng.新来的教授很严厉。\r460.Wollenwir gemeinsam fuer die Pruefung lernen?我们一起备考好吗? 461.Nachdem wir jetzt die Oberschule geschafft haben,was hast du vor?现在我们已经高\r中毕业了,你有什么打算?\r462.Mein Vater sagt,dass es fuer einen jungen Menschen die wichtigste Entscheidung ist,die richtige Hochschule zu waehlen. 我父亲说,选择一所合适的大学是一个年轻 人要作出的最重要的决定。\r463.Wie lange hast du diese Schule besucht?你在这所学校多久了?\r464.Ich habe keine Zimmeranweisung fuer das Wohnheim bekommen,deshalb muss ich\rherausfinden,in welchem Zimmer ich wohnen werde. 我没有收到宿舍房间安排的\r通知,所以我要去搞清楚我将住哪个房间。\r465.Hast du die Kurse aufgesucht,die du dieses Semester studieren moechtest?\r你有没有选定这个学期你要学哪些课程?\r#### Lektion 32 Job und Karriere 工作和事业\r466.Ich muss anfangen, mich nach einem Job umzusehen.我得开始找工作了。 467.Washalten Sie von Ihrem neuen Chef?您认为您的新老板如何?\r468.Mein Chef arbeitet zu hart.我的老板工作太努力了。\r469.Wird Ihr Job gut bezahlt?您的工资高吗?\r470.Wir muessen die Fortbildung in dieser Firma verbessern.我们需要改善公司的培训。 471.Das Interview heute Nachmittag war sehr anstrengend.今天下午面试很难。\r472.Ich habe den ganzen Tag am Telefonverbracht,um mit Kunden zu sprechen.我一天都\r在给客户打电话。\r473.Ich bin so beschaeftigt,dass ich an meinem Schreibtisch zu Mittag gegessen habe.\r我非常忙,午饭都是在办公桌上吃的。\r474.Ich mag meinen Job,weil ich viel reisen kann.我喜欢我的工作,因为我能够有机会经\r常旅行出差。\r475.Mein Bruder fliegt fuer eine Fluglinie.我哥哥在一家航空公司当飞行员。 476.Wasfuer einen Job moechten Sie machen?您想要什么样的工作?\r477.Ich hatte ein sehr gutes Interview fuer einen Job mit einer Werbefirma.我在一家广告公司面试很成功。\r478.Ich muesste einen Magister haben,um eine Anstellung in dieser Branche zu finden. 要想在那个领域找工作,我必须要有硕士文凭。\r479.Wird der Chef etwas dagegen haben,wenn ich einige persoenliche Dinge auf meinem Schreibtisch habe? 如果我在办公桌上放一些个人物品,老板会介意吗?\r480.Wie sieht die Firmenpolitik im Hinblick auf die Ferien aus?在休假方面 ,公司的政策市怎样的?\r#### Lektion33 Hobbys und Unterhaltung\r481.Ich lese in meiner Freizeit gern Buecher.我在空闲时间喜欢读书。\r482.Briefmarken zu sammeln ist eine entspannende Freizeitbeschaeftigung.集邮是一种令 人轻松的业余爱好。\r483.Mein Onkel geht gern angeln.我叔叔喜欢钓鱼。\r484.Er hat jeden Nachmittag Fussballtraining.他每天下午都有足球训练。\r485.Ich mag Bergwandern.我喜欢到山里远足。\r486.Sind Sie schon einmal Ski gefahren?您滑过雪吗?\r487.Wasmachen Sie gern in Ihrer Freizeit?您有什么业余爱好?\r488.Jeder muss sich nach der Arbeit entspannen.每个人都需要在工作后放松放松。 489.Lass uns Basketball in der Turnhalle spielen.我们去体育馆打篮球吧。\r490.Ich sammle antike Sachen.我喜欢收集古玩。\r491.Meine Leiblingsbeschaeftigung ist Bungeespringen.我最大的嗜好就是蹦极。 492.Wasmachen Sie gern in Ihrer Freizeit?您在空闲时间喜欢干些什么?\r493.Ich mag sehr gern Abenteuergeschichten.我真的很喜欢探险故事。\r494.Washalten Sie davon,Fussballkarten zu sammeln.您觉得收集足球卡片怎么样? 495.Ich hoffe,mei Sohn mag dieses Hobby ebenso gern wie Sie.我希望我的儿子像您一样\r喜欢这个业余爱好。\r#### Lektion 34 Einkaufen 购物\r496.Sie ist ausgegangen,um ein neues Kleid zu kaufen.她出去买新裙子了。\r497.Er musste ein Geschenk zum Landen zurueckbringen.他必须去把一件礼物归还给商店。\r498.Ich muss einen neuen Regenschirm kaufen.我需要买一把新雨伞。\r499.Die Marke,die ich mag,ist auserkauft.我喜欢的那个牌子已经卖完了。\r500.Haben Sie irgendwelche Schule in meiner Groesse?你们这里有合适我的尺码的鞋子\r吗?\r501.Es ist das beste Elektronikgeschaeft in der Stadt.这是本城最好的电子产品商店。 502.Ich hasse es,Samstag morgens einzukaufen.我讨厌在星期六的上午去购物。 503.Wokann ich hier Hundefutter finden?这家店的狗食放在哪儿?\r504.Wie viel kostet das?这个多少钱?\r505.Gibt es Rabatt auf diese Ware?这些东西打折吗?\r506.Finden Sie,dieses Kleid zu teuer?您认为这件衣服太贵了吗?\r507.Es ist recht formal und ich habe nicht viele Gelegenheiten,es anzuziehen.\r它很正式,我并不是有很多机会穿得很正式。\r508.Finden Sie,dass diese Jacke mir gut steht?您认为我穿这件毛衣会好看吗? 509.WelcheLaenge soll der Rock haben,den Sie kaufen moechten?您要买多长的裙子? 510.Ich schaue nach ,ob es irgendwelche in meinem Preisrahmen gibt.我得看看有没有东\r西在我的价格承受范围之内。\r#### Lektion 36 Wohnungssuche 寻购住房\r526.Es wird einfacher sein,ein Haus zu erhalten,nachdem wir verheirated sind.我们结婚后会更容易弄到房子。\r527.Wie viel ist dieses Haus wert?这房子值多少钱?\r528.An diesem Haus muss nur einiges repariert werden.这房子只需要稍稍维修一下。 529.Ich liebe die Nachbarschaft drumherum.我喜欢这儿的周围邻里。\r530.Wir brauchen ein Haus mit einer Garage fuer zwei Autos.我们需要一个能放两辆车的\r车库的房子。\r531.Wir sollten die vordere Tuer reparieren ,bevor wir das Haus verkaufen.我们应该在卖掉房子之前把前面修一下。\r532.Ich rufe sofort das Immobilienbuero an.我现在就给那家房地产公司打电话。 533.Sollen wir ein Haus mieten oder kaufen?我们应该租房还是买房?\r534.Ich mag dieses Dach.我喜欢那屋顶的样子。\r535.Hat dieses Haus einen Keller?这房子有地窖吗?\r536.Ich habe einige moegliche Haeuser in den Verkaufsanzeigender Zeitung gefunden.\r我在报纸的房屋出售栏中找到了几个可能的选择。\r537.Die Pachtzeit unserer Wohnung ist fast abgelaufen.我们的房屋租期就要到了。 538.Ich bin sicher,dass wir eine Wohnung finden,bevor die Pachtzeit auslaeuft.我相信我们能在租期满之前找到房子的。\r539.Ich hoffe,dass wir bald ein neues Haus finden.我希望我们能尽快找到新房子。 540.Der Verkaeufer ist bereits ausgezogen,deshalb koennen Sie einziehen,sobald am\rWochenende der Vertrag unterschrieben wird.卖主已经搬出去了,所以您只要在这个周末签完契约就可以搬进去了。\r#### Lektion 37 Im Internet surfen\r541.Ich muss einige Lektionen fuer die Vorlessung renterladen.我需要为课堂下载一些课 程。\r542.Meine Verbindung ist zu langsam.我的连接速度太慢了。 543.Ich werde in einigen Minuten vom Netz gehen.我马上就断线。\r544.Dieses Internet-Cafe ist zu teuer.这个网吧太贵了。\r545.Ich muss zu einer Nachrichten-Webseite gehen.我需要上一个新闻网站。\r546.Einer meiner Freunde hat seine eigene Webseite.我的一个朋友有自己的网站。 547.Wie ist Ihr E-mail Adresse?您的电子邮箱地址是什么?\r548.Haben Sie E-mail?您有电子邮箱吗?\r549.Mein Server hat heute Morgen Probleme.我的服务器今天早上出了问题。\r550.Es ist schwierig,in China auf einige auslandische Webseiten zu kommen.在中国很难找到一些国外网站。\r551.Sie koennen eine Menge Informationen ueber das Internet finden,die kostenlos sind. 您可以在网上找到很多免费的信息。\r552.Wasmachen Sie im Internet ,das so lange dauert?您上网这么久,都干些什么了? 553.Manchmal mag ich einfach nur im Netz surfen.有时,我就是喜欢在网上冲浪。 554.Es gibt viele Sachen im Internet,die fuer einen Jungen in deinem Alter nicht geeignet sind. 在网上有许多东西是不适合你这种年龄的男孩看的。\r555.Nun,Internet gibt es fast auf der ganzen Welt.Man benutzt es fuer das Geschaeft, die Ausbildung und einfach nur aus Spass.因特网逐渐在全世界普及了 。人们用它来做生 意,获得教育,还有娱乐。\r#### Lektion 38 Sport 体育运动\r556.Jeder schaut sich im Augenblick die Fussballweltmeistschaft an.现在每个人都在看世\r界杯。\r557.Ich bin muede nach dem Spiel heute Nachmittag.打完今天下午的比赛,我累了。\r558.Der Schiedsrichter haette ein Foul geben muessen.裁判应该判犯规。\r559.Schiess den Ball zu mir herueber.把球传给我。\r560.Ich muss schneller laufen.我必须跑快些。\r561.Glauben Sie ,dass wir noch gewinnen koennen?您认为我们还能赢吗?\r562.Diese Mannschaft hat die ganze Spielzeit ueber hart trainiert.这个队整个赛季都在努力训练。\r563.Ich habe mir im letzten Spiel meinen Knoechel verletzt.在最后一场比赛中 ,我的脚踝\r受伤了。\r564.Haben Sie keine Angst,dass dieser TrainerSie aus der Mannschaft nehmen wird?\r您难道不担心教练会把您从对中除名吗?\r565.Ich weiss nicht,ob wir gewinnen koennen,wenn wir Sie verlieren.真不知道我们队少\r了您还能不能赢比赛。\r566.Wasglauben Sie,welche Chancen haben wir,dieMeisterschaft zu gewinnen?您认为我\r们拿冠军的机会如何?\r567.Ich bevorzuge Sportarten,in denen man im Teamarbeiten muss anstatt zu kaempfen. 我喜欢那些人们需要合作而不是互相殴打的体育项目。\r568.Boxer trainieren sehr hart fuer viele Jahre,um an den Olympischen Spielen teilzunehmen. 拳击手要经过多年的训练才能参加奥运会。\r569.In einer Mannschaftsportart kann eine Person nicht allein den ganzen Verdienst haben. 在团体比赛中,一个人不能独享所有的功劳。 570.Wasist dein Lieblingssport?你最喜欢什么运动项目?\r#### Lektion 39 Feiertage und Ferien 节假日\r571.Lass uns an den Strand fahren am langen Wochenende.我们去海滩度过这个悠长的\r周末吧。\r572.In meiner Schule gibt es 3 Woche Winterferien.我的学校寒假放 3 个星期假。 573.Wasmachst du im Sommer?你暑假准备干些什么?\r574.Ich bin in den Ferien nach Thailand gefahren.我去了泰国度假。\r575.Mein Liebingsfeiertag ist Weihnachten.我最喜欢的节日时圣诞节。\r576.Meine ganze Familie faehrt zusammen in die Ferien.我全家人一起去度假。 577.Wir treffen uns zu Weihnachten im Haus meiner Grosseltern.圣诞节我们在祖父母家\r团聚。\r578.Ich koennte dieses Jahr wirklich Ferien brauchen.今年我真的很需要放一放假。 579.Flugkickets kosten waehrend der Feiertag mehr.节假日飞机票涨价。\r580.Wir koennen uns im Augenblick keinen Urlaub leisten.我们现在没有钱度假。 581.Wir haben am Feiertag gegrillt.这次放假我们去烧烤了。\r582.Wir haben eine Familietradition,uns bei meinem Grossvater zum Abendessen zu\rtreffen. 我们家的传统式在我祖父家聚餐。\r583.Ich glaube,ich sollte besser den Weihnachtsschmuck herausholen.我想我最好把圣诞\r节装饰物找出来。\r584.Einer meiner schoensten Augenblicke zu Weihnachten ist es,die ueberraschten Gesichter der Kinder zu sehen,wenn sie am Weihnachtsmorgen ihre Geschenke unter dem Weihnachtsbaum auspacken.\r在圣诞节早上,看到孩子们在圣诞树下打开礼物时那充满惊喜地脸 ,是在圣诞节我 最喜欢看到的了。\r585.Freust du dich nicht schon auf die kommenden Sommerferien。暑假就快到了,你难 道不高兴吗?\r#### Lektion 40 Reisen 旅行\r586.Warumkann ich keine Ruechfahrkarten fuer den Zug erhalten?我为什么不能买这趟\r列车的回程车票?\r587.Ich habe unseren Flug bereits fuer naechsten Monat gebucht.我已经定了我们下个月\r的机票。\r588.Meine Brieftasche wurde in Mexiko gestohlen.我的钱包在墨西哥被偷了。\r589.Ich brauche einen neuen Pass.我需要一个新的护照。\r590.Sprechen Sie Englisch?您说英语吗?\r591.Er hat zu viel Gepaeck fuer die Reise mitgenommen.这次旅行他带的行李太多了。 592.Kennen Sie den Weg zum Flughafen?您知道去机场的路吗?\r593.Ich habe einige tolle Fotos von meiner Reise nach Aegypten.我在埃及旅行时拍了一\r些很好的照片。\r594.Ich glaube nicht,dass sie noch Karten fuer diesen Bus haben.我想他们没有更多的这\r趟公共汽车的票了。\r595.Die Lage ist im Augenblick nicht so sicher,umdiesen Land zu besuchen.现在去那个国家不安全。\r596.Sind Sie als Touristin Frankreich?您是在法国旅行?\r597.Frankreich ist auf der ganzen Welt fuer sein Essen beruehmt.Haben Sie irgendetwas probiert?\r法国美食全世界闻名。您有没有尝过?\r598.Wie lange werden Sie Frankreich besuchen?您打算在法国游玩多久?\r599.Sie koennen Frankreich nicht besuchen,ohne seine beruehmteste Stadt zu besichtigen.来法国您不能不去这个国家最著名的城市看看。\r600.Ich hoffe,dass Sie Ihren Aufenthalt geniessen.我希望您在这里过得愉快。\r#### Lektion 41 Filme anschauen 电影\r601.Dieser Film ist im Augenblick auf dem ersten Platz im Land .现在那部电影全国排名第一。\r602.Ich glaube,dass dieser Film der beste dieses Schauspielers ist.我认为这部电影是那个演员最好的代表作。\r603.Ich war zu aengstlich,mir einige Szenen anzuschauen.我太害怕了,有些镜头不敢看 。 604.Ich denke,dass die Spezialeffekte unglaublich waren.我认为这些特技效果简直令人\r难以置信。\r605.Der Film war ein bisschen anders als das Buch,auf dem er basiert.这部电影与原著有些不同。\r606.Ich glaube,dass kleine Kinder diesen Film nicht sehen sollten.我认为小孩子不应该看这部电影。\r607.Mein Onkel mag lieber aeltere Filme.我叔叔更喜欢老电影。\r608.Mein Lehrer ist sehr intelligent,aber er mag einfache Aktion Filme.我的老师很聪明,但是他喜欢情节简单的动作片。\r609.Der Regisseur ist sehr jung,aber bereits beruehmt.这个导演很年轻,但是已经出名\r了。\r610.Auslaendische Filme sind fuer meinen Geschmack zu merkwuerdig.我觉得外国电影\r太怪异了。\r611.WelcheArt Film moegen Sie gerne anschauen?您喜欢看什么样的电影? 612.Moegen Sie Science-Fiction-Filme? 您喜欢科幻电影吗? 613.Warumschauen wir nicht in der Zeitung nach,wann die Filme anfangen?\r为什么不查看一下报纸,那里面有电影放映时间预告。\r614.Warumwuerden Sie gern einen Film sehen wollen,ueber den Sie nichts wissen?\r您怎么会喜欢看一部您一点都不了解的电影呢?\r#### Lektion 44 Musik und Konzerte 音乐和音乐会\r646.Ich habe Karten fuer das Konzert in der naechsten Woche.我有下个星期音乐会的票 。 647.Ich habe dieses Stueck schon oft gehoert.这首乐曲我听过很多次了。\r648.Der Violinist ist sehr begabt.这个小提琴手很有天赋。\r649.Ich ziehe klassische Musik der Rockmusik vor.相对摇滚乐,我更喜欢古典音乐。 650.Er spielt Guitarre in einer lokalen Band.他在当地一个乐队里弹吉他。\r651.Ich wuenschte,ich koennte ein Musikinstrument spielen.我希望我能演奏一样乐器。 652.Die Karten fuer das Opernkonzert sind ausverkauft.演奏会的票都卖完了。\r653.Mein Sohn nimmt Klavierstunden.我的儿子在学钢琴。\r654.Musik ist eine universale Sprache.音乐是无国界的语言。\r655.Ich singe nur,unterder Dusche.我只是在洗澡的时候才唱歌。\r656.Ich mache eine Party und brauche etwas Tanzmusik.我打算开个派对,因此需要一些\r舞曲。\r657.Mein Lieblingssaenger hat gerade ein neues Album herausgebracht.我最喜欢的歌手又出了新唱片了。\r658.Sie hat in fast drei Jahren nichts Neues herausgebracht.她在 3 年内几乎没有出过任\r何唱片了。\r659.Haben Sie Karten fuer das Konzert erhalten,wovon Sie mir erzaehlt haben?\r您跟我说的那场音乐会的票,您有没有买到?\r660.Ich suche nach einem Album,aber ich fuerchte,dass ich mich an den Namen nicht erinnern kann. 我在找一张唱片,但恐怕我已经记不起它的名字了。\r#### Lektion 45 Ehe 婚姻\r661.Wir sind seit vierzehn Jahre verheiratet.我们结婚有 14 年了。\r662.Sind Sie schon verheiratet?您已婚了吗?\r663.Sie haben letztes Jahr geheiratet.他们去年结婚的。\r664.Wir wurden in einer Kirche getraut.我们在教堂结婚的。\r665.Wir haben eine kleine Hochzeitsfeier gehabt.我们举行了一个小小的婚礼。 666.Naechste Woche ist unser zwanzigster Hochzeitstag.下周是我们结婚 20 周年的纪念\r日。\r667.Wir haben alle unsere Freunde zur Hochzeit eingeladen.我们邀请了我们所有的朋友\r来参加婚礼。\r668.Es ist schoen verheiratet zu sein.结了婚真好。\r669.Meine Frau kommt aus Chicago.我的妻子是芝加哥人。\r670.Wir moechten in Zukunft keine Kinder haben.我们不想有孩子。\r671.Ich kann mir nicht vorstellen,den Rest meines Lebens mit jemand anderem zu\rverbringen. 我无法想象自己与其他人共度此生。\r672.Nicht viele Leute koennen von sich sagen,dass sie ihre goldene Hochzeit schon erlebt haetten. 没有多少人可以说,他们已度过了金婚纪念日。\r673.Es gibt nichts Traurrigeresals eine bittere Scheidung.痛苦的离婚是最令人伤心的。 674.Es war auch gut,dass sie sich leicht einigen konnten,wie das eheliche Eigentum\raufgeteilt werden sollte.\r他们很容易就对婚姻财产的公平分割达成了一致,那也是好的。\r675.Dennoch glaube ich,dass es sehr weh tut,wenn eine Ehe zerbricht.\r不过,我仍认为一段婚姻破裂的时候是很让人心碎的。\r#### Lektion46 Verabredungen 约会\r676.Sehen die beiden sich noch regelmaessig?那一对现在还约会吗?\r677.Moechten Sie ein mal mit mir zusammen zu Abend essen?您想不想什么时候和我出\r去吃个饭?\r678.Entschudigung,aber ich habe einen anderen Termin.对不起,我有约了。 679.Haben Sie meine Freundin kennengelernt?您见过我的女朋友吗?\r680.In ihrer Bezieheung gibt es im Augenblick einige Probleme.他们的关系现在出现了些\r问题。\r681.Ich moechte mich im Augenblick ni´cht auf eine Person gestlegen.我现在还不想对一个人做出承诺。\r682.Ich glaube,dass wir andere Leute treffen sollten.我想我妈应该和其他人约会。 683.Willst du dich von mir trennen?你要和我分手吗 ?\r684.Ich bin im Augenblick nicht an einem Treffeninteressiert.我现在对约会没兴趣。 685.Wir sollten einfach Freunde sein.我们应该只做朋友。\r686.Darf ich zu einer Verabredunggehen?我能出去约会吗?\r687.Ich freue mich wirklich,dass Sie mich einladen.很高兴您邀请我出来。\r688.Ich bin ein bisschen aufgeregt,da das unser erstes Treffenist.我有点紧张,这是我们的第一次约会。\r689.Warum lassen Sie mich nicht zahlen,da ´Sie die Eintrittskarten fuer den Tany gekauft haben? 您已经买了舞会入场券了,不如让我来结账吧 ?\r690.Ich moechte wissen,ob Sie yur Party maechste Woche eingeladen wurden. 我想知道有没有人邀请你参加下周的舞会。\r#### Lektion 47 Besichtigungen 观光游览\r691.Haben Sie schon mal den Grand Canyon gesehen?您见过大峡谷吗?\r692.Die Aussicht von hier oben ist wundervoll.从这儿看过去,景色很美丽。\r693.Lassen Sie uns gehen und den Sonnenuntergang angucken.我们去看日落吧。\r694.Es ist schwer,beidiesem Licht ein Bild zu erhalten.这种光线下很难照相。\r695.Die Menschenmassen verderben die Landschaft.拥挤的人群破坏了景致。\r696.Die gepflasterte Strasse hinauf zum Berg stoert das Naturbild.这条一直铺到山顶的路破坏了自然的感觉。\r697.Ich moechte die Wueste in Westchina sehen.我想去看看中国西部的沙漠。\r698.Er hat gesagt,dass die Kueste beim Sonnenausfgang wunderschoen war.他说日出时这\r个海岸很美丽。\r699.Der Zug faehrt durch wunderschoene Gegenden.火车经过一些美丽的乡村。 700.Der Winter ist die beste Zeit dorthin zu reisen,weil die Schneelandschaft so schoen ist.冬天是最好的旅游季节,因为雪景很美丽。\r701.Wosollen wir dieses Jahr in den Ferien hinfahren?我们今年去哪儿度假?\r702.Ich finde auch,dass Disney World ein guter Platz fuer Kinder ist und sie eine Menge Spass haben wuerden. 我同意迪士尼乐园是孩子们的天堂,在那儿他们会玩得很开心。\r703.Es ist wichtig fuer die Kinder,einesolch wichtige deutsche Landschaft zu sehen. 让孩子们看看这个重要的德国景观,这很重要。\r704.Es ist sehr beliebt und sie machen nur eine begrenzte Anzahl von Tourenpro Tag. 那个地方很受欢迎,每天只允许一定数量的参观者入内。\r705.Ein Teil der Besichtigung besteht darin,Gerichte aus unterschiedlich Gegenden zu probieren. 旅游观光 的一部分就算尝尝不同地方的没尝过的风味小吃。\r#### Lektion48 EinPicknickmachen 野餐\r706.Hast du genug Sandwichs fuer das Picknick eingepackt?这次野餐你带够了三明治\r吗?\r707.Wir muessen einen Platz weit weg von den Ameisen finden. 我们得找一个远离蚂蚁\r的地方。\r708.Es ist wunderbares Wetter fuer ein Picknick.这是野餐的好天气。\r709.Lass uns auf diese Bank dort hinsetzen.我们坐到那边的板凳上去吧。\r710.An diesem Platz sind nicht zuviel Leute,um hier zu essen.这个地方不是太拥挤,可以\r在这里吃。\r711.Lass uns beim See essen.我们去湖边吃东西吧。\r712.Ein Picknick kann eine romantische Verabredungsein.野餐可以是浪漫的约会。 713.Ich habe schoene Erinnerungen an Picknicks mit meinen Eltern.和父母一起去野炊给\r我留下了美好的回忆。\r714.Achten Sie darauf,dass Sie all Ihren Abfall mitnehmen,wenn Sie das Essen beebdet haben.\r你们吃完以后记得把所有的垃圾都带走。\r715.Gibt es noch ein Bier in der Kuehltasche?冰箱里还有啤酒吗?\r716.Wir wissen nicht,wie viel wir zu essen kaufen sollen,bis wir entscheiden,wie viele Leute kommen sollen. 只有先决定要来的人数,我们才会知道要买多少食物。\r717.Wir sollten Pappteller und Plastikbesteck nehmen,dann muessen wir kein Geschirr abwaschen. 我们应该买纸碟和塑料用具,那我们就不用洗碟子了。\r718.Es ist so ein schoener Tag fuer ein Picknick.真是野餐的好天气。 719.Ich mag sehr gern selbstgemachtes Essen,nicht das vom Schnellimbiss. 我非常喜欢家庭自制的食品,而不是快餐店那种。\r720.Das Wetter ist wirklich schoen und wir sollten ein wenig spazieren gehen,um das Essen zu verdauen. 天气这么好,我们出去走走,消化一下我们吃的东西。\n","date":"2016-10-22T00:00:00Z","permalink":"https://blog.iostao.com/2016/10/deutsch-900-two/","title":"Deutsch 900 Sätze 2"},{"content":"Lektion 1 Gruesse und Vorstellung.打招呼,介绍 1.Hallo. 您好。 2.Guten Morgen.早上好。 3.Wie geht\u0026quot;s Ihnen?您好吗?\n4.Nicht schlecht.还不错。 5.Ich freue mich,Sie kennen zu lernen.很高兴认识您。 6.Ich freue mich,Sie wieder zu sehen.很高兴再次见到您。\r7.Ich bin ueberrascht,Sie hier zu sehen.想不到在这见到您。\r8.Wastun Sie hier?您在这里干什么?\r9.Hallo.Ich bin Matin.嗨,我是马丁。\r10.Mein Name ist Robert.我的名字是罗伯特。\r11.Sie koennen mich Berg nennen.您可以叫我贝格。\r12.Haben wir uns frueher schon mal gesehen?我们以前见过面吗? 13.Kenne ich Sie?我认识您吗?\r14.Darf ich mich vorstellen?让我介绍一下自己。\r15.Ich moechte Sie meinem Chef vorstellen.我想把您介绍给我的老板认识 ## Lektion 2 Dankbarkeit und Entschuldigen 感激和道歉 16.Danke.谢谢。\r17..Keine Ursache.不用客气。\r18.Dank fuer Ihre Hilfe.感谢您的帮助。\r19.Sie wissen nicht,was das fuer mich bedeutet.您不知道这(个忙)对我有多重要。 20.Sie sind sehr nett.您太好了。 21.Danke fuer alles,was Sie getan haben.感谢您为我做的一切。\n22.Entschuldigung. 对不起。\r23.Entschldigen Sie bitte die Kritik.对不起,我批评了您。 24.Macht nicht.没关系。\r25.Ich bedaure wirklich,letzte Woche nicht ins Kino gewesen zu sein.我真的很后悔上个星 期没去看电影。\r26.Entschuldigung,dass ich heute zu spaet in der Vorlesung war.对不起,我今天上课迟到 了。\r27.Sie koenen mich fuer diese Sache tadeln.这都怪我。 28.Koennen Sie mir verzeihen?您能原谅我吗?\r29.Nehmen Sie bitte meine Entschuldigung an.请接收我的道歉。 30.Das ist mein Fehler.这都是我的错。 ## Lektion 3 Hoffnungen und Wuensche 希望与愿望 31.Ich hoffe,dass wir den Wettbewerb dieses Jahr gewinnen.我希望我们今年的比赛能\r赢。\r32.Ich hoffe es auch.我也希望如此。\r33.Waswuenschen Sie sich zu Weihnachten dieses Jahr?今年圣诞节您想要什么(礼物)? 34.Ich moechte Arzt warden.我想做个医生。\r35.Ich glaube ,dass die Situation sich verbessern wird.我相信事情会好转的。\r36.Ich moechte jetzt wirklich etwas trinken.我现在很想喝点东西。\r37.Ich hoffe, dass Sie sich besser fuelen.我希望您感激好些。\r38.Er ist die groesste Hoffnung fuer die Mannschaft.他是全队最大的希望。 39.Ich moechte dieses Auto haben.我想拥有那辆车。\r40.Ich moechte allein sein.我想单独呆一会。\r41.Ich bin sicher ,dass Sie es verdienen.我相信这是您应得的。\r42.Ich bin sicher,dassSie Erfolg haben werden.我相信您一定会成功的。 43.Viel Glueck.祝您好运。\r44.Ich wuensche Ihnen alles Gute.给您我最好的祝愿。\r45.Das ist sher gut. 太好了。 ## Lektion 4 VorschlagundMeinungen 建议和意见\r46.Ich schlage vor,dassSie einen Beruf erlernen,der etwas mit Tiere zu tun hat.我建议您考虑学习与动物有关的职业。\r47.Ich rate Ihnen,die Sachen zu gniessen.我建议您去享受那些东西。\r48..Ich werde an ihn denken.我会考虑他的。\r49.Darf ich Ihnen einige Ratschlaege geben?我能给您一些建议吗?\r50.Wasschlagen Sie vor?您有什么建议?\r51.Ich schlage vor,dassSie tun,was er sagt.我建议您按照他说的去做。\r52.Ist das Ihre Vorschlag?那是您的建议吗?\r53.Ich wuerde empfehlen,dass Sie versuchen,sich zu entspannen. 我建议您试着放松一\r下。\r54.Darf ich einen Vorschlag machen?我能提个建议吗 ?\r55.Lassen Sie mich Ihnen einige Vorschlaege machen.让我给您点建议。 56.Es sollte vorboten werden.它应该被禁止。\r57.Ich bin nicht gluecklich mit unserem neuen Chef.我不喜欢我们的新老板。 58.Ich glaube nicht,dass die Schulen so gut sind ,wie sie sich darstellen.我认为这些学校不 像他们自己说的那样好。\r59..Ich glaube ,dass wir einen neuen Praesidenten brauchen.我认为我们需要一位新总 裁。\r60.Ich glaube,dass wir eine Pause machen sollten.我认为我们应该休息一下。\r## Lektion 5 Einladung 邀请 61.Wir muessen uns trennen.我们该见下面了。\r62.Moechten Sie kommen?您想来吗?\r63.Danke fuer die Einladung.谢谢您的邀请。\r64.Ich moechte Sie zum Kaffee einladen.我想邀请您喝咖啡。\r65.Ich moechte Sie zu einer Party einladen.我想邀请您参加一个聚会。\r66.Moechten Sie zu Mittag essen?您想吃午饭吗?\r67.Warumkommen Sie nicht spaeter vorbei?您为什么不过会儿再来 ?\r68.Haben Sie heute Abend Zeit?您今晚有空吗?\r69.Wasmachen Sie spaeter?您待会儿做什么?\r70.Lassen Sie uns spaeter treffen.回头见。\r71.Kommen Sie und besuchen Sie mich einmal.有空来看我。\r72.Rufen Sie mich an,wenn Sie naechstes Mal in der Stadt sind.您下次再来的时候给我打\r个电话。\r73.Ich moechte Sie wieder sehen.我希望再见到您。\r74.Moechten Sie einmal mit mir zu Abend essen?什么时候有空(和我)吃晚饭吗? 75.Wannkann ich Sie wieder sehen?我什么时候能再见到您?\nLektion 6 Aufforderungen 要求\r76.Ich bitte sie ,ihre Musik leiser zu drehen.我请问她把音乐关小些。\r77.Es ist eine kleine Bitte.这是个很小的请求。\r78.Sie muss es leiser drehen.她必须关小些。\r79.Ich bitte Sie nur,dassSie ihn in Ihrem Hof lassen.我只是要求您让他呆在您的院子里。 80.Ich moechte Ihren Computer ausleihen.我需要借用一下您的电脑。\r81.Kann ich das Buch anschauen?我可以看看那本书吗?\r82.Koennten Sie ein bisschen hinueberruecken?您能移动一下吗?\r83.Sie werden aufgefordert,naechste Woche bei Gericht zu erscheinen.要求您下星期到\r庭。\r84.Mein Antrag auf eine Gehaltserhoehung wurde zurueckgewiesen.我加薪的请求被拒绝\r了。\r85.Darf ich eine kleine Bitte aeussern?我能提个小小的请求吗?\r86.Das ist eine ziemlich grosse Bitte.那是一个很大的请求。\r87.Warumbitten sie nicht um etwas Hilfe bei Ihrer Arbeit?您为什么不要求一些工作上的\r帮助呢?\r88.Das ist eines der meist verlangten Lieder im Radio.这是收音机里点唱率最高的歌曲之\r一。\r89.Koennten Sie mir bei dieser Kiste helfen?您能帮我搬搬这箱子吗? 90.Koennen Sie ein bisschen ruhiger sein?您能安静一点吗?\r## Lektion 7 PlaeneundEntscheidungen 计划和决定 91.Ich werde darüber nachdenken.我会考虑的。\r92.Wir koennen für eine Weile beide mein Auto benutzen.一段时间里我们只得共用我的 车了。\r93.Wir müssen beginnen,für Taubes Hochschulausbildung zu sparen.我们得开始为掏贝积 攒大学资金。\r94.Wissen Sie schon,was Sie nach dem Examen tun werden?你知道你毕业后做什么吗? 95.Ich habe mich noch nicht entschieden.我还没决定好。\r96.Ich informiere Sie darüber ,wenn ich mich entschieden habe.我会让您知道我的决定。 97.Ich muss eine schwierige Wahl treffen.我必须做一个困难的决定。\r98.Entscheiden Sie sich schnell.请您迅速决定。\r99.Ich hatte das nicht vermutet.我没有意料到那个。\r100.Wie haben Sie vor,ausdieser Misere herauszukommen?面对这一团糟,您打算怎么\r办?\r101.Das Desaster war ein Resultat der schlechten Planung.这次灾难的发生是由于计划不\r周导致的。\r102.Ich plane,mit dem nächsten Zug hier rausyufahren.我打算坐下一班火车离开这\r里。\r103.Ich plane ,ein neues Haus zu kaufen.我打算买一套新房子。 104.Ich hatte nur die besten Absichten.我是出于好意。 105.Alles geht entsprechend nach Plan.一切都照计划进行着。 ## Lektion 8 Vereinbarung und Widerspruch 同意和不同意 106.Ich glaube nicht ,dass mit unseren Steuern irgendetwas Gutes gemacht wird.我不认为税收对我们有什么好处。 107.Ich habe eine vollstaendig andere Meinung.我完全不同意。 108.Vielleicht haben Sie recht.也许您是对的。\r109.Ich glaube ,dass das eine gute Idee ist.我想那是个好主意。\r110.Ich bin erfreut ,dass wir die gleiche Meinung haben.很高兴我们的看法一致。\r111.Ich bin nicht der gleichen Meinung wie Sie.我和您的看法不同。\r112.Ich bin in dieser Sache nicht Ihrer Meinung.在这件事情上我不同意您的看法。 113.Das ist es ,was ich gedacht habe.那就是我的想法。\r114.Sie haben voellig recht.您对极了。\r115.Das ist sicher.那是肯定的。\r116.Ich würde sagen,dass das zutreffend ist.我肯定那是对的。\r117.Stimmen Sie nicht zu?难道您不同意?\r118.Ich stimme dem zu.我同意那一点。\r119.Ich stimme mit Ihnen darin überein.在这一点上我同意您的看法。\r120.Ich bin nicht sicher ,ob ich mit Ihnen übereinstimme.我不能肯定是否同意您的意见 。\r## Lektion 9 KomplimenteundLob 称赞和表扬\r121.Sie haben Ihre Arbeit gut gemacht.您干得漂亮。\r122.Das war zum groezlig;en Teil Glück.那大部分靠运气。\r123.Sie haben wirklich einen guten Geschmack.您真的很有品位。 124.Ich beneide Sie sehr.我真羡慕您。\r125.Das ist ein schoenes Auto,das Sie dort haben.您那辆车真漂亮。 126.Sie sehen gut aus.您看起来很不错。 127.Dieses Hemd steht Ihnen wirklich.那件衬衫真的很适合您。\n128.Sie haben sehr gute Manieren.您很有风度。\r129.Ich begrüsse Ihre Bemühungen.我对您的努力表示敬佩。 130.Sie sind der Beste im Geschaeft.您是行业里最好的。 131.Sie sind der Neid der ganzen Stadt.您是众人羡慕的焦点。 132.Rot steht Ihnen gut.您穿红色很好看。\r133.Sie haben eine Arbeit für dieses Haus erledigt.这房子您打理得不错。 134.Machen Sie weiter so.干得好,保持下去。\r135.Ich liebe es ,wie Sie mich zum Lachen bringen.我喜欢你逗我笑。\r## Lektion 10 Warnungen und Vorbote 警告和禁止\r136.Es gibt ein Schild ausserhalb des Tores,daraufsteht \u0026rsquo;\u0026rsquo; ZUTRITT VERBOTEN\u0026rsquo;\u0026rsquo;.门外有牌子写着“禁止入内”。\r137.Nicht hier.这里不行。\r138.Ich glaube nicht,dass Sie das tun sollten.我认为您不应该那样做。 139.Sie koenen mich nicht vom Rauchen abhalten.他们不能阻止我抽烟。 140.Sie koennen dort nicht hingehen.您不能去那儿。\r141.Das ist verboten.那是被禁止的。\r142.Ich warne Sie.我在警告您。\r143.Niemand darf dorthin gehen.谁也不许进那儿。\r144.Es ist verboten,das zu tun.不允许那样做。\r145.RACUCHEN VORBOTEN.禁止吸烟。\r146.EINTRITT VERBOTEN. 禁止入内。 147.KEIN ZUTRITT FUER UNBEFUGTE.未经许可不得入内。\n148.BETRETEN DER RASENFLAECHE VERBOTEN.请勿践踏草地。\n149.ZUTRITT VERBOTEN.不得入内。\r150.KEINE HAUSTIERE ERLAUBT.宠物不得入内。 ## Lektion 11 Ueber Leute und Gegenstaende reden 谈论人和物 151.Wasdenken Sie ueber den neuen Chef?您认为新老板怎么样? 152.Meinen Sie Herrn Li?您指李先生吗?\r153.Sein Onkel ist sehr ungewoehnlich.他的叔叔非常不同寻常。 154.Mein Mitarbeiter ist zu laut.我的同事嗓门太大了。\r155.Das neue Maedchen erledigt ueberhaupt keine Arbeit.那个新来的女孩什么工作也不 做。\r156.Seine Eltern sind zu streng zu ihm.他的父母对他很严格。\r157.John ist der beste Spieler ,den wir haben.约翰是我们最好的队员。 158.Halder kommt aus Kanada.哈尔德来自加拿大。\r159.Es ist nicht schwer.这个不重。\r160.Die Waender sind zu dunkel.墙的颜色太暗了。\r161.Der Fussboden ist sehr sauber.地板很干净。\r162.Dieser Tisch ist nicht stabil. 这桌子不稳。\r163.Es gibt Flecken auf meinem neuen Hemd.我的新衬衫上污渍。 164.Ich habe dieses Spielzeug in Beijing gekauft.这玩具是我在北京买的。 165.Dieses Buch ist auf franzoesisch geschrieben.这本书是用法语写的。\nLektion 12 Fragen nach Alter und Namen 166.Das ist Jean.这是吉恩。\r167.Ich bin Till.我是蒂尔。\r168.Wie ist Ihr Name ?您叫什么名字?\r169.Und wie alt sind Sie ,Herrn Fichte?您多大了,费希特先生?\r170.Ich bin 38.我 38 岁了。\r171.Ich werde im Mai.29.我 5 月份就 29 岁了。\r172.Naechsten Monat werde ich 40.我下个月满 40 岁。\r173.Ich habe Ihrem Namen vergessen.我没记住您的名字。\r174.Wassagten Sie ,wie alt Sie sind?您说您多大了?\r175.Man nennt mich Benni.人们叫我本尼。\r176.Wannhaben Sie die Hochschule beendet?您什么时候读完大学的?\r177.Waswar noch mal Ihr Name ?您说您叫什么名字?\r178.Benutzen Sie Ihren Vornamen in der Arbeit ?早工作中,您是使用您的名吗? 179.Mein Name bedeutet \u0026ldquo;Freude\u0026rdquo; auf Spanisch.我的名字在西班牙语中的意思是 “快\r乐”。\r180.Ich wurde nach meinem Grossvater benannt.我的名字是跟着我祖父取的。\r## Lektion13 Ueber die Zeit und das Datum sprechen.谈论时间和日期 181.Wie spaet ist es?现在几点了?\r182.Es ist ungefaehrl halb 3.差不多 2:30 了。\r183.Wannwerden Sie zurueck sein?您什么时候回来?\r184.Meine letzte Vorlesung ist um 3:30 zu Ende.我最后一节课在 3:30 结束。\r185.Wir haben nur eine Stunde,die Arbeit fertig zu machen.我们只剩下一个小时来工作 了。 186.Ich habe hier drei Stunden lang gewartet.我在这等了 3 小时。\r187.Die Zeit vergeht schnell,wenn man Spass hat.开心的时候,时间过得很快。\r188.Es ist fünfzehn Minuten vor neun.现在是 9 点差一刻。\r189.Das Büro oeffnet um 8 morgens.办公室早上 8 点钟开门。\r190.WelchesDatum ist morgen?明天是几号?\r191.Morgen ist der 25.Novenber.明天是 11 月 25 号。\r192.Ich muss meine Steuern bis zum 15.April bezahlen.我必须在 4 月 15 号之前交清税。 193.Ist der 30.ein Montag?30 号是星期一吗?\r194.Mein Geburtstag ist am 9.Mai.我的生日在 5 月 9 号。\r195.Ich muss diesen Aufsatz bis zum nächstem Dienstag beenden.我必须在下个星\r期二之前完成这论文。 ## Lektion14 Ueber das Wettersprechen 谈论天气\r196.Es ist gutes Wetter zum Fussballspielen. 是踢足球的好天气。\r197.Es ist sehr klar und kuehl.天气干爽。\r198.Es wird schnell kalt.天气很快会变冷的。\r199.Dieser Fruehling soll kalt werden.据推测今年的春天会很冷。\r200.Wirhaben eine Menge Regen diesen Winter.我们今年冬天下了很多雨。\r201.Es ist kochend heiss draussen.外面很热。\r202.Bei dieser hohen Feuchtigkeit ist es sehr schwuel draussen.由于湿气很重,外面很闷\r热。\r203.Es regnet sehr stark im Augenblick.现在雨下得很大。 204.Es beginnt zu schneien draussen.外面开始下雪了。 205.Einige Strassen sind schon von Regen ueberschwemmt.有些街道几乎被雨水淹了。\n206.Es friert draussen.外面结冰了。\r207.Es ist ein bisschen kuehl draussen.外面有点冷。\r208.Die Luft ist warm,aber es gibt eine schoene Brise.天气挺热,但是有怡人的微风。 209.Dieser Morgen ist kuehler als erwartet.今天早上比预计的要凉快。\r210.Es wird waermer im Laufe des Tageswerden.天气会一天天地变暖和。\r## Lektion 15 Um Hilfe bitten 求助\r211.Brauchen Sie meine Hilfe?您需要我的帮助吗?\r212.Ich habe gehofft ,dass Sie mir helfen koennten.我希望您能帮助我。 213.Koennten Sie sie mir ausleihen?您能把它们借给我吗?\r214.Wie kann ich Ihnen helfen?我能帮忙吗?\r215.Womitkann ich Ihnen helfen?我能帮您什么忙吗?\r216.Ich brauche keine Hilfe.我不需要帮助。\r217.Helfen Sie mir,bitte.请帮帮我。\r218.Ich suche Kanistrasse 16.我在找康尼大街 16 号。 219.KoennenSiemirsagen,wieichdorthinkomme?您能告诉我 如何到那儿吗? 220.Wie lange brauche ich zu Fuss?我要走多久?\r221.Wissen Sie,wie ich zum Stadion komme?您知道体育馆怎么去吗?\r222.Mein Haus ist gleich neben dem Postamt.过来邮局再走两家就是我家了。 223.Der Busbahnhof ist auf der linken Seite.汽车站在您的左手边。 224.WelcheRichtung ist Norden?哪是北方?\r225.WelcheStrasse ist das?这是哪条街? ## Lektion16 Ein Telefonatfuehren,etwas bestellen\r226.Hallo?喂?\r227.Hier ist Professor Schmith.我是史密斯教授。\r228.Ich rufe Sie morgen an.我明天给您打电话。\r229.Mit wem spreche ich?请问您是哪一位?\r230.Wie kann ich Ihren Anruf weiterleiten?要我把您的电话转给谁 ?\r231.Haben Sie die falsche Nummer gewaehlt?您打错电话了吗?\r232.Mit wem moechten Sie sprechen?您想和谁通话?\r233.Er ist im Augenblick nicht hier.他现在不在这儿。\r234.Ich muss einen Terminmachen.我需要订一个预约。\r235.Wannkann ich mit Ihnen sprechen?我什么时候能和您谈谈?\r236.Wasmachen Sie naechsten Donnerstag?下个星期四您干什么?\r237.Moechten Sie darueber ein andermal sprechen?下次再谈这个好吗?\r238.Ich moechte eine Reservierung fuer naechsten Freitag vomehmen.我想预定下个星期\r五的(房间等)。\r239.Kann ich morgen kommen?我可以明天来吗? 240.Koennen Sie am Nachmittag kommen ?您今天下午能来吗?\r## Lektion17UeberTaetigkeitensprechen 谈论活动 241.Wohingehen Sie?您要去哪儿?\r242.Wastun Sie jetzt?您现在在干什么?\r243.Wenn ich nicht fruehstuecke, dann habe ich nicht genuegend Energie waehrend des Tages. 如果我不吃早餐的话,我就一天都没有足够的能量。\r244.Ich muss mir die Zaehne putzen .我得去刷牙了。\r245.Ich habe keine Zeit ,jetzt zu duschen.我现在没时间淋浴。\r246.Ich habe keine Zeit ,waehrend der Arbeit zu Mittag zu essen.我上班时没时间吃午饭 。 247.Taeglichmuss ich 40 Minuten zur Arbeit fahren.我每天必须开车 40 分钟去上班。 248.Haben Sie die Zeitung von heute gelesen?您看来今天的报纸吗?\r249.Ich sehe jeden Abend die Nachrichten.我每天晚上都看新闻。\r250.Ich erinnere mich nicht daran,wie es kalt war.但是我记不起来有多冷了。 251.Wohingenau sind wir in Kanada gewesen?我们去了加拿大的哪儿? 252.Wie konnte ich das vergessen?我怎么能忘记呢?\r253.Ich bin nur einmal mit dem Flugzeug geflogen.我只坐过一次飞机。\r254.Ich hoffe,dieses Jahr gute Zensuren zu erhalten.我希望今年能取得好成绩。 255.Ich werde naechstes Jahr Chinesisch studieren.我明年要学汉语。\r## Lektion 18 Ueber das Studiumsprechen 谈论学习\r256.Wie laeuft dein Biologieunterricht?你的生物课怎么样了?\r257.Es ist interessant ,aber es gibt soviel Arbeit.很有趣,但是作业太多了。\r258.Das ist auch meine Meinung,aber ich glaube,dass es sehr langweilig ist.这只是我的看法,我认为那很枯燥。 259.Ich meine ,dass es sehr interessant ist.我认为那很有趣。\r260.Ich hoffe,dass du die Arbeit schaffen kannst.我希望你能跟上功课。\r261.Bist du gut im Matheunterricht?你的数学学得好吗?\r262.Verstehstdu die Chemihausaufgaben?化学作业你能理解吗?\r263.Es ist anstrengend,meinem Englischlehrer zuzuhoeren.很难听清我的英语老师说话 。 264.Ich habe mich die ganze Nacht fuer diesen Test vorbereitet.我一个晚上没睡,为这场\r测验做准备。\r265.Hast du gehoert,dass unser Lehrer einen anderen Aufsatz verlangt hat?你听到我们老师又布置了一篇论文吗?\r266.Mir ist wirklich langweilig in diesem Unterricht.我很厌烦这门课。\r267.Ich mag Biologie mehr als ich zuerst gedacht hatte.我比当初想象的要更喜欢生物课 。 268.Kannst du mir bei den Geschichtshausaufgaben hatte.你能帮我做历史作业吗? 269.Ich komme morgens immer zu spaet in meine erste Vorlesung.早上的第一节课我总\r是迟到。\r270.Ich muss in den Franzoesischunterricht gehen.我必须去上法语课了。\r## Lektion 19 Leute und Gegenstaende beschreiben 谈论人和事物 271.Wo?在哪?\r272.Wasist es?这是什么?\r273.Ist es ein Tiger?是老虎吗?\r274.Werist dieser Mann?那个男人是谁?\r275.Sie sehen mein neuestes Kunstwerk.您正在看的是我最新的艺术作品。\r276.Das braune Auto gehoert zu meiner Schwester.那辆棕色的车是我姐姐的。 277.Ich glaube,dass das rote Auto ein Japanisches ist.我想这辆红色的车是日本车。 278.Er hat eine lange Nase.他的鼻子很长。\r279.Mein Bruder ist schlank.我弟弟很瘦。 280.Dieser Bus ist sehr alt.这辆公共汽车很旧了。\r281.Haben Sie einen gelben Hut hier gesehen?您在这附近看到了一顶黄色帽子了吗? 282.Ich moechte das kleine Kaetzchen mit den orangenen Streifen.我想要这只有桔黄色\r条文的小猫。\r283.Koennen Sie mir eine Beschreibung der Person geben?您能给我描述一下这个人吗? 284.Sie hat ein rundes Gesicht und grosse Augen.她有一张圆脸,大眼睛。\r285.In der Suppe war viel unterschiedlicher Gemuese.这汤中有许多不同的蔬菜。\r## Lektion 20 Auf dem Universitaetsgelaende 在校园里\r286.Ich versuche,die Lektuere fuer unsere Physikvorlesung zu beenden.我在努力完成我\r们物理课的作业。\r287.Ich muss heute Abend meit der Vorbereitung zu beginnen.我必须今晚开始准备。 288.Das Problem ist ,dass ich letzte Woche zwei TageUnterricht verpass habe.问题是我上个星期缺了两天的课。\r289.Gehst du spaeter zur Klassensitzung?你待会儿去开班会吗?\r290.Wie viele Vorlesungen hast du bis jetzt verpasst?到目前为止,你缺了多少课? 291.Du kannst sie fuer einen Monat haben.你可以借一个月。\r292.Es kostet 0.50 pro Tag fuer ueberfaellige Buecher.过期的书一天罚款 50 欧分。 293.Hast du irgendwelche Buecher ueber Russland?你有关于俄国方面的书吗? 294.Man soll nicht in der Bibliothek sprechen.不应该在图书馆聊天。\r295.Dieses Buch ist von einem Professor vorgebucht.这本书被一位教授预订了。 296.Sie ist eine sehr populaere Autorin.她是个很受欢迎的作者。\r297.Diese Bibliothek braucht mehr aktuelle Buecher.图书馆需要多一些最新的书。 298.Wostehen die Mathematikbuecher?数学书在哪儿?\r299.Wannschliesst heute die Bibliothek?图书馆今天什么时候关门?\r300.Ich hasse es ,wenn Leute in Bibliotheksbuecher schreiben.我讨厌别人在图书馆的书\r上面写字。\n","date":"2016-10-20T00:00:00Z","permalink":"https://blog.iostao.com/2016/10/deutsch-900-one/","title":"Deutsch 900 Sätze 1"},{"content":"git push代码的时候，可能会遇到下面的提示：\n$ git push warning: push.default is unset; its implicit value is changing in Git 2.0 from 'matching' to 'simple'. To squelch this message and maintain the current behavior after the default changes, use: git config --global push.default matching To squelch this message and adopt the new behavior now, use:\ngit config --global push.default simple When push.default is set to 'matching', git will push local branches to the remote branches that already exist with the same name. Since Git 2.0, Git defaults to the more conservative 'simple' behavior, which only pushes the current branch to the corresponding remote branch that 'git pull' uses to update the current branch. See 'git help config' and search for 'push.default' for further information. (the 'simple' mode was introduced in Git 1.7.11. Use the similar mode 'current' instead of 'simple' if you sometimes use older versions of Git) 事实上这并不会影响你push的结果，最终push还会成功，因为这只是一个”warning“。会在后面看到push成功的结果。\nCounting objects: 10, done. Delta compression using up to 4 threads. Compressing objects: 100% (10/10), done. Writing objects: 100% (10/10), 1.10 KiB | 0 bytes/s, done. Total 10 (delta 9), reused 0 (delta 0) 你可以按照他说的那样运行： $ git config \u0026ndash;global push.default matching\n或者\n$ git config --global push.default simple 命令，以后再push就不会有警告了。\n下面说一下 push.default matching 和 push.default simple 的区别：\npush.default设置maching的意思是：git push 会把你本地所有分支push到名称相对应的远程主机上。这意味着可能你会在不经意间push一些你原本没打算push的分支。\npush.default设置成simple的意思是：git push仅仅把当前所在分支push到从当初git pull pull下来的那个对应分支上，另外，这个过程也会同时检查各个分支的名称是否相对应。\n","date":"2016-08-04T22:01:33Z","permalink":"https://blog.iostao.com/2016/08/git-warning-default/","title":"Git Warning push.default is unset"},{"content":"第一步：安装rvm RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)\n$ curl -L get.rvm.io | bash -s stable $ source ~/.rvm/scripts/rvm 等待终端加载完毕,后输入：\n$ rvm -v\n如果能显示版本好则安装成功了。\nrvm 1.27.0 (latest) by Wayne E. Seguin \u0026lt;wayneeseguin@gmail.com\u0026gt;, Michal Papis \u0026lt;mpapis@gmail.com\u0026gt; [https://rvm.io/] 列出ruby可安装的版本信息\n$ rvm list known ruby-]2.2[.4] [ruby-]2.3[.0] [ruby-]2.2-head ruby-head 安装一个ruby版本\n$ rvm install 2.3.0 列出ruby已安装的版本信息\n$ rvm list rvm rubies =* ruby-2.3.0 [ x86_64 ] # =\u0026gt; - current # =* - current \u0026amp;\u0026amp; default # * - default 安装完成之后ruby -v查看是否安装成功。\n$ ruby -v ruby 2.3.0p0 (2015-12-25 revision 53290) [x86_64-darwin15]","date":"2016-08-01T13:55:12Z","permalink":"https://blog.iostao.com/2016/08/mac-nvm-update-ruby/","title":"rvm升级Ruby"},{"content":"如果你在一台机器使用两个github账号，或者是使用github的同时，还有bitbucket等代码管理仓库。 例如github，默认情况下，这个秘钥是在你账户的.ssh目录生成id_rsa文件，对应一个id_rsa.pub公钥文件，但是，我可能会有两个github帐号，一个个人，一个办公用（或者是多个仓库管理），这时，我就需要生成多个密钥。\n$ ls ~/.ssh/ config github_rsa github_rsa.pub\npersonalid personalid.pub\n以上是我的密钥列表，那么我的github如何使用多个密钥呢。\n需要编辑一下配置文件~/.ssh/config： 如果没有这个文件，可以创建一个(切换到 ~/.ssh\t目录下)\n$ touch config 编辑 config文件\n1 2 3 4 5 6 7 8 9 Host github.com Hostname github.com User username IdentityFile ~/.ssh/github_rsa Host bitbucket.org Hostname bitbucket.org User username IdentityFile ~/.ssh/personalid 只是用一个公钥 也可以几个账号都上传同一个公钥，配置的时候，使用同一个公钥文件就可以了。为了安全性考虑，不建议这么做\n1 2 3 4 5 6 7 8 9 Host github.com Hostname github.com User username IdentityFile ~/.ssh/github_rsa Host bitbucket.org Hostname bitbucket.org User username IdentityFile ~/.ssh/github_rsa 解释此配置文件：\nHost: \u0026quot;github.com\u0026quot;是一个『别名』，可以随意命名，也可以直接写github Hostname:\t仓储地址：例如git@github.com，这里要的就是 github.com IdentityFile: 所使用的公钥文件 配置完毕，用下面的命令测试一下：\n$ ssh -T git@bitbucket.com logged in as beyond521t. You can use git or hg to connect to Bitbucket. Shell access is disabled. 可以使用如下命令，进行debug查看：\n$ ssh -vv git@bitbucket.com ","date":"2016-07-18T15:43:04Z","permalink":"https://blog.iostao.com/2016/07/git-sshkey-multi/","title":"管理多个SSH Key"},{"content":"本文主要介绍如何使用终端，生成ssh key。 SSH只是一种协议，用于计算机之间的加密登录，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。\n生成SSH KEY： $ ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; , 然后会要求你输入公钥的名字： Enter file in which to save the key (/Users/LaoTao/.ssh/id_rsa): ssh_rsa 接下来要求输入密码，以及确认密码： Enter passphrase (empty for no passphrase): Enter same passphrase again: 以下是整个终端命令流程： $ ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/LaoTao/.ssh/id_rsa): ssh_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ssh_rsa. Your public key has been saved in ssh_rsa.pub. The key fingerprint is: SHA256:m4+0RNpNoAgjjpmtIrQhmwvQHsGnOIoikVkJ/tVqHXM your_email@example.com The key's randomart image is: +---[RSA 2048]----+ |. | |.o . . | |..B .. +.E | |o@.*..o.+. | |%+=..o..S . | |*Bo.. + = | |%.. . * . | |*. o + | |. o . | +----[SHA256]-----+\t可以使用cat命令查看公钥： $ cat ~/.ssh/ssh_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCuX2Zbre+4kPLkolvWXXtmvehFoO/LYVe+/EDA3j4NLX+6GZYXqAG6IEDAKzDKUzaUoxfuWZFk8ZyHhjfViD3FC90Yh9xuIXGYua4xyy6/7CC/HK2mS3Ha0SGW/QKMJ+QrLyeCpUeNiGDbH12DvUJpgp1vwTIIi0Pkykz6SP2mWkgpAKsBYExg+PkY2aLzopw2GpW0JApqQ9Jz/yMZQ5T7yh/k7iYZNWQ/ch9UxmM58gEQjw1qHiC7QZU9JvJsbh+qusNcIjcKLjMrwhw6q21jeGtn+7It4hKo9YL76OR/QRi1OWUJzqOaTY4ssUBEU15f3OGxVT03emJ556hFyVLn your_email@example.com 拷贝命令： Windows:\nclip \u0026lt; ~/.ssh/id_rsa.pub Mac:\npbcopy \u0026lt; ~/.ssh/id_rsa.pub GNU/Linux (requires xclip):\nxclip -sel clip \u0026lt; ~/.ssh/id_rsa.pub 然后将复制的ssh_rsa.pub 公钥粘贴到git服务器的SSH配置中。例如github:\n","date":"2016-07-17T13:42:55Z","permalink":"https://blog.iostao.com/2016/07/git-sshkey/","title":"生成SSH Key"},{"content":"帐号退出登录，切换rootViewController的时候，发现内存没有释放，于是对代码进行了一遍检查。发现了在定义 protocol的时候，有两种方式。\n区别 一个是使用 @objc定义， 一个不使用@objc。\n使用 @objc 方法可以定义 optional。否则，不可以。\n使用 @objc 定义接口 @objc protocol delegateAction : NSObjectProtocol { /** 代理方法 */ optional func delegateMethod() } 这里的写法会造成内存泄露\nclass LTViewModel: NSObject { /** 代理 */ var delegate: delegateAction? } 正确的写法\nclass LTViewModel: NSObject { //这里需要添加 weak 修饰 /** 代理 */ weak var delegate: delegateAction? } 直接使用 protocol 定义接口 protocol delegateAction : NSObjectProtocol { /** 代理方法 */ optional func delegateMethod() } 正确的写法\n//这里不能够使用 weak 修饰，即使使用了，Xcode也会报错。 class LTViewModel: NSObject { /** 代理 */ var delegate: delegateAction? }","date":"2016-07-11T15:39:46Z","permalink":"https://blog.iostao.com/2016/07/swift-delegate-memory-leak/","title":"swift 使用 delegate 内存泄露问题"},{"content":"执行 git pull 的时候，提示(When I do the \u0026ldquo;git pull\u0026rdquo;)\nssh_exchange_identification: read: Connection reset by peer fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 经过各种研究，发现了一个比较坑的问题（至少目前我遇到的就是），问题就是服务端有问题，具体是什么，不清楚，因为我不负责这块内容。只说一下，临时解决吧，因为需要，所以不能够等待服务端解决之后再去提交。 (I found this is because the)\n这种问题是因为使用SSH提交导致的，但是发现使用HTTPS这种提交没有问题。git clone代码的时候，大家肯定会看到，给了两个选项，一个是SSH的地址， 一个是HTTPS的地址。\n//输入命令\n$ git remote -v //输出 SSH的origin配置 origin\tgit@git.******.com:ict/project.git (fetch) origin\tgit@git.******.com:ict/project.git (push) //添加一个HTTPs origin //这里使用的是 HTTPS地址 git remote add origin2 https://git.******.com/ict/project.git //输入命令\n$ git remote -v //输出 origin配置 origin\tgit@git.******.com:ict/project.git (fetch) origin\tgit@git.******.com:ict/project.git (push) origin2\thttps://git.******.com/ict/project.git (fetch) origin2\thttps://git.******.com/ict/project.git (push) //然后进行一下操作实时 //这里使用HTTPS 的话，使用 配置的 origin2 进行配置\n$ git pull origin2 develop //发现执行成功 remote: Counting objects: 22, done. remote: Compressing objects: 100% (22/22), done. remote: Total 22 (delta 12), reused 0 (delta 0) Unpacking objects: 100% (22/22), done. ","date":"2016-07-11T11:43:06Z","permalink":"https://blog.iostao.com/2016/07/git-ssh-exchange-identification/","title":"ssh exchange identification"},{"content":"LTPickerView - Swift 连接地址 GitHub LTPickerView-Swift 关于 VERSION 1.0.1\nSwift 2.2\nTIME 2016-07-09 11:41:07\nCreate By 老陶\n效果图 一维数组 二维数组 时间选择器 要求 因为使用了元组等返回结果，所以不允许在Objective-C中混编使用 使用 返回数据类型 resultValue 是一个元组类型\n/** 返回数据的结果类型 */ typealias pickerResultType = (first: AnyObject, second: AnyObject, third: AnyObject, fourth: AnyObject, fifth: AnyObject) UIPickerView 一、一维数组\nlet array = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;] let pickerView = LTPickerView.pickerView(array, title: \u0026quot;一维数组\u0026quot;) pickerView.setSelectedRow(2)\t//选中某一行 pickerView.show()\t//显示界面 //点击 确定/取消 的回调方法 pickerView.resultClosure({ (pickerView, resultValue) in print(\u0026quot;\\(resultValue)\u0026quot;) }) { (pickerView) in } 二、多维数组\nlet array = [[\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;]] let pickerView = LTPickerView.pickerView(array, title: \u0026quot;多维数组\u0026quot;) //选中行数，这里必须使用(0, 0, 0, 0, 0) 这种元组格式，5个元素 pickerView.setSelectedRows((0, 1, 2, 3, 0)) pickerView.show() //点击 确定/取消 的回调方法 pickerView.resultClosure({ (pickerView, resultValue) in }) { (pickerView) in } UIDatePicker let pickerView = LTPickerView.datePickerView(NSDate(), datePickerMode: UIDatePickerMode.Date, title: \u0026quot;时间选择器\u0026quot;) pickerView.show() pickerView.resultClosure({ (pickerView, resultValue) in //resultValue.first 是输出的`String`类型 //resultValue.second 是输出的`NSDate`类型 print(\u0026quot;\\(resultValue.first), \\(resultValue.second)\u0026quot;) }) { (pickerView) in } 版本更新 ####V1.0.0\n2016-07-09 11:41:40\nFirst Version\n####V1.0.1 2016-07-09 11:41:45\n增加时间选择器，默认选中时间功能 修复已知bug\n","date":"2016-07-08T23:08:08Z","permalink":"https://blog.iostao.com/2016/07/swift-ltpickerview/","title":"LTPickerView.swift"},{"content":"swift 判断String里面包含的中、英文、数字、符号。并附汉字Unicode字符编码表。 Unicode字符编码表\u0026ndash;下载\nlet text = \u0026ldquo;文字内容text123😄\u0026rdquo; for commitChar in text.unicodeScalars { //字符串只有一个字符，这个循环只会执行1次 print(Int(commitChar.value))\nif ((commitChar.value\u0026gt;=0x4e00)\u0026amp;\u0026amp;(commitChar.value\u0026lt;=0x9FA5)) { //字符为中文 print(\u0026quot;字符为中文\u0026quot;) } else if((commitChar.value\u0026gt;64)\u0026amp;\u0026amp;(commitChar.value\u0026lt;91)){ print(\u0026quot;字符为大写英文字母\u0026quot;) }else if((commitChar.value\u0026gt;96)\u0026amp;\u0026amp;(commitChar.value\u0026lt;123)){ print(\u0026quot;字符为小写英文字母\u0026quot;) }else if((commitChar.value\u0026gt;47)\u0026amp;\u0026amp;(commitChar.value\u0026lt;58)){ print(\u0026quot;字符为数字\u0026quot;) }else{ print(\u0026quot;其他字符\u0026quot;) } } ","date":"2016-06-22T15:01:36Z","permalink":"https://blog.iostao.com/2016/06/swift-unicodescalars/","title":"判断中、英文、数字、符号"},{"content":"一、下载 可以到charles官网下载到最新版本。\n二、破解 顶部下载文件中，含有破解包。\n打开应用程序，选择Charles,选择显示包内容： 然后点击Contents-\u0026gt;Resources-\u0026gt;Java:\n然后将我们下载下来的charles.jar替换这里的charles.jar就可以了。然后打开Charles就可以了。\n三、抓包 第一、HTTP抓包 1、打开Charles程序\n2、查看Mac电脑的IP地址，系统偏好设置-\u0026gt;网络就可以查看到了，比如我的ip地址是：192.168.2.248 3、打开iOS设置，进入当前wifi连接(必须和Mac在一个局域网内)，设置HTTP代理『手动』，将服务器填为上一步中获得的IP，即192.168.2.248，端口填8888。\n4、iOS设备打开你要抓包的app进行网络操作\n5、Charles弹出确认框，点击Allow按钮即可\n第二、HTTPS抓包\n需要下载Charles证书:\n证书下载地址\n具体链接\nCharles证书，解压后导入到iOS设备中 在HTTPS的接口上，右键，选择Enable SSL Proxying就可以抓该HTTPS接口的数据了。 注意：当我们不抓包的时候，会将Charles关闭，这时候iOS如果还开着代理，是访问不到网络的，因为设置了代理(就是Charles)，这时候需要将iOS中的代理关闭，这个是抓包时经常犯的错。千万不要因为这种二逼问题，耽误了工作。\n","date":"2016-06-13T17:49:18Z","permalink":"https://blog.iostao.com/2016/06/mac-charlesproxy/","title":"charles 抓包"},{"content":"5月30号参加的APS审核，然后大概第三天查了一下成绩，很高兴通过了。周末趁着有时间，在这里简单写一下关于APS的一些心得吧。\n我是元旦的时候，寄出去的审核材料，到审核一共差不多是半年整。期间因为工作的原因，也就是下班或者周末的时候，简单的整理了一下各科的资料，整理资料，写翻译。但是效率并不高。上个月接到审核电话之后，就有点慌了，因为只有整理了资料，并没有记住。所以就开始准备认真学习了。周末的时候，先去的中国传媒大学教学楼学习，后来去的北京第二外国语学院，发现二外学习还是不错的，去餐厅也近一些。\n期间各种学习，然后审核的前一个周末，我朋友说帮我模拟面试一下，结果我发现虽然东西我都记住了，但是张口说不出来，因为平时看东西都是小声的说并记忆，导致正常说的时候，说不出来，然后最后三天时间就重点练习口语。张开口，自问自答。\n我是周二审核，周一那天请了一天假，在家练习了一天。我住的地方到亮马桥那边有点儿远，所以下午去那边附近酒店，提前入住，这样第二天可以省很多时间。\n到了那边报道之后，前台会让你去等候室等待，好多人在里面，如果自信的话，可以和旁边的和小伙伴聊聊天。我是比较紧张，就自己坐在那里，然后等了几个人之后，就看到一个头发有些红色，然后像熊猫的那位过来叫人，念的我的名字，然后我走过去的时候，就听到好多人说红灭啊。\n主审核官是红灭，自我感觉人还是不错的。过去的时候把包放到了柜子里，然后口袋里也不要放什么东西，当时我口袋里放了张房卡。她看到我口袋有东西，就问我是什么，我刚开始没听出来，她就脾气暴躁的又问了两次，然后我反应过来，掏出来给她看了一下，她就让我去笔试的那个小房间里了。\n小房间里有笔，词典这些，当然不要想着中英、中德词典了。而且时间有限，尽量提前背熟词汇，翻词典挺浪费时间的。\n我的笔试题是两道大题，不清楚其他人的题是什么样的题型，因为保密问题，不能在这里写出来了。不过我第二个有几个单词想不起来了，因为有几个点，那几个单词的影响，这道题只回答了一半。\n到时间了，红灭把我领导对面的办公室里，还有一个副审核官，进去之后打了招呼入座。然后红灭可能脾气暴躁还是什么影响吧，坐下之后，又确认了一下我的名字。我以为接下来会是自我介绍什么的，结果都没有，直接就是问了专业知识。虽然我工作一年了，但是并没有问毕业论文的东西。我是计算机专业的，中间有几门课是实践课，问到了之后，我告诉她是实践内容，但是有一些词汇没准备好，回答的并不是很好。另外就是我英语没有过四级，所以语言也不好。\n后面就是问了一下我为什么想去德国，想去什么学校。简单聊了一下，红灭送我出来的时候，对我说了一句你的语言很差，我以为挂了呢，不过幸运的是通过了。\n我是毕业工作了之后审核的APS，网上很多说的毕业了之后，很多是问你自我介绍 为什么想出国学习、毕业论文这些，专业课知识问的少，这种话不要相信，我是自我介绍、毕业论文都没有问，基本都是专业知识。所以准备一定要充分。\n","date":"2016-06-11T10:46:18Z","permalink":"https://blog.iostao.com/2016/06/aps-pass/","title":"APS过审了，开心"},{"content":"版权声明：本文为博主原创文章，未经博主允许不得转载。 -- 老陶 刚工作的时候做了多语言，发现网上方法很多都是关于跟随系统语言设置的，而系统内部设置的确比较少。\n所以今天闲来没事，写一写总结，供大家参考。\n当然做的时候，也会百度搜索，所以项目中可能会看到网上一些比较熟悉的东西。\n大家做这一步，相信项目工程是有的了吧（因为本人做独立开发，所以一般新功能几乎都是在项目中做的，很少有写demo，就不考虑demo的情况了）\n在项目文件的Supporting Files中的InfoPlist.strings中，右键(或command + N)\u0026ndash;\u0026gt;新建一个string文件。\n（如果没有这个文件，在xcode6中创建，好像没有看到，可以自己创建一个文件，名字可以随便取，后面会给一个方法，获取这个文件的。） 如图1-1所以\n创建完文件之后，点击项目—\u0026gt;选择Project—\u0026gt;选择Info—\u0026gt;点击“+”号。（画线隐藏） 在右下方有个Language的选项，默认进来是只有English的，点击+号之后可以看到各种语言选项\n在这里选择Chinese(Simplified)。下面会出现一个选项，选择InfoPlist.string文件，那个是语言设置的。（如果是自定义的文件，就选择自定义的那个）\n//\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n到这里，基本配置就完成了。然后后面就是设置需要的字符，以及调用方法了\n在相应的string文件中，写入需要的字符。前面相当于key。后面是value。\nCFBundleDisplayName是app的名字，技术不够，暂时不知道如何手动切换语言，改变桌面的名字，这一步，只是根据系统语言来的。\n如果默认根据系统语言更改语言，那么调用的时候只需要NSLocalizedString(\u0026lt;#key#\u0026gt;, \u0026lt;#comment#\u0026gt;)用这一句就可以了。其他的不需要做处理。\n如果是想自定义的话，那么需要写一个类：\n//.h头文件： #import \u0026lt;Foundation/Foundation.h\u0026gt;\n@interface InternationalController : NSObject\n(NSBundle *)bundle; //获取当前资源文件 (void)initUserLanguage; //初始化语言文件 (NSString *)userLanguage; //获取应用当前语言 (void)setUserLanguage:(NSString *)language; //设置当前语言 @end\n//.m类体文件\n// // InternationalController.m // mworkingHaier // // Created by LaoTao on 14-10-20. // Copyright (c) 2014年 CaiGaoBaDou. All rights reserved. //\n#import \u0026ldquo;InternationalController.h\u0026rdquo; #import \u0026lt;UIKit/UIKit.h\u0026gt;\n@implementation InternationalController\n//创建静态变量bundle，以及获取方法bundle（此处不要使用getBundle). static NSBundle *bundle = nil;\n(NSBundle *)bundle { return bundle; } //初始化方法:\n(void)initUserLanguage { NSUserDefaults *def = [NSUserDefaults standardUserDefaults]; NSString *string = [def valueForKey:kLanguage];\nif (string.length == 0) { //获取系统当前语言版本（中文zh-Hans,英文en) NSArray *languages = [def objectForKey:@\u0026ldquo;AppleLanguages\u0026rdquo;]; NSString *current =[languages objectAtIndex:0]; string = current; [def setValue:current forKey:kLanguage]; [def synchronize]; //持久化，不加的话不会保存 }\n//获取文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:string ofType:@\u0026ldquo;lproj\u0026rdquo;]; // NSLog(@\u0026quot;%@\u0026quot;,path); bundle = [NSBundle bundleWithPath:path]; //生成bundle }\n//获得当前语言的方法\n(NSString *)userLanguage { NSUserDefaults *def = [NSUserDefaults standardUserDefaults]; NSString *language = [def valueForKey:kLanguage]; return language; } //设置语言\n(void)setUserLanguage:(NSString *)language { NSUserDefaults *def = [NSUserDefaults standardUserDefaults];\n//1.第一步改变bundle的值 NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@\u0026ldquo;lproj\u0026rdquo;]; bundle = [NSBundle bundleWithPath:path];\n//2.持久化 [def setValue:language forKey:kLanguage]; [def synchronize]; }\n@end\n把\u0026quot;InternationalController.h\u0026quot;这个在.pch文件中引用，这样全局就都可以调用了\n在AppDelegate.m的didFinishLaunchingWithOptions方法中，加一句：\n[InternationalController initUserLanguage]; //初始化应用语言\n然后设置个全局的宏变量，系统的是NSLocalizedString.这里就设置了LTlocalizedString（LT是老陶的首字母，beyond521t这个t同理，嘿嘿）\nself.title = LTLocalizedString(@\u0026ldquo;TitleName\u0026rdquo;, nil);\n如此就可以使用了。切换语言，请看头文件，直接方法名 + 方法，以及语言就OK了。\n注：英文在iOS中为\u0026quot;en\u0026quot;,简体中文\u0026quot;zh-Hans\u0026quot;.\n切换语言后：处理方法是，再次跳转到根视图即可。（更多处理方式，请看本人另一篇日志，根视图处理）\n","date":"2016-05-25T17:26:36Z","permalink":"https://blog.iostao.com/2016/05/ios-multilanguage/","title":"iOS多语言，支持app内部设置"},{"content":"根据苹果开发者网站的声明，大部分现有应用程序已经通过NSURLSession和CFNetwork APIs兼容该协议。依然使用IPv4 APIs的或者硬件编码IP地址的开发者将需要手工调整应用代码来适应苹果的最新策略。\nIPv6比IPv4更有效： 避免了网络地址转换的需要(NAT: Network Address Translation) 通过使用简单的Headers，通过网络提供更快的路由 防止网络碎片 Avoids broadcasting for neighbor address resolution （避免广播 \u0026hellip;.，请自行翻译好了） DNS64/NAT64 过渡工作流程 为了帮助减缓IPv4地址耗尽，NAT在许多IPv4网络实现。虽然这个解决方案暂时工作，它证明了昂贵和脆弱。今天，随着越来越多的客户使用IPv6，供应商现在必须同时支持IPv4和IPv6。这是一个代价高昂的努力。 图1-1蜂窝网络提供独立的IPv4和IPv6连接 理想的情况下，供应商要降为IPv4网络支持。然而，这样做可以防止客户端访问IPv4的服务器，这是互联网的一个重要部分。为了解决这个问题，最主要的网络供应商实施 DNS64/NAT64 过渡工作。这是一个纯IPv6网络，继续提供访问IPv4内容通过翻译。 图1-2蜂窝网络的部署与 DNS64 和 NAT64 的IPv6网络 在这种类型的工作流中，客户端发送DNS查询到DNS64服务器，它要求从DNS服务器获取 IPv6 地址。当一个IPv6地址被发现，它会立即传回到客户端。然而，当没有找到IPv6地址时，DNS64服务器请求一个IPv4地址代替。然后DNS64服务器通过为IPv4添加地址前缀合成一个IPv6地址，并传递回客户端。在这方面，客户端总是收到一个IPv6-ready地址（In this regard, the client always receives an IPv6-ready address.最后一句原文 By 老陶2016-05-22 12:29:56）。\n图1-3处理IPv4向IPv6的转换过程 当客户端像服务器发送一个请求，任何IPv6数据包\nWhen the client sends a request to a server, any IPv6 packets destined for synthesized addresses are automatically routed by the network through a NAT64 gateway. The gateway performs the IPv6-to-IPv4 address and protocol translation for the request. It also performs the IPv4 to IPv6 translation for the response from the server. See Figure 1-4.\n图1-4 DNS64/NAT64过渡方案工作流程 IPv6 和 App Store 的要求 IPv6 DNS64/NAT64的网络兼容性处理将成为 App Store 的一个提交要求，所以应用程序兼容性不可少的。好消息是大部分软件都兼容IPv6.对于这些应用，定期回归测试你的应用程序仍然是有必要的。不兼容IPv6的应用在操作DNS64/NAT64网络时可能会遇到问题。幸运的是，解决这些问题通常很简单，就像是本章节所讨论的。\n支持IPv6的常见问题 几种阻止一个应用支持IPv6的情况。下面的章节描述如何解决这些问题。\n协议中包含IP地址的文字。 在配置文件中包含IP地址。 网络检测。 使用地级别的网络API. Using small address family storage containers.（请自行翻译 add By 老陶 2016-05-22 15:15:36） 此部分原文：\nSeveral situations can prevent an app from supporting IPv6. The sections that follow describe how to resolve these problems. IP address literals embedded in protocols. Many communications protocols, such as Session Initiation Protocol (SIP), File Transfer Protocol (FTP), WebSockets, and Peer-to-Peer Protocol (P2PP), include IP address literals in protocol messages. For example, the FTP parameter commands DATA PORT and PASSIVE exchange information that includes IP address literals. Similarly, IP address literals may appear in the values of SIP header fields, such as To, From, Contact, Record-Route, and Via. See Use High-Level Networking Frameworks and Don’t Use IP Address Literals. IP address literals embedded in configuration files. Configuration files often include IP address literals. See Don’t Use IP Address Literals. Network preflighting. Many apps attempt to proactively check for an Internet connection or an active Wi-Fi connection by passing IP address literals to network reachability APIs. See Connect Without Preflight. Using low-level networking APIs. Some apps work directly with sockets and other raw network APIs such as gethostbyname, gethostbyname2, and inet_aton. These APIs are prone to misuse or they only support IPv4—for example, resolving hostnames for the AF_INET address family, rather than the AF_UNSPEC address family. See Use High-Level Networking Frameworks. Using small address family storage containers. Some apps and networking libraries use address storage containers—such as uint32_t, in_addr, and sockaddr_in—that are 32 bits or smaller. See Use Appropriately Sized Storage Containers. 确保IPv6 DNS64/NAT64兼容性 遵循以下的知道以确保IPv6 DNS64/NAT64在你的应用程序的兼容性。\n使用高级的网络框架 应用需要可以建立在`高级网络框架` 或 `低级POSIX socket API网络框架`。在大多数情况下，高层次框架是足够的。它们有能力，易于使用，相比低级API拥有更少的缺陷。 图 1-5 网络框架和API图 WebKit. This framework provides a set of classes for displaying web content in windows, and implements browser features such as following links, managing a back-forward list, and managing a history of pages recently visited. WebKit simplifies the complicated process of loading webpages—that is, asynchronously requesting web content from an HTTP server where the response may arrive incrementally, in random order, or partially due to network errors. For more information, see WebKit Framework Reference.\nCocoa URL loading system. This system is the easiest way to send and receive data over the network without providing an explicit IP address. Data is sent and received using one of several classes—such as NSURLSession, NSURLRequest, and NSURLConnection—that work with NSURL objects. NSURL objects let your app manipulate URLs and the resources they reference. Create an NSURL object by calling the initWithString: method and passing it a URL specifier. Call the checkResourceIsReachableAndReturnError: method of the NSURL class to check the reachability of a host. For more information, see URL Session Programming Guide.\nCFNetwork. This Core Services framework provides a library of abstractions for network protocols, which makes it easy to perform a variety of network tasks such as working with BSD sockets, resolving DNS hosts, and working with HTTP/HTTPS. To target a host without an explicit IP address, call the CFHostCreateWithName method. To open a pair of TCP sockets to the host, call the CFStreamCreatePairWithSocketToCFHost method. For more information, see [CFNetwork Concepts](CFNetwork Concepts) in CFNetwork Programming Guide. If you do require the low-level socket APIs, follow the guidelines in RFC4038: Application Aspects of IPv6 Transition.\n","date":"2016-05-22T11:58:16Z","permalink":"https://blog.iostao.com/2016/05/ios-requireipv6/","title":"6 月 1 日起所有提交的 app 都需要支持 IPv6 网络"},{"content":"问题 Assertion failed: (currentSyncQueue != self \u0026amp;\u0026amp; \u0026ldquo;inDatabase: was called reentrantly on the same queue,which would lead to a deadlock\u0026rdquo;),function -[FMDatabaseQueue inDatabase:],file /Users/LaoTao/Documents/CIM/cim-ios/HealthGuard/Class/Lib/Tools/LocalDB/FMDB/FMDatabaseQueue.m, line 153.\n今天运行app，发现在“assert(currentSyncQueue != self \u0026amp;\u0026amp; \u0026ldquo;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock\u0026rdquo;);”这句crash掉了。 然后就去先看一下大意：\n断言失败(Assertion 单元测试的时候会经常碰到)，inDatabase 在相同的queue队列中被重复调用，引发死锁。\n原因 在使用时，如果在queue里面的block执行过程中，又调用了 indatabase方法，则会检查 是不是同一个queue，如果是同一个queue会死锁；原因很简单：\n队列里面 放了一个block，该block又在 本队列 后面放了一个 block；\n从而：前一个block 里面 调用了 后一个block，必须等后一个block执行完成了，\n前一个block才会 出队列；\n而后一个block想要执行，则又必须先等 前一个block出队列；\n因此 死锁！！！！\n解决方法 在indatabase的block中，不要再调用indatabase方法。这个细心一下，多数时候很容易发现。\n可是有时候因代码封装等问题，大家可能很难发现问题所在。那么就来个暴力断点吧。在每一个使用indatabase的地方都 NSLog(或者print)一下一个编号。 然后crash的时候，看一下最后是哪两个相互发生的影响造成的死锁。\n","date":"2016-05-16T16:26:01Z","permalink":"https://blog.iostao.com/2016/05/ios-fmdatabasequeue-lead-to-a-deadlock/","title":"FMDatabaseQueue lead to a deadlock"},{"content":"站点地图SiteMap的好处是很大的，对Seo很有好处，能够更方便、迅速的让搜索引擎收录。 只需要四部你就可以完成站点地图的制作。\n地址\n1.输入你的网址和一些附加选项。如下图 2.点击提交开始生成。你可以休息会，可能要登几分钟。 3.下载为你生成的sitemapXML文件。\n4.上传到你的网站目录下。 如果是使用的hexo博客模板。那么将文件放在 /source 目录下面。然后执行以下命令就可以了。\n$ hexo generate $ hexo deploy 不过相应的搜索引擎需要设置好才可以。不然可不会生效。\n通过上面四步就ok啦！\n效果如下图，不过不会立即生效的。上传后，等一些时日就好了。 ","date":"2016-05-15T12:01:11Z","permalink":"https://blog.iostao.com/2016/05/web-onlinegenerationsitemap/","title":"在线生成站点地图SiteMap"},{"content":"inout 关键字可以用于将参数修饰为可修改，并且将修改会回传。这次 Swift 3 中对这个关键字也做了一些修改，咱们一起来聊聊吧。\n在 Swift 中，如果我们希望一个函数可以修改它的参数变量的值，我们可以使用 inout 关键词。这个相当于编程语言概念中所谓的传址调用。 具体代码中就是这样的例子：\nfunc foo(inout x: Int) { x = 2 } var x = 5 foo(\u0026amp;x) print(x) // 2 在这个例子中， foo 函数的参数 x, 使用了 inout 修饰，这样我们在后面的调用中，将变量 x 传递给这个函数后，这个变量中的值也会被这个函数内部改变。 这个就是 inout 的基本作用了。\n在 Swift 3.0 中，有一个 SE-0031 的提案，就是改变 inout 这个关键词的位置的。\n当前的语法中，inout 的位置是在参数标签的位置上，也就是这个例子中的：\nfunc foo(inout x: Int) inout 关键字位于参数标签 x 的前面。 而 Swift 3.0 以后，这个关键词的位置就会在参数类型前面了：\nfunc foo(x: inout Int) 这个提案中也解释了这样做的好处。首先这样做之后参数标签就不和修饰关键字发生混淆，比如避免了这样的情况：\nfunc foo(inOut x: Int) func foo(inout x: Int) 第一行的 inout 的大小写错误，所以它不是关键字。但这时编译器不会报错，因为 inOut 这时候作为了外部参数标签(Swift 的参数标签分为外部标签和内部标签，这个例子中外部标签是 inOut，所以我们在外部调用这个函数的时候就是这个语法 foo(inOut:),而函数内部还是用内部标签 x 来引用这个参数)。\n除了避免混淆之外，inout 的位置移动后还有一点需要大家注意的。按照提案中的意思，就是以前版本的遗留代码中的 inout，很可能会变成参数标签，也就是这样：\nfunc foo(inout x: Int) 比如之前我们的 foo 函数这样定义，但 Swift 3.0 之后， 这里的 inout 并不是关键字，而变成这个参数的外部标签了。所以这一点还是很值得注意的。\n最后提案中还说了一句，这样修改后能够更好的和 Rust 语言的模式相匹配。并且说在后续的版本中会更多的引入到 Swift 语言中。\n总体来说呢，这个改动不算大，但多多少少会对我们已有的代码造成一些影响。 inout 这个关键字大家应该多少都会用到过。所以在 Swift 3.0 更新后，也需要注意下这个问题~\n","date":"2016-05-14T21:36:37Z","permalink":"https://blog.iostao.com/2016/05/swift-inout-keyordschangeposition/","title":"inout 关键字位置的变化"},{"content":"转自:swiftcafe\nSwift 3.0 更新越来越临近，这次更新会给我们带来很多实用的内容，比如对 Objc 库的迁移，会更符合 Swift 的语法风格。用过之前版本的 Swift，我们会发现很多 Objc 库的方法名称其实还是以 Objc 的风格来命名，而这次 Swift 3.0 的更新会专门处理这个问题。\n原因\n这个源于一个编号为 SE-0005 的提案，并且已经审核通过。这个方案的提出，源于这样一个痛点。 Swift 应用于 iOS App 开发，就免不了会依赖于原生的 Cocoa Touch 库。而由于历史原因，大家也都知道， iOS 原生库大多时基于 Objc 来实现的。所以他们的编码规范也都遵循着 Objc 的规范，诸如函数，方法的命名规则这些，都有自己的一套标准。\n而 Swift 3.0 也发布了自己的 API 设计规范，同时 Objc 也有自己的设计规范，这样一来我们使用 Swift 开发 iOS App 的时候，其实总是在游走于两套规范的 API 之间，对开发者的体验嘛，就不是很好了。\n例子\n咱们用一个实际的例子来说明这个问题。 比如 NSString 有这样一个方法：\n1 2 let content = listItemView.text.stringByTrimmingCharactersInSet( NSCharacterSet.whitespaceAndNewlineCharacterSet()) stringByTrimmingCharactersInSet 会剪掉字符串头尾中的某些字符。从这个方法名中，明显的可以看出它是以 Objc 规范来命名的。\n如果以 Swift 的编码规范，这个方法其实应该这样命名：\n1 let content = listItemView.text.trimming(.whitespaceAndNewlines) 从这里可以看出，objc 的命名方式，很多会把函数的返回值类型，以及参数类型都包含在函数名里面。比如我们上面的 stringByTrimmingCharactersInSet 方法。但这和 Swift 命名规则就不同了。而且随着 Swift 规范的清晰，这个问题就越来越凸显出来了。\n所以 Swift 3.0 才会将这个问题提上日程，并在这个版本中准备解决这个问题。\n规则\n解决这个问题，肯定不能手动的替换。因为系统库的方法实在太多了，所以就需要总结出一系列替换规则。根据这些规则将相应的标识替换完成。\n那么 Swift 具体是怎么做的呢， 咱们来了解一下。\n扩大 swift_name 编译属性的应用范围 - 这个涉及到 Swift 底层的概念，当我们将 Objc 的 API 导入到 Swift 的时候，我们是可以指定一个编译属性 swift_name 的。而这个编译属性，可以将 Objc 中的标识名称在 Swift 中以不同的名字表现出来。但在之前的版本中，这个编译属性只能对枚举项和工厂方法有效，这次将会扩大它的范围。\n去除多余的类型名称 - Objc 的编码规范中，会建议在方法名称中将参数名和类型也表示出来，而这个在 Swift 中就是多余的，我们前面那个例子也演示了。这个也是着重处理的点。\n添加默认参数 - 对于 Objc 需要默认参数的地方，会在 Swift 中添加上默认参数，比如一些选项参数：\n1 NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.AllowFragments) 这个 option 参数就会提供默认参数。\n添加第一个参数的参数标签 - 为方法的第一个参数添加合适的参数标签。\n在布尔属性前面加上 is - 在最新的 Swift 规范中，需要在布尔属性前面加上 is, 而 Objc 规范恰巧不建议使用 is，所以在 Swift 3 中会将 Objc 迁移过来的布尔属性，按照 Swift 规范来进行修改。可以参考 Swift 规范中关于布尔属性的部分内容。\n值类型变成小写 - 会将 Objc 的属性值以小写开头， 比如 URLHandler 会变为 urlHandler。\n下面是一个官方文档中给出的转换的例子：\nclass UIBezierPath : NSObject, NSCopying, NSCoding { convenience init(ovalInRect: CGRect) func moveToPoint(_: CGPoint) func addLineToPoint(_: CGPoint) func addCurveToPoint(_: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint) func addQuadCurveToPoint(_: CGPoint, controlPoint: CGPoint) func appendPath(_: UIBezierPath) func bezierPathByReversingPath() -\u0026gt; UIBezierPath func applyTransform(_: CGAffineTransform) var empty: Bool { get } func containsPoint(_: CGPoint) -\u0026gt; Bool func fillWithBlendMode(_: CGBlendMode, alpha: CGFloat) func strokeWithBlendMode(_: CGBlendMode, alpha: CGFloat) func copyWithZone(_: NSZone) -\u0026gt; AnyObject func encodeWithCoder(_: NSCoder) } 转换后：\nclass UIBezierPath : NSObject, NSCopying, NSCoding { convenience init(ovalIn rect: CGRect) func move(to point: CGPoint) func addLine(to point: CGPoint) func addCurve(to endPoint: CGPoint, controlPoint1 controlPoint1: CGPoint, controlPoint2 controlPoint2: CGPoint) func addQuadCurve(to endPoint: CGPoint, controlPoint controlPoint: CGPoint) func append(_ bezierPath: UIBezierPath) func reversing() -\u0026gt; UIBezierPath func apply(_ transform: CGAffineTransform) var isEmpty: Bool { get } func contains(_ point: CGPoint) -\u0026gt; Bool func fill(_ blendMode: CGBlendMode, alpha alpha: CGFloat) func stroke(_ blendMode: CGBlendMode, alpha alpha: CGFloat) func copy(with zone: NSZone = nil) -\u0026gt; AnyObject func encode(with aCoder: NSCoder) } 是不是感觉方法名清晰很多呢。\n总结\n以上就是 Swift 3 对 Objc 依赖库中的优化了，这次优化后，我们以后在用 Swift 来开发 iOS App 的时候，就不会再混合两种代码风格啦。\n","date":"2016-05-09T21:24:10Z","permalink":"https://blog.iostao.com/2016/05/swift3-0advanceobjctransformtoswift/","title":"Swift 3.0 预告：将 Objc 库转换成更符合 Swift 语法风格的形式"},{"content":"Xcode7.3我更新到了Xcode7.3.1版本，然后在编译运行的时候就经常提示错误：\nCommand /Applications/Xcode.app/Contents/Developer/Toolchains/ XcodeDefault.xctoolchain/usr/bin/swiftc failed with exit code 1 不过当我再次编译的时候，就会执行正常。偶尔会提示这个问题，刚开始以为是Xcode7.3.1版本的问题。然而在今天准备打包的时候，却一直被这个提示卡在了这里。无奈只能去想办法去解决这个问题了。 刚开始网上查找资料，有的说是有的文件不存在，经过排查，确实发现了，有红色的文件。 删除之后，却还是不成功。最后通过修改配置，暂时解决了。\nTarget \u0026gt; Build Settings \u0026gt; Swift Compiler \u0026gt; Optimization Level. I had to change my \u0026quot;Optimization Level\u0026quot; to None[-0none] 虽然这里通过了编译，但不知道有没有更好的办法。\n","date":"2016-05-09T10:58:13Z","permalink":"https://blog.iostao.com/2016/05/swiftpackageerror-swiftc-failed-with-exit-code-1/","title":"swift打包失败，swiftc failed with exit code 1"},{"content":"自今年6月1日开始，所有提交至苹果App Store的应用申请必须要兼容面向硬件识别和网络路由的最新互联网协议\u0026ndash;IPv6-only标准。在去年的全球开发者大会上苹果就率先宣布iOS9会向IPv6-only网络服务过渡。(Supporting IPv6 DNS64/NAT64 Networks)\nApple 在这里给出了适配 IPv6 的指南\n根据苹果开发者网站的声明，大部分现有应用程序已经通过NSURLSession和CFNetwork APIs兼容该协议。依然使用IPv4 APIs的或者硬件编码IP地址的开发者将需要手工调整应用代码来适应苹果的最新策略。\n随着IPv4地址用完，转移到地址更丰富的IPv6协议正在变得越来越重要。对于苹果来说，切换至IPv6能够带来更广泛的行业接受协议，尤其是那些负责销售iPhone和iPad的网络运营商们。此外伴随物联网的迅速普及，能够加速智能手机的迅猛发展。\n其实早在2012年6月的IPv6日，世界范围内就开始全面启动IPv6。在中国，移动、联通和电信大范围开展现网IPv6试点。随着IPv6研究工作和实际部署的不断开展，网络迟早会进入纯IPv6（IPv6-only）的时代。目前很多的资源还在IPv4环境中，因此IPv6和IPv4网络之间的互通尤为重要。\n苹果这么急着进入IPv6-only网络领域，估计是想改变一下如今的环境，更好的支持下一代的苹果产品和系统。 在此之前，苹果曾在WWDC2015就率先宣布iOS9会向IPv6-only网络服务过渡，随着IPv4地址用完，转移到地址更丰富的IPv6协议也是大势所趋。\n","date":"2016-05-05T13:50:19Z","permalink":"https://blog.iostao.com/2016/05/ios-require-allappipv6-only/","title":"苹果:所有应用必须支持IPv6-only网络"},{"content":"点击下载代码\n多设备其实和单设备并没有什么太大的变化。至少初级写的时候，只是代码量多了一些。但是后面各种状态还有代码的优化工作挺多。\n@interface CentralManager ()\u0026lt;CBCentralManagerDelegate, CBPeripheralDelegate,CentralManagerDelegate\u0026gt; { /** 这里只做多设备简单介绍。如果设备很多，或者设备不固定，可以考虑使用数组等进行优化 */ CBPeripheral *_devicePeripheral; //硬件设备 (设备1) CBPeripheral *_wristbandPeripheral; //手环设备 (设备2)\nCBCharacteristic *_deviceCharacteristic; //硬件设备服务特征 （用来发送指令） CBCharacteristic *_wristbandCharacteristic; //手环设备服务特征 (发送指令，用来和手环进行数据交换，读取手环数据等) //蓝牙管理类，这就是蓝牙Boss呀，没有他，你就别想做蓝牙 CBCentralManager *_manager; } 这里添加了两个 CBPeripheral *成员变量。 每一个 CBPeripheral对应一个硬件设备，如果硬件过多，建议使用数组进行优化。 如果只是两个设备倒还不会有影响。另外建议使用swift，做起来会更快速一些。\n#pragma mark - \u0026raquo; 发现蓝牙设备\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)advertisementData RSSI:(NSNumber *)RSSI { if (!peripheral.name) { return; } //连接设备可以根据需求，写到两个方法里面，可以根据点击操作分别连接不同的设备。 我这里是直接进行了同时连接 //里面的字符串是硬件设备的名称。 也可以根据 广播等内容进行判断连接 //连接硬件设备 if ([peripheral.name rangeOfString:@\u0026quot;Device\u0026quot;].location != NSNotFound) { [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } //连接手环设备 if ([peripheral.name rangeOfString:@\u0026quot;wristband\u0026quot;].location != NSNotFound) { [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } } #pragma mark - \u0026raquo; 连接成功\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@\u0026quot;连接成功:%@\u0026quot;, peripheral.name); if (_devicePeripheral == peripheral) { _deviceBleState = BleManagerStateConnect; _devicePeripheral = peripheral; }else if (_wristbandPeripheral == peripheral) { _wristbandBleState = BleManagerStateConnect; _wristbandPeripheral = peripheral; } for (id listener in _listener) { if ([listener respondsToSelector:@selector(didConnectDevicePeripheral:)]) { [listener didConnectDevicePeripheral:peripheral]; } } /* 1、连接成功 2、发现服务 3、发现特征值 4、特征值 是用来 和蓝牙设备做交互使用的。如设置设备时间，或者读取设备数据。设置通知等 */ //因为在后面我们要从外设蓝牙那边再获取一些信息，并与之通讯，这些过程会有一些事件可能要处理，所以要给这个外设设置代理 peripheral.delegate = self; //找到该设备上的指定服务 调用完该方法后会调用代理CBPeripheralDelegate（现在开始调用另一个代理的方法了） // [peripheral discoverServices:@[[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]]; // [peripheral discoverServices:@[[CBUUID UUIDWithString:@\u0026quot;7480\u0026quot;]]]; [peripheral discoverServices:nil]; //发现服务 } #pragma mark - \u0026raquo; CBPeripheralDelegate #pragma mark - \u0026raquo; 发现服务\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { if (error == nil) { NSLog(@\u0026quot;发现服务\u0026quot;); for (CBService *service in peripheral.services) { NSLog(@\u0026quot;服务:%@\u0026quot;, service); //发现服务，然后去查找该服务的特征值 ,然后请转到下面的那个代理方法 [peripheral discoverCharacteristics:nil forService:service]; // if ([service.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]) { // //查询服务所带的特征值 // // [peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:@\u0026quot;FFE0\u0026quot;]] forService:service]; // [peripheral discoverCharacteristics:nil forService:service]; // } } } } #pragma mark - \u0026raquo; 发现特征值\n(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { NSLog(@\u0026quot;\u0026mdash;\u0026ndash;发现特征值\u0026quot;); //在这里给 蓝牙设备写数据， 或者将 peripheral 和 characteristic 拿出去，可以在其他地方，发送命令 if (error == nil) { for (CBCharacteristic *characteristic in service.characteristics) {\nNSLog(@\u0026quot;发现特征值:%@\u0026quot;, characteristic); //这里只写了 devicePeripheral 的特征值。 手环的 方法同理，代码几乎一样 if (_devicePeripheral == peripheral) { [peripheral setNotifyValue:YES forCharacteristic:characteristic]; //以下宏定义的UUID 请根据自己当前的硬件设备做调整。 不同的设备会有不同的定义。 //另外，读写的，也会的也会不同。 可以使用 第三方蓝牙工具，进行设备上的服务和特征值查看一下。 //或者是直接参阅 贵公司的蓝牙设备 协议文档 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_1]]) { //如果是指定的特征值，设置NotifyValue [peripheral setNotifyValue:YES forCharacteristic:characteristic]; }else if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_2]]) { _deviceCharacteristic = characteristic; for (id listener in _listener) { if ([listener respondsToSelector:@selector(didDiscoverDevicePeripheral:service:)]) { [listener didDiscoverDevicePeripheral:peripheral service:service]; } } } }else if (_wristbandPeripheral == peripheral) { } } } }\n#pragma mark - \u0026raquo; 如果一个特征的值被更新，然后周边代理接收\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { } #pragma mark - \u0026raquo; 读数据\n//这里是接收到蓝牙数据。 但是蓝牙数据都是一堆 16进制数据，需要根据协议去解析 //数据协议，请参阅协议文档，如果没有，就去找吧。 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSLog(@\u0026quot;接收到数据:%@,%@\u0026quot;, peripheral.name, characteristic.value); } - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSLog(@\u0026quot;did write value For Characteristic\u0026quot;); NSLog(@\u0026quot;%@\u0026quot;, characteristic.value); } - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error { NSLog(@\u0026quot;did Write Value For Descriptor\u0026quot;); } ","date":"2016-04-30T16:51:37Z","permalink":"https://blog.iostao.com/2016/04/ios-bledevelopmultidevice/","title":"iOS-BLE蓝牙开发(二) -- 多设备"},{"content":"iOS开发蓝牙入门 简单来说，iOS蓝牙就是有一个中心角色（可以理解为管理蓝牙的一个对象 CBCentralManager） 就像是创建UITableView一样，需要先初始化 中心角色(CBCentralManager) 既然存在了蓝牙管理对象，那么想要连接蓝牙，一般都是先去搜索设备。所以下一步，搜索设备（暂时不要看代码，先把思路理清楚。下面是代码，会按照这个思路再走一遍）\n搜索到一个设备 - didDiscoverPeripheral\n你就会在delegate方法中，得到这个设备。然后判断，如果这个设置是你需要的，那么就进行连接。如果没有特别情况，这里最好是停止设备搜索，因为你已经找到它了。\n连接自然会有两个结果，所以对应两个代理方法\n连接成功\tdidConnectPeripheral 连接失败\tdidFailToConnectPeripheral 连接成功 在这里去搜索服务，服务里会有特征值。特征值，是用来和蓝牙设备，做读写命令交互用的。\n发现服务 - didDiscoverServices 发现到服务，然后去查找这个服务中的特征值\n发现特征值 - didDiscoverCharacteristicsForService 这里去设置读写数据。或者是把特征值，做一个成员变量接收，这样就可以，选择什么时刻发送命令了。\n获取到蓝牙设备发送过来的数据 - didUpdateValueForCharacteristic 蓝牙数据一般为一堆16进制数据，然后自己根据协议去解析就好了。\n总结中心模式的用法 引入CoreBluetooth.framework 引入蓝牙协议，如 @protocol CBCentralManagerDelegate; @protocol CBPeripheralDelegate; 创建 CBCentralManager //定义一个中心角色对象 @property (strong, nonatomic) CBCentralManager *centralManager; //建立中心角色 _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; //搜索蓝牙设备 [_centralManager scanForPeripheralsWithServices:nil options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; //发现蓝牙设备 - 代理方法 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)advertisementData RSSI:(NSNumber *)RSSI { //这里peripheral 就是搜索到的蓝牙设备对象了。 //advertisementData 是广播消息。 //RSSI 信号强度 //这里名字 我随便写的。可以根据需求，来作判断。比如利用广播判断 if ([peripheral.name isEqualToString:@\u0026quot;小米手环\u0026quot;]) { //连接设备 ， 这里会有 连接成功， 和 连接失败两个代理方法 [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } } #pragma mark - \u0026gt;\u0026gt; 连接成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { [_centralManager stopScan]; //停止扫描 //因为在后面我们要从外设蓝牙那边再获取一些信息，并与之通讯，这些过程会有一些事件可能要处理，所以要给这个外设设置代理 peripheral.delegate = self; //找到该设备上的指定服务 调用完该方法后会调用代理CBPeripheralDelegate（现在开始调用另一个代理的方法了） // [peripheral discoverServices:@[[CBUUID UUIDWithString:@\u0026quot;7480\u0026quot;]]]; //这个是发现所有服务， 上面的是发现指定服务 [peripheral discoverServices:nil]; } #pragma mark - \u0026gt;\u0026gt; CBPeripheralDelegate #pragma mark - \u0026gt;\u0026gt; 发现服务 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { if (error == nil) { NSLog(@\u0026quot;发现服务\u0026quot;); for (CBService *service in peripheral.services) { NSLog(@\u0026quot;服务:%@\u0026quot;, service); //设备 发现所有特征 [peripheral discoverCharacteristics:nil forService:service]; //下面代码，是用来查找特定服务的 特征，如果能确定只用哪个服务的，就可以用下面的方法 //if ([service.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]) { //查询服务所带的特征值 //[peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:@\u0026quot;FFE0\u0026quot;]] forService:service]; //[peripheral discoverCharacteristics:nil forService:service]; // } } } #pragma mark - \u0026gt;\u0026gt; 发现特征值 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { if (error == nil) { for (CBCharacteristic *characteristic in service.characteristics) { NSLog(@\u0026quot;发现特征值:%@\u0026quot;, characteristic); //这个FFE1是我随便写的。需要根据你们自己的硬件给的来填写. if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\u0026quot;FFE1\u0026quot;]]) { //我的这个特征是用来读取数据的。这里设置通知 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; }else if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_2]]) { //给蓝牙设备发送数据， 写数据 [peripheral writeValue:(NSData *) forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse]; } } } }","date":"2016-04-28T16:41:43Z","permalink":"https://blog.iostao.com/2016/04/ios-bledevelop/","title":"iOS-BLE蓝牙开发"},{"content":"\u0026lsquo;init(start:end:)\u0026rsquo; is deprecated: it will be removed in Swift 3. Use the \u0026lsquo;..\u0026lt;\u0026rsquo; operator var continousDigitsRange:Range\u0026lt;Int\u0026gt; = Range\u0026lt;Int\u0026gt;(start: 0, end: 0) Since update to Xcode 7.3 (Swift 2.2) I got the following hint: 'init(start:end:)' is deprecated: it will be removed in Swift 3. Use the '..\u0026lt;' operator. 新方法：\nlet string = \u0026ldquo;Who A U\u0026rdquo; string.substringWithRange(Range(string.startIndex.advancedBy(0) ..\u0026lt; string.startIndex.advancedBy(2)))\ni++ i\u0026ndash; 苹果认为 i++ 和 ++i在代码中容易产生理解错误。所以取消了 自增、自减。 改为 i += 1, 或 i -= 1 for var i = 0; i \u0026lt; 4; i++ for index in 0\u0026hellip;3\nfor index in 0 ..\u0026lt; 4\n//定义数组 var array = [String]()\t或者 let array = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;] for str in array { print(\u0026quot;\\(str)\u0026quot;) } //如果是一个对象数组。比如一个Model -- Person.swift var array = [Person]() 或者 let array = [person1, person2, person3] for person in array { print(\u0026quot;\\(person.name)\u0026quot;) } ","date":"2016-04-28T15:20:01Z","permalink":"https://blog.iostao.com/2016/04/swift3-0newinfofoundin2-2/","title":"swift3.0变化（swift2.2工程中发现）"},{"content":"let insets = UIEdgeInsetsMake(30, 0, 10, 0) //top: CGFloat, _ left: CGFloat, _ bottom: CGFloat, _ right: CGFloat 其中Insets这个参数的格式是 (top, left, bottom, right)，从上、左、下、右分别在图片上画了一道线，这样就给一个图片加了一个框。\n只有在框里面的部分才会被拉伸，而框外面的部分则不会改变。 4个参数是上边界，左边界，下边界，右边界距离，也可以为负值。\nlet image = UIImage(named: \u0026quot;icon.png\u0026quot;) //iOS5之前，端盖(end cap)概念，用来指定图片中的哪一部分不用拉伸。上下左右不需要被拉伸的边缘就称为端盖。\n//iOS5 + 方法 bodyImage.image = image?.resizableImageWithCapInsets(insets) //iOS6 + 方法 bodyImage.image = image?.resizableImageWithCapInsets(insets, resizingMode: UIImageResizingMode.Stretch) resizingMode 用来指定拉伸模式: UIImageResizingMode.Stretch 拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片 UIImageResizingMode.Tile 平铺模式，通过重复显示UIEdgeInsets指定的矩形区域来填充图片 ","date":"2016-04-27T10:53:54Z","permalink":"https://blog.iostao.com/2016/04/uiimage-resizableimagewithcapinsets/","title":"UIImage 拉伸图片 resizableImageWithCapInsets"},{"content":"今天看了淘宝的BUY+ 败家视频之后，感受颇深。身为开发者，我们该如何更新自己的技能，才能在这个圈内立足？时代在召唤，所以本人开始打算逐步深入VR的队伍当中。 然而开始，我们应该学习什么编程语言 或3D引擎（3D Engine），才能适应时代的发展。\nVR 设备分析 让我们先来看看现在的 VR 设备。\n目前主要的 VR 设备有 Oculus , Sumsang Gear VR ， HTC Vive ， Microsoft HoloLens ， Sony PlayStation VR ，国内的 VR 设备则太多，销量较高的有 蚁视 和 暴风魔镜 等等。\nOculus 代表产品： Oculus Rift\n简单介绍： 万众瞩目的 Oculus Rift 已经预售了。简单地说，Oculus Rift 是一个带有部分输入设备的虚拟现实显示器。这些输入设备包括一个遥控器，一个红外传感器，还有 Touch 控制器。Rift 的所有计算是在一台 PC 上进行的，在 Oculus Ready PCs 可以看到 Rift 要求的 PC 配置。由于显卡的性能问题，Rift 目前并不支持 Mac，只能下载到基于 Windows 的 Runtime。 SDK支持： Oculus Rift 支持 Unity 5 、Unity 4 和 Unreal 。3月1日，Oculus 发布了 MobileSDK 1.0.0.1 升级，这个 SDK 提供了对 Oculus Remote Monitor 的支持，同时也让我们可以在 Mac OSX 上基于 MobileSDK 进行开发。\nSamsung 代表产品： Gear VR\n简单介绍： Gear VR 是 Samsung 和 Oculus 共同开发的。它目前使用 Samsung 的 Galaxy S7/S7 edge, Note5, S6, 和 S6 edge 来代替头显中原来的显示器。Gear VR 还内置传感器用于和三星手机配对，并内置了触摸板用于操作。和 Oculus Rift 使用 PC 来进行计算不同，Gear VR 把计算放在了 Samsung 手机上。 SDK支持： Oculus 的 MobileSDK 最开始就是为 Gear VR 提供的。\nHTC 代表产品： Vive 简单介绍： Vive 也已经预售了。它是目前呼声最高的消费级 VR 设备了。Base stations 设计，电子围栏，多功能操纵手柄，StreamVR，良好的体验都让它成为目前最好的 VR 设备。在 VIVE OPTIMIZED PCs 可以看到推荐的 PC 配置，和 Oculus 类似，但不要求 8G 内存 。 SDK支持： Steam VR 、Unity 和 Unreal 。\nMicrosoft 代表产品：HoloLens 简单介绍： M$ 的确是不差钱，一上来就搞出来一个 MR(Mixed Reality) 设备，还让 HeloLens 上了国际空间站 。简单的说，HoloLens 就是一台微型 Windows 10 一体机啊！和竞争对手们完全不是一个打法好么？不在一个纬度好么！硬件我就不说了，直接看 Hardware 好了，简直惊悚。\nSDK支持： 为 HoloLens 开发应用，其实就是为 Windows 10 开发 App ，目前官方页面并没有公布太多的开发信息。但你也知道，IDE 一定是宇宙最强的 Visual Studio，语言一定是 C# 。\nSony 代表产品： PlayStation VR 简单介绍： Sony 大法虽然好，但 PSVR 和上面几家比起来会出来的比较晚，又从 2016 上半年跳票到下半年。它是和 PS4 共同使用的，目前我没有找到它的 SDK。但 Unity 提到了对 PlayStation VR 的支持。\n暴风魔镜 代表产品： 魔镜4 简单介绍： 暴风魔镜是目前在国内大肆宣传的一款产品。暂时还没有哪一款产品的宣传力度超过它。当然，它也是我唯一买过（主要是买得起）的产品。和 Google Cardboard 类似，它是一款把手机塞进去就能体验廉价 VR 的产品。具体的体验效果，取决于手机的高（tu）端（hao）程度。 SDK支持：暴风魔镜提供了 Android/iOS/Unity/Unreal 的 SDK 。\nVR 引擎分析 从上面的设备分析可以看出，目前对 VR 支持最好的 3D 引擎就是 Unity 和 Unreal 了。它们两位可以说是 VR 的标配引擎。借用一句广告词： 2U ，你值得拥有！ 除了 2U 哥俩外，下面还有一些在 VR/AR 界十分活跃的引擎和软件：\nOSVR\nOpen Source Virtual Reality 是一个全面开源的软件平台，支持多种设备和引擎，Blender/MonoGame/StreamVR/Unity/Unreal/CryEngine/WebVR 都在支持之列。在国内，OSVR 已经和 360 公司展开了合作。OSVR是全球的开源虚拟现实平台，由Razer(雷蛇)——全球高性能游戏硬件、软件与系统品牌，以及Sensics——全球专业级虚拟现实头戴式显示器品牌联合创立。该软件平台致力于为所有虚拟现实技术树立开放标准，使得各款支持OSVR的虚拟设备与支持OSVR的软件能够顺利交互、接合。\nOSVR软件\n介绍了这套引擎的架构方式。OSVR能够提供简单而标准化的方式，助你探索、配置和操作数以百计的设备，包括VR眼镜、定位追踪、深度摄像头、眼动议、游戏控制器等等。\nVRPN\nVirtual Reality Peripheral Network 是学术圈搞起来的一套基于网络传输界面的开源 VR 库。允许大家共同建设，把自家的设备加进去。这个库支持非常多的设备，甚至直接包含了设备驱动 Supported hardware devices 。VRPN 已经在 PC/Win32, PC/Cygwin, PC/Linux, and Mac/OSX (32- and 64-bits on all), ARM Linux systems 和 Android 上测试过。\nMiddleVR\nMiddleVR 目前提供 Unity 插件 ，当然你也可以直接使用它的 SDK，它也支持目前大多数主流的 HMD (Head-mounted display）设备。虽然是由一家公司在维护，但目前是免费使用的。\nVRPN Virtual Reality Peripheral Network 是学术圈搞起来的一套基于网络传输界面的开源 VR 库。允许大家共同建设，把自家的设备加进去。这个库支持非常多的设备，甚至直接包含了设备驱动 Supported hardware devices 。VRPN 已经在 PC/Win32, PC/Cygwin, PC/Linux, and Mac/OSX (32- and 64-bits on all), ARM Linux systems 和 Android 上测试过。 MiddleVR MiddleVR 目前提供 Unity 插件 ，当然你也可以直接使用它的 SDK，它也支持目前大多数主流的 HMD (Head-mounted display）设备。虽然是由一家公司在维护，但目前是免费使用的。\nVR 语言 说起 VR 语言，其实还不如说是 3D 引擎的语言。VR 没有 3D 引擎支持是无法进行开发的。让我们看看上面提到的 3D 引擎和 SDK 主要使用什么语言。 首当其冲的是 C/C++ ，这是毋庸置疑的。大多数 3D 引擎都使用 C++ 开发，Oculus 提供的 SDK 也是使用 C++ 进行开发的。 Gear VR 是在安卓设备上运行，需要使用 Android NDK 基于 C++ 进行开发。Unreal 引擎同样使用 C++ 进行开发。MiddleVR 提供了基于 C++ 的 SDK。 其次是 C# 。 Unity 把 C# 当作脚本语言使用。在 VRPN 中可以使用 .NET bindings for VRPN 作为开发语言。不出意外的话， HoloLens 也一定使用的是 C# 。 再次就是 Javascript 。它也是 Unity 的一种脚本语言（即使选择的人并不多）。但 WebVR 和 Javascript 程序员的基数（基友数？）一定会让 Javascript 继续在使用人数上占优（我真的不是黑啊）。即使不考虑 WebVR ， three.js ， Babylonjs 这类已经非常成熟的 HTML5 3D 引擎也足够证明 Javascript 在 3D 上的强大生命力。 VR 平台 从目前的状态看， Oculus 仅支持 Windows 和 Android（通过 Gear VR） 。MiddleVR 仅支持 Windows 平台。其他的几个引擎例如 OSVR/VRPN 都是多平台支持的，Unity 和 Unreal 当然也是多平台支持。Playstation VR 无疑是 PS 独占。HoloLens 则无疑是 Windows 独占。 只有 WebVR ，不挑平台陪你玩。 结语 VR/AR/MR 仍然在如火如荼的发展。以上的技术1~2年后或许会有翻天覆地的变化，领跑者说不定就成了追赶者，黑马也可能随时出现。但总的来说，VR在目前这个阶段的发展，最重要的仍是内容。内容的产出依然离不开程序员，离不开3D引擎和编程语言。作为程序员，只要我们苦练内功，紧跟技术发展的脚步，就不必担心被时代所遗弃。若是不小心搭上了VR时代的快车，或许更容易一飞冲天。 而当下，我们需要一往无前。\n以下个人收集，未入门人员，我也不懂。 c# unity3d 5.x版本 难度较低 未来主流 c++ ue为代表 难度大 人员很难组齐\n你可以想象苹果发布App Store的时候，会有人说它会击垮出租车吗？Uber用了很多年才出现，我觉得VR也将如此，目前我们已经推出了游戏，而且这些游戏体验非常好，五年后可能有人做出完全革命性的东西来填补空白，我们不知道这将是什么样的游戏。\n","date":"2016-04-18T21:00:33Z","permalink":"https://blog.iostao.com/2016/04/ios-vr-journeyoftime/","title":"VR时代之旅"},{"content":"@interface NSObject (NSDelayedPerforming) - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes; - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; @end 最近看到大家对cancelPreviousPerformRequestsWithTarget不能取消带参数的\n(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; 情况，写了一点点代码调试了一下，发现如果是带参数，那取消时的参数也要一致，否则不能取消成功。 开始延迟执行：\n[self performSelector:@selector(didRuninCurrModel:) withObject:[NSNumber numberWithBool:YES] afterDelay:3.0f];\n[self performSelector:@selector(didRuninCurrModelNoArgument) withObject:nil afterDelay:3.0f];\n假如在三秒内执行以下取消方法，则结果分别为：\n[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(didRuninCurrModel:) object:[NSNumber numberWithBool:YES]];//可以取消成功。 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(didRuninCurrModel:) object:[NSNumber numberWithBool:NO]];//不能取消成功。参数不匹配 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(didRuninCurrModel:) object:nil];//不能取消成功。参数不匹配 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(didRuninCurrModelNoArgument) object:nil];//可以成功取消 [NSObject cancelPreviousPerformRequestsWithTarget:self];//可以成功取消全部。 [[self class] cancelPreviousPerformRequestsWithTarget:self];//可以成功取消全部。 ","date":"2016-04-11T14:34:31Z","permalink":"https://blog.iostao.com/2016/04/ios-cancel-performselector-and-cancelpreviousperformrequestswithtarget/","title":"IOS 关于取消延迟执行函数的种种。performSelector与cancelPreviousPerformRequestsWithTarget"},{"content":"版本2：增加了Swift 2.0的语法，与Swift 1.2的语法相比，主要是：advance方法变成了advancedBy方法（但不是简单替换）；没有了count方法，count(str)需要变成str.characters.count等。\n字符串的定义\nvar str1=\u0026quot;hello, mandarava.\u0026quot; //字符串变量 let str2=\u0026quot;hello, mandarava.\u0026quot; //字符串常量 let str3=\u0026quot;\u0026quot; //空字符串 let str4=String() //空字符串 字符的定义\nvar char1:Character=\u0026quot;m\u0026quot; //字符变量 let char2:Character=\u0026quot;m\u0026quot; //字符常量 字符串的连接\nlet str1=\u0026quot;hello, \u0026quot; let str2=\u0026quot;mandarava.\u0026quot; let str3=str1+str2 //=连接str1、str2 //str3=\u0026quot;hello, mandarava.\u0026quot; //---------------------------------------- let str4=\u0026quot;\\(str1)\\(str2)\u0026quot; //=连接str1、str2 //str4=\u0026quot;hello, mandarava.\u0026quot; //---------------------------------------- let strArray=[\u0026quot;apple\u0026quot;, \u0026quot;orange\u0026quot;, \u0026quot;cherry\u0026quot;] let joinStr=\u0026quot;,\u0026quot;.join(strArray) //joinStr=\u0026quot;apple,orange,cherry\u0026quot; 字符串与字符的连接\nlet char1:Character=\u0026quot;o\u0026quot; var str1=\u0026quot;hell\u0026quot; let str2=str1+String(char1) //str2=\u0026quot;hello\u0026quot; //---------------------------------------- let str3=\u0026quot;\\(str1)\\(char1)\u0026quot; //str3=\u0026quot;hello\u0026quot; //---------------------------------------- str1.append(char1) //str1=\u0026quot;hello\u0026quot; 字符串与其它类型值的连接\nlet xx=10 let yy=10.8 let str1=\u0026quot;\\(xx)+\\(yy)=?\u0026quot; //str1=\u0026quot;10+10.8=?\u0026quot; //---------------------------------------- let str2=String(format: \u0026quot;%i+%.1f=?\u0026quot;, xx, yy) //str2=\u0026quot;10+10.8=?\u0026quot; 字符串枚举字符\n//Swift 1.2 let str=\u0026quot;mandarava\u0026quot; for ch in str{ println(ch) } //----------------------- //Swift 2.0 let str=\u0026quot;mandarava\u0026quot; for ch in str.characters{ print(ch) } 获取字符串中指定索引处的字符\nlet str=\u0026quot;Mandarava\u0026quot; let chr=str[advance(str.startIndex,2)] //Swift 1.2 //chr:Character=\u0026quot;n\u0026quot; let chr=str[str.startIndex.advancedBy(2)] //Swift 2.0 //chr:Character=\u0026quot;n\u0026quot; 计算字符串长度length\nlet str=\u0026quot;@Tao\u0026quot; let len1=count(str) //swift 1.2 //=4 let len2=str.characters.count //swift 2.0 //=4 let blen=str.lengthOfBytesUsingEncoding(NSUTF8StringEncoding) //=10 字符串比较\nlet str1=\u0026quot;hello,\u0026quot; let str2=\u0026quot;mandarava.\u0026quot; let str3=\u0026quot;hello,mandarava.\u0026quot; let comp1 = str1==str2 //false let comp2 = str1+str2 == str3 //true let comp3 = str1 \u0026lt; str2 //true let comp4 = str1 != str2 //true 是否包含子串contains\nlet str1=\u0026quot;hello,mandarava.\u0026quot; let str2=\u0026quot;mandarava\u0026quot; let range=str1.rangeOfString(str2) if range != nil{ //包含 } 查找子串indexof\nvar str=\u0026quot;hi,Mandarava.\u0026quot; let range=str.rangeOfString(\u0026quot;Mandarava\u0026quot;, options: NSStringCompareOptions.allZeros) //Swift 1.2 let range=str.rangeOfString(\u0026quot;Mandarava\u0026quot;, options: NSStringCompareOptions()) //Swift 2.0 let startIndex=range?.startIndex //=3 首字母大写capitalized\nvar str1=\u0026quot;mandarava is a flower.\u0026quot; str1.capitalizedString //str1=\u0026quot;Mandarava Is A Flower. 转换为大写字母uppercase\nvar str1=\u0026quot;hello, mandarava.\u0026quot; str1=str1.uppercaseString //str1=\u0026quot;HELLO, MANDARAVA.\u0026quot; 转换为小写字母lowercase\nvar str1=\u0026quot;HELLO, MANDARAVA.\u0026quot; str1=str1.lowercaseString //str1=\u0026quot;hello, mandarava.\u0026quot; 截取字符串substring\nlet str1=\u0026quot;hello,mandarava.\u0026quot; let str2=str1.substringFromIndex(advance(str1.startIndex, 6)) //Swift 1.2 let str2=str1.substringFromIndex(str1.startIndex.advancedBy(6)) //Swift 2.0 //str2=\u0026quot;mandarava.\u0026quot; //---------------------------------------- let str3=str1.substringToIndex(advance(str1.startIndex, 5)) //Swift 1.2 let str3=str1.substringToIndex(str1.startIndex.advancedBy(5)) //Swift 2.0 //str3=\u0026quot;hello\u0026quot; //---------------------------------------- let range=Range\u0026lt;String.Index\u0026gt;(start: advance(str1.startIndex, 6), end: advance(str1.endIndex, -1)) //Swift 1.2 let range=Range\u0026lt;String.Index\u0026gt;(start: str1.startIndex.advancedBy(6), end: str1.endIndex.advancedBy(-1)) //Swift 2.0 let str4=str1.substringWithRange(range) //str4=\u0026quot;mandarava\u0026quot; 字符串修剪trim\nlet str1=\u0026quot; mandarava.\\n \u0026quot; let str2=str1.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()) //str2=\u0026quot;mandarava.\u0026quot; //---------------------------------------- let str3=str1.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet()) //str3=\u0026quot;mandarava.\\n\u0026quot; //---------------------------------------- let charset=NSCharacterSet(charactersInString:\u0026quot; \\n\u0026quot;) let str4=str1.stringByTrimmingCharactersInSet(charset) //str4=\u0026quot;mandarava.\u0026quot; 字符串的分解子串split\nvar str1=\u0026quot;boy, girl, man, woman\u0026quot; let str1Array=str1.componentsSeparatedByString(\u0026quot;,\u0026quot;) //str1Array=[\u0026quot;boy\u0026quot;, \u0026quot; girl\u0026quot;, \u0026quot; man\u0026quot;, \u0026quot; woman\u0026quot;] var str2=\u0026quot;boy,girl,man 10 20 30\u0026quot; let charset=NSCharacterSet(charactersInString:\u0026quot;, \u0026quot;) let str2Array=str2.componentsSeparatedByCharactersInSet(charset) //str2Array=[\u0026quot;boy\u0026quot;, \u0026quot;girl\u0026quot;, \u0026quot;man\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;30\u0026quot;] 字符串替换replace\nvar str1=\u0026quot;My name is Mandarava.\u0026quot; let subRange=Range(start: str1.startIndex, end: advance(str1.startIndex, 2)) //Swift 1.2 let subRange=Range(start: str1.startIndex, end: str1.startIndex.advancedBy(2)) //Swift 2.0 str1.replaceRange(subRange, with: \u0026quot;Your\u0026quot;) //str1=\u0026quot;Your name is Mandarava.\u0026quot; var str2=\u0026quot;hello, Mandarava.\u0026quot; str2=str2.stringByReplacingOccurrencesOfString(\u0026quot;Mandarava\u0026quot;, withString: \u0026quot;Tao\u0026quot;) //str2=\u0026quot;hello, Tao.\u0026quot; str2=str2.stringByReplacingOccurrencesOfString(\u0026quot;Tao\u0026quot;, withString: \u0026quot;Mandarava\u0026quot;, options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil) //str2=\u0026quot;hello, Mandarava.\u0026quot; string转换为Int/Long/Float/Double/Bool等 var str1=\u0026quot;100\u0026quot; var i=str1.toInt()! //Swift 1.2 //=100 var i=(str1 as NSString).integerValue //Swift 2.0 //=100 var i=(str1 as NSString).intValue //=100 var l=(str1 as NSString).longLongValue //=100 var str2=\u0026quot;10.8\u0026quot; var f=(str2 as NSString).floatValue //=10.8 var d=(str2 as NSString).doubleValue //=10.8 var str3=\u0026quot;true\u0026quot; var b=(str3 as NSString).boolValue //=true 原文链接：http://www.jianshu.com/p/52e7580166ff\n","date":"2016-04-07T13:19:17Z","permalink":"https://blog.iostao.com/2016/04/swift-stringoperation/","title":"Swift字符串常用操作总结"},{"content":"既然像 String 这样的 Swift 的类型和 Foundation 的对应的类是可以无缝转换的，那么我们在使用和选择的时候，有没有什么需要特别注意的呢？\n简单来说，没有特别需要注意的，但是尽可能的话还是使用原生的 String 类型。\n原因有三。\n首先虽然 String 和 NSString 有着良好的互相转换的特性，但是现在 Cocoa 所有的 API 都接受和返回 String 类型。我们没有必要也不必给自己凭空添加麻烦去把框架中返回的字符串做一遍转换，既然 Cocoa 鼓励使用 String，并且为我们提供了足够的操作 String 的方法，那为什么不直接使用呢？\n其次，因为在 Swift 中 String 是 struct，相比起 NSObject 的 NSString 类来说，更切合字符串的 \u0026ldquo;不变\u0026rdquo; 这一特性。通过配合常量赋值 (let) ，这种不变性在多线程编程时就非常重要了，它从原理上将程序员从内存访问和操作顺序的担忧中解放出来。另外，在不触及 NSString 特有操作和动态特性的时候，使用 String 的方法，在性能上也会有所提升。\n最后，因为 String 里的 String.CharacterView 实现了像 CollectionType 这样的接口，因此有些 Swift 的语法特性只有 String 才能使用，而 NSString 是没有的。一个典型就是 for\u0026hellip;in 的枚举，我们可以写：\nlet levels = \u0026quot;ABCDE\u0026quot; for i in levels.characters { print(i) } // 输出： // ABCDE 而如果转换为 NSString 的话，是无法使用 characters 并且进行枚举的。\n不过也有例外的情况。有一些 NSString 的方法在 String 中并没有实现，一个很有用的就是在 iOS 8 中新加的 containsString。我们想使用这个 API 来简单地确定某个字符串包括一个子字符串时，只能先将其转为 NSString：\nif (levels as NSString).containsString(\u0026quot;BC\u0026quot;) { print(\u0026quot;包含字符串\u0026quot;) } // 输出： // 包含字符串 Swift 的 String 没有 containsString 是一件很奇怪的事情，理论上应该不存在实现的难度，希望只是 Apple 一时忘了这个新加的 API 吧。当然你也可以自行用扩展的方式在自己的代码库为 String 添加这个方法。当然，还有一些其他的像 length 和 characterAtIndex: 这样的 API 也没有 String 的版本，这主要是因为 String 和 NSString 在处理编码上的差异导致的。 使用 String 唯一一个比较麻烦的地方在于它和 Range 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：Range\u0026lt;String.Index\u0026gt;。这有时候会让人非常讨厌：\nlet levels = \u0026quot;ABCDE\u0026quot; let indexPositionOne = levels.startIndex.successor() let swiftRange = indexPositionOne ..\u0026lt; indexPositionOne.advancedBy(4) levels.stringByReplacingCharactersInRange(swiftRange, withString: \u0026quot;AAAA\u0026quot;) // 输出： // AAAAA var str = \u0026quot;1234567890\u0026quot; let subRange = Range(start: str.endIndex.advancedBy(-5), end: str.endIndex.advancedBy(-1))\tstr.replaceRange(subRange, with: \u0026quot;Your\u0026quot;) print(\u0026quot;\\(str)\u0026quot;) //输出: //12345Your0 //如果这里的-1改为 //0. 输出为12345Your //-1. 输出为12345Your0 //-2. 输出为12345Your90 //-3. 输出为12345Your890 //-4. 输出为12345Your7890 //-5. 输出为12345Your67890 //-6. Crash 自己找一下规律吧 一般来说，我们可能更愿意和基于 Int 的 NSRange 一起工作，而不喜欢使用麻烦的 Range\u0026lt;String.Index\u0026gt;。这种情况下，将 String 转为 NSString 也许是个不错的选择（既然选择了swift，个人建议还是多去研究swift）：\nlet nsRange = NSMakeRange(1, 4) (levels as NSString).stringByReplacingCharactersInRange( nsRange, withString: \u0026quot;AAAA\u0026quot;)","date":"2016-04-07T13:03:18Z","permalink":"https://blog.iostao.com/2016/04/swift-stringornsstring/","title":"String还是NSString"},{"content":"1.导出crash log\n通过Xcode的Organizer查看某台iphone设备的DeviceLog，选择需要的crash log，导出XXX.crash文件。\n2.找到对应的app文件\n找到当前iphone设备上安装的ipa文件，右键解压后得到Payload文件夹，你需要的app文件就在其中了。\n3.找到对应build版本的dSYM文件\n路径: /用户/用户名(修改为自己电脑的用户名)/资源库/Developer/Xcode/Archives/\ndSYM文件是iOS编译后保存16进制函数地址映射信息的文件，每次应用程序build后，都会生成对应的xxx.app, xxx.app.dSYM文件。\n4.确定dSYM、app以及crash文件的关系\n每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。 查看xx.app文件的uuid的方法，在terminal中输入命令：\ndwarfdump \u0026ndash;uuid xxx.app/xxx (xxx工程名)\n查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：\ndwarfdump \u0026ndash;uuid xxx.app.dSYM (xxx工程名)\n而.crash的uuid位于，crash日志中的Binary Images:中的第一行尖括号内。如：\narmv7 \u0026lt;8bdeaf1a0b233ac199728c2a0ebb4165\u0026gt; 将对应的xxx.app.dSYM文件以及xxx.app文件以及xxx.crash文件拷贝到同一文件夹中，如：~/Desktop/DebugLog。\n5.通过symbolicatecrash分析crash文件\nXcode有自带的symbolicatecrash工具,可以通过dSYM文件将crash文件中的16进制地址转换成可读的函数地址。symbolicatecrash工具位于: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKit.framework/Versions/A/Resources/symbolicatecrash(Xcode 4.5) /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash(Xcode 5.0) 该文件是隐藏文件，可以通过如下命令查找并拷贝到系统目录下，并建立快捷方式。\n1)打开终端，进入到symbolicatecrash工具所在的文件夹目录\ncd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/\n2)查找确认是否存在symbolicatecrash\nls -al | grep symbolicatecrash\n3)将symbolicatecrash工具拷贝到/usr/bin目录下\nsudo cp symbolicatecrash /usr/bin/symbolicatecrash\n4)设置DEVELOPER_DIR系统变量\ncd ~/\nvi .bash_profile\n并输入如下内容 export DEVELOPER_DIR=\u0026quot;/Applications/Xcode.app/Contents/Developer\u0026quot;\n保存并退出\nsource .bash_profile\n5)重启终端，确认是否已正确设置DEVELOPER_DIR系统变量\necho $DEVELOPER_DIR\n查看输出结果是否为/Applications/Xcode.app/Contents/Developer\n6)查看PATH系统变量是否存在如下路径/usr/bin\necho $PATH\n7)如果PATH不存在如下路径/usr/bin，可在~/.bash_profile中添加如下代码\nexport PATH=\u0026quot;/usr/bin:$PATH\u0026quot;\n保存并退出\nsource .bash_profile\n8)上述准备工作完成后，进入dSYM和crash文件对应的文件夹目录，如\ncd ~/Desktop/DebugLog\n9)执行如下命令，即可正确解析crash文件\nsymbolicatecrash xxx.crash xxx.app.dSYM \u0026gt; test.txt\n注意：symbolicatecrash的参数顺序，否则会报类似如下错误\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 678.\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 681.\nUse of uninitialized value $data in substitution (s///) at /usr/bin/symbolicatecrash line 685.\nUse of uninitialized value in pattern match (m//) at /usr/bin/symbolicatecrash line 404.\nUse of uninitialized value in scalar assignment at /usr/bin/symbolicatecrash line 418.\nNo crash report version in XXX.app.dSYM/ at /usr/bin/symbolicatecrash line 954.\n","date":"2016-04-01T17:20:34Z","permalink":"https://blog.iostao.com/2016/04/ios-dsymanalysecrash/","title":"iOS通过dSYM文件分析crash"},{"content":"至2016年iPhone出生已有9年之久，给我们手机市场带来了巨大的改变，近年来iPhone在产品方面有哪些改变呢？本期专题带你回顾iPhone – iPhone6s。\n","date":"2016-03-24T20:50:34Z","permalink":"https://blog.iostao.com/2016/03/ios-developmenthistoryofapple/","title":"苹果手机发展史"},{"content":"OSI/RM (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型\n应用层 Application layer 表示层 Presentation layer 会话层 Session layer 传输层 Transport layer 网络层 Network layer 数据链路层 Data link layer 物理层 Physical layer 用图说话\n","date":"2016-03-23T07:17:48Z","permalink":"https://blog.iostao.com/2016/03/aps-osi_tcp-ip/","title":"OSI、TCP/IP"},{"content":"计算机专业词汇 reuse 重用，复用 recall\tcallback 回调 override 重写 recursion 递归 encapsulation 封装 inheritance\t继承 interface 接口 delegationg 委托 entity 实体 schema n.模式，概要，图表 scheme\tn.方案 relational schema 关系模式 design 设计 optimize vt.使最优化，使尽可能有效 redundancy 冗余 Redundant adj.冗余\t的 abnormal\t异常 interface 接口 host\t主机 Atomic 原子的，原子能的；微粒子的 relation model 关系模式 durable\t持久的\ntwo to the fourth power 2的4次方 message\t报文 frame\t框架，帧 SQL Data\t数据 Data Base\t数据库 Data Base Management System (DBMS)\t数据库管理系统 Data Definition Language (DDL) 数据定义语言 Data Manipulation Language (DML) 数据库操作语言 （增删查改） Data Base System (DBS) 数据库系统 Data Base Administrator (DBA) 数据库管理员 Schematic diagram of database system\t数据库系统示意图 Security\t安全性 Integrity\t完整性 Concurrency\t并发 Recovery\t恢复 Entity-Relationship Approach (E-R)\t实体-联系方法 Entity\t实体 Attribute\t属性 Relationship\t联系 Relation\t关系 Tuple\t元组 Attribute and Attribute Value\t属性和属性值 Domain\t域 Relation Mode\t关系模式 Key\t键 Candidate Key\t候选键 Primary Key\t主键 Non Primary Key\t非主属性/非键属性 Foreign Key\t外键 Normal Form\t范式 Boyce-Codd Normal Form (BCNF) Boyce-Codd范式 Index\t索引 Cluster Index\t聚集索引 Non-cluster Index\t非聚集索引 algorithms\t运算法则 add / plus\t加 minus\t减 multiplied\t乘 divide\t除 compiler design principles machine language\t机器语言 object program\t目标程序 object code\t目标代码 process\t进程 thread\t线程 queue\t队列 synchrony\t同步 asynchronism\t异步 superclass\t父类 subclass\t子类 ","date":"2016-03-22T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-computervocabulary/","title":"Computer English Vocabulary"},{"content":"Encapsulation 封装 Encapsulation is hide the internal implementation, and stabilize the external interface. It can hide the implementation details and make the code modular.\neg.\npublic int max(int a, int b) { return a \u0026gt; b ? a : b; } int a = max(1, 5); int b = max(10, 15); int max = max(a, b); Inheritance Inheritance can expand the code modular, it used for resue code.\neg.\npublic class Person { String ID; String Name; Boolean Gender; String Birthday; } public class Student extends Person { String SID; String major; String Department; } The Student inherit attributes from the SuperClass -- PersonClass. Polymorphism 1、overload\nThe functions have the same method name, but they have different parameters.\neg.\npublic int max(int a, int b) { return a \u0026gt; b ? a : b; } public int max(int a, int b, int c) { int max = a \u0026gt; b ? a : b; return = max \u0026gt; c ? max : c; } 2、 It just happened in the case of inheritance.\neg.\npublic class Person { String ID; String Name; Boolean Gender; String Birthday; public void introduction() { System.out.println(\u0026quot;My name is \u0026quot; + Name \u0026quot;, my Birthday is \u0026quot; + Birthday + \u0026quot;.\u0026quot;); } } public class Student extends Person { String SID; String major; String Department; //override the function public void introduction() { System.out.println(\u0026quot;My name is \u0026quot; + Name + \u0026quot;.\u0026quot;); } } Delegation The delegation has two functions: one is transmit values, and one is transmit the event. It can reduce the complex of the code.\neg.\npublic class A { B b = new B(); } public class B { //B want to transmit a value to A. //But B can't communicate with A by directory. //so here use the delegation to help transmit value. } ","date":"2016-03-18T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-encapsulation-inheritance-polymorphism-delegation/","title":"Encapsulation, Inheritance, Polymorphism, Delegation"},{"content":"统一建模语言\n模型种类 十种图形 建模机制 用例模型 用例图 静态建模 静态模型 类图、对象图、包图 静态建模 行为模型 状态图、活动图 动态建模 交互模型 顺序图、协作图 动态建模 实现模型 构件图、配置图 静态建模 ","date":"2016-03-15T17:46:18Z","permalink":"https://blog.iostao.com/2016/03/aps-uml/","title":"APS-UML"},{"content":"What is the Normal Form? Normal Form is a set that with a particular level. （范式是符合某一种级别的关系模式的集合。） Create database must follow certain rules. In the relational database, this rule is the Normal Form. What is the Normal Form used to do? / What is the role of Normal Form? Database that meet these Normal Form are concise and clear stuctured. At the same time, there are no exceptions when insert, delete and update. Generally, the Relationship is divided into 5 Normal Form. 1NF, 2NF, 3NF, Boyce-Codd NF, 4NF, 5NF. In generally, the database only to meet the 3NF. 1NF In any relational database, the 1NF is the basic requirement. If the database that does not meet the 1NF, it isn't a relational database. The 1NF is a non repeating column. * There must have primary key. * Primary key cannot be empty. * The Primary Key can't be repeated * the column can't be divided. StudentNo Name Sex Email Phone 001 LaoTao Mail laotao@m.com 18866688688 2NF Meeting the 2NF must meeting the 1NF. Each non key attribute is not part dependent on the Primary Key attribute. So the main task of the 2NF is to meet the 1NF, and eliminate some dependence of the function. StudentNo Name Sex Email Phone ClassNo classAddress 001 LaoTao Mail lt@m.cn 18866688688 1003 67#A205 This table is fully satisfied with the 1NF. The primary key is consisting of the \u0026quot;StudentNo\u0026quot; and \u0026quot;ClassNO\u0026quot;. But the \u0026quot;ClassAddress\u0026quot; depends on the key(ClassNo -\u0026gt; ClassAddress), so it must be divided into two tables. Table 1\nStudentNo Name Sex Email Phone ClassNo 001 LaoTao Mail lt@m.cn 18866688688 1003 Table 2\nClassNO ClassAddress 1003 67#205 3NF 如果关系模型R是第二范式， 且没有一个非键属性传递依赖于键，则称R是3NF. The 3NF requires a database table does not contain the non primary key information that has benn included in other tables. StudentNo Name Sex Email bounsLevel bouns 001 LaoTao Mail lt@m.cn Good £1000 This table is fully satisfied with the 2NF.But boundsLevel and bounds has a transitive dependency(传递依赖). StudentNo Name Sex Email boundsNo 001 LaoTao Mail lt@m.cn 01 boundsNo bounsLevel bouns 01 Good £1000 I'd love using the boundsNo as the Primary Key, There are two reasons: * 1)don't use the characters as Primary Key. * 2)Generally, use the unrelated key in preference as the primary Key. BCNF Boyce-Codd Normal Formal\n三层模式模型 E-R图 ","date":"2016-03-14T21:36:38Z","permalink":"https://blog.iostao.com/2016/03/aps-sql2005/","title":"APS-SQL2005"},{"content":"(分层，各层作用，协议)\nWhat\u0026rsquo;s the purpose of this course? - basic knowledge of computer network - focus on the structure and behavior of network Details Introduction 简介 - the architecture of newtork is based on different protocols. =\u0026gt; Protocol: an agreement between the communicating parties on how communication is to proceed. - Network Model of hierarchy =\u0026gt; 5 Layers 5 Layers OSI/RM (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型\n5 Layers Function Application Layer message Transport Layer segment Network Layer datagram Data Link Layer frame Physical Layer bit each layer contains several protocals in s sense, each layer offers certain service to the layer above it. each layer communicates with the corresponding(相应的) layer, using specific message header to distinguish(区别). Application Layer 应用层 (HTTP, FTP, SMTP, DNS) * deal with the problems how network applications work and communicate with each other. * famour protocols: - HTTP, HyperText Transfer Protocol =\u0026gt; defines how the web clients ask for web pages and how the server transfer the web pages to clients. - kinds of connection non-persistent connection persistent connection =\u0026gt; won't shut down till specific time. Client Server |\tStart TCP | |----------------\u0026gt;| | | | Confirm | |\u0026lt;----------------| | | | ask for files | |----------------\u0026gt;| | | | get files | |-----------------| |-----------------| HTTP Request request line -\u0026gt;\nGET/HTTP/1.1 | Host: www.devtao.com header line -| connection: close | user-agent: Mozilla / 4.0 |\tAccept-language: cn HTTP Respond:\nstatus line -\u0026gt;\n(status code: 200, 404) header line entity body\nCookie\n=\u0026gt; a special file to distinguish the clients\nSam login to Amazon, PC send cookie 1000 to server, server will store this cookie in the backend database. next time Sam login to Amazon, the server will recognise him.\nFTP, File Transfer Protocol =\u0026gt; Users can upload or download files from the FTP server =\u0026gt; in LAN\nuser \u0026lt;\u0026ndash;\u0026gt; FTP Interface FTP Client \u0026lt;\u0026ndash;\u0026gt; FTP Server II II local file system remote file system 对照下图\n------ --------------- ------------ ------------ | user |\u0026lt;--\u0026gt; | FTP Interface | | FTP Client |\u0026lt;--\u0026gt; | FTP Server | ------ --------------- ------------ ------------ ||\t|| ------------------- -------------------- | local file system | | remote file system | ------------------- -------------------- SMTP (Simple Main Transfer Protocol)\n=\u0026gt; define how the E-mainl system works.\n----------- ----------------- SMTP --------------- | A's agent | -\u0026gt; | A's mail Server | ----\u0026gt; |B's mail Server| ----------- ----------------- --------------- || || ----------- | B's agent | ----------- define the message format =\u0026gt; header\n=\u0026gt; Only ASCII code is legal in SMTP.\nDNS (Domain Name Server Protocol)\n=\u0026gt; use DNS to get the internet IP address.\npeople prefer to rememter the web address, or say URL rather than the IP address. -use DNS to find the corresponding IP address of a specific web URL(Uniform Resource Locator). www.google.com \u0026lt;=\u0026gt; 8.8.8.8\nusing a distributed database. Network A computer network is a group of interconnected computers. Networks may be classified(划分) according to a wide kind of characteristics. The most common division is \u0026ldquo;LAN\u0026rdquo; and \u0026ldquo;WAN\u0026rdquo;.\n\u0026ldquo;WAN\u0026rdquo;(Wide Area Network), is connect computer within a very wide Region. \u0026ldquo;LAN\u0026rdquo;(Local Area Network), is a Network in l limited region and computers belonging to it, will enter the net when they get switched on. Network-Topologys Network toplogy is the study of the arrangement(排列) or mapping(映射) of the elements of a network, especially the physical and logical interconnections between nodes(结点).\nLine-Topology\nBus-Topology\nAll computers are connected in a line. When a line is broken, the whole network doesn\u0026rsquo;t work.\nRing-Topology\nIt\u0026rsquo;s like a Bus or Line Topology and has the same advantages and disadvantages.\nStar-Topology\nIn Star-Topology, all computers are connected to Central-Stations like Hub, Switch or Router. This topology is very quick and safe and also easy to maintenance.\n","date":"2016-03-13T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-network/","title":"APS-Network"},{"content":"毛爷爷说过，不能打无准备的仗。\n复习时，可按照下面的方针进行知识点的整理：\n1、必修类课程每门课提炼3-4个知识点，4个最优 2、选修课课程每门课提炼2-3个知识点，3个最优 3、其他课程一句话，讲清楚学了啥干了啥就行 课程复习 C语言 (数组、结构、指针) 编程语言 （语言分类[机器，汇编，高级], 共同点，不同点，OOP, 流程图） 数据结构 （顺序表、链表、队列和栈、树、图） 数字逻辑 （逻辑门、卡诺图） 数据库原理 （三层模式模型、关系数据库、E-R图、范式）（事务原子最好也看一下） 计算机网络 （网络分层模型、DNS、TCP三次握手、UDP） 计算机组成原理 （CPU内部结构、存储分层结构、寻址） 计算机操作系统 （进程状态图，死锁及其解决方法，虚拟存储器） 计算机系统结构 （流水线结构、实现、可能出现的问题以及解决方法） 编译原理 （词法分析、语法分析、语义分析） 自我介绍 自我介绍方面，在准备时一定要包括下面几个方面，尽量精简（否则据说红灭这种审核官可能会很不耐烦） 1、姓名 2、年龄+年纪 3、来自哪所院校 4、专业 留学计划 留学计划这也是一个多半会被问到的问题，一定要事先想清楚大概的计划，比如城市、学校、每个月生活费等等 （英审的注意。 Notice: 你为什么不用德语来面试？ （红灭可能问到的蛋疼的问题))\n","date":"2016-03-12T06:37:24Z","permalink":"https://blog.iostao.com/2016/03/aps-start/","title":"APS-Start"},{"content":"1.单线程：禁用所有的mutex锁，并发使用时会出错。当SQLite编译时加了SQLITE_THREADSAFE=0参数，或者在初始化SQLite前调用sqlite3_config(SQLITE_CONFIG_SINGLETHREAD)时启用。\n2.多线程：只要一个数据库连接不被多个线程同时使用就是安全的。源码中是启用bCoreMutex，禁用bFullMutex。实际上就是禁用数据库连接和prepared statement（准备好的语句）上的锁，因此不能在多个线程中并发使用同一个数据库连接或prepared statement。当SQLite编译时加了SQLITE_THREADSAFE=2参数时默认启用。若SQLITE_THREADSAFE不为0，可以在初始化SQLite前，调用sqlite3_config(SQLITE_CONFIG_MULTITHREAD)启用；或者在创建数据库连接时，设置SQLITE_OPEN_NOMUTEX flag。\n3.串行：启用所有的锁，包括bCoreMutex和bFullMutex。因为数据库连接和prepared statement都已加锁，所以多线程使用这些对象时没法并发，也就变成串行了。当SQLite编译时加了SQLITE_THREADSAFE=1参数时默认启用。若SQLITE_THREADSAFE不为0，可以在初始化SQLite前，调用sqlite3_config(SQLITE_CONFIG_SERIALIZED)启用；或者在创建数据库连接时，设置SQLITE_OPEN_FULLMUTEX flag。\n在iOS上，默认使用的是第2种方式编译的，也就是只有一个线程能够打开数据库操作，其他线程要操作数据库必须等数据库关闭后才能打开操作。多线程时：每个线程独立打开数据库，操作数据库，操作完后关闭数据库。打开和关闭都比较费时间，而且要手动控制打开关闭锁，在每个线程操作不频率时可用该方法。\n如果多个线程频繁操作数据库，使用以上方法很容易造成系统崩溃，解决方案：开启第3种串行模式，使用一个类（单例方式）操作数据库。 -(BOOL)open { sqlite3_shutdown(); NSLog(@\u0026quot;sqlite3 lib version: %s\u0026quot;, sqlite3_libversion()); int err=sqlite3_config(SQLITE_CONFIG_SERIALIZED); if (err == SQLITE_OK) { NSLog(@\u0026quot;Can now use sqlite on multiple threads, using the same connection\u0026quot;); } else { NSLog(@\u0026quot;setting sqlite thread safe mode to serialized failed!!! return code: %d\u0026quot;, err); } err = sqlite3_open([VersionDBPath UTF8String], \u0026amp;hSqlite3DB); if(err != SQLITE_OK) { NSLog(@\u0026quot;datebase open error: %d\u0026quot;, err); return NO; } return YES; }","date":"2016-03-11T11:56:53Z","permalink":"https://blog.iostao.com/2016/03/ios-sqlitemultithreading/","title":"iOS上Sqlite多线程问题"},{"content":"在bitbucket上使用https协议，经常会在提交代码的时候出错，让人很着急上火，但是用ssh就要方便很多。\n下面介绍一下设置ssh的方法：\n1.在终端中运行ssh-keygen。\n2.然后一路enter，直接到结束。不要理会中间的输入。\n3 打开用户目录下.ssh/id_rsa.pub文件，复制其内容。(服务器操作，可以用vi打开，进行复制) 4.Bitbucket上点右上角的小头像，然后选择Manage account.\n5.左边目录选择SSH Keys， 然后选择add key。将刚才复制的内容粘贴进去，保存。\n回到工程页面，将使用的协议选择为SSH。\n现在就可以使用SSH了。\n","date":"2016-02-21T12:43:34Z","permalink":"https://blog.iostao.com/2016/02/git-deploy-ssh-of-bitbucket/","title":"如何配置Bitbucket的ssh"},{"content":"版权声明：本文为博主原创文章，未经博主允许不得转载。\nUITesting中文出错 今天使用UITesting， 遇到中文内容，就会报错，经过各种尝试，目前找到了一个解决方法，但是仍然还是比较麻烦，对于这种内容，各种途径查找，尚未找到更优的解决方法。以下是问题和解决方法。\n如图，所有中文的内容，在脚本内都显示为 unicode编码形式。无奈，采取了转义字符，如下图所示\n至少双引号内的已经是字符串类型了。然后运行一下脚本，发现不通过。所以尝试一下手动进行文字输入，如下图：\n执行脚本，发现成功。\n唯一遗憾的是，并没有找到更好的解决办法，也没有大牛那种专研的技术和坚韧去继续寻找完美的解决方案。\n","date":"2016-02-19T11:35:23Z","permalink":"https://blog.iostao.com/2016/02/swift-uitesting-chinesewordserror/","title":"UITesting中文错误问题"},{"content":"版权声明：本文为博主原创文章，未经博主允许不得转载。 最近才注意到NSArray,NSDictionary,NSNumber有一种字面量方式声明。瞬间感觉写代码又省了好多事情。\n只是百度了一下，从Xcode4.4就已经存在这种方式了，但是自己居然一直在使用Previously那些方法。\n于是现在在这里做一次整理，方便自己记忆（其实是当初说要写博客，但是好久没写了，来补个数量尴尬)\n借鉴:http://cocoaheads.tumblr.com/post/17757846453/objective-c-literals-for-nsdictionary-nsarray\n也看了一下官方文档，但是上面那个链接给的非常详细。大家如果有愿意看的话，看上面那个地址就可以了，以下，只是为了自己学习。\nObjective-C literals: one can now create literals for NSArray, NSDictionary, and NSNumber (just like one can create literals for NSString)\nString Value\nstring_value ::= \u0026ldquo;text\u0026rdquo; | \u0026rsquo;text'\nNSArray:\nPreviously:\narray = [[NSArray alloc] initWithObjects: a, b, c, nil ];\narray = [NSArray arrayWithObjects: a, b, c, nil ];\nNow: array = @[ a, b, c ];\nNSDictionary:\nPreviously:\nNSDictionary *dict;\ndict = [[NSDictionary alloc] initWithObjectsAndKeys:@[ o1, o2, o3 ],@[ k1, k2, k3 ], nil ];\ndict = [NSDictionary dictionaryWithObjects:@[ o1, o2, o3] forKeys:@[ k1, k2, k3]];\nNow:\ndict = @{ k1 : o1, k2 : o2, k3 : o3 };\nNSNumber:\nPreviously:\nNSNumber * number;\nnumber = [NSNumber numberWithInt:12345];\n//同理，这种初始化还有Char,Long,Float,Double,Bool等类型，不再一一列举\nNow:\nNSNumber *number;\nnumber = @\u0026lsquo;X\u0026rsquo;;\nnumber = @12345;\nnumber = @12345ul;\nnumber = @12345ll;\nnumber = @123.45f;\nnumber = @123.45;\nnumber = @YES;\n","date":"2016-02-17T15:59:01Z","permalink":"https://blog.iostao.com/2016/02/ios-objective-c-literal-value/","title":"字面量声明方式 Objective-C Literal Value"},{"content":"Sqlite Error 版权声明：本文为博主原创文章，未经博主允许不得转载。\n做iOS开发，今天写数据库，遇到了这个错误。我的数据库w中有个字段也是token。刚开始以为是这个字段出了什么问题，不过后来排查，发现跟这个字段完全没有关系。这个就是sqlite3里的。（特此记录一下）\n错误日志截图 NSString *sql_select = [NSString stringWithFormat:@\u0026ldquo;select * from %@ where uid = %@ and dev_id = %@\u0026quot;,TBNAME_User_Dev, uid, device.nameOrAddress];\n原代码是这样写的。解决方法是在 uid , dev_id 的两个参数 上 加上 单引号(这两个是字符类型变量)。\nNSString *sql_select = [NSString stringWithFormat:@\u0026ldquo;select * from %@ where uid = \u0026lsquo;%@\u0026rsquo; and dev_id = \u0026lsquo;%@\u0026rsquo; \u0026ldquo;,TBNAME_User_Dev, uid, device.nameOrAddress];\n倘若使用这种方法写，就不需要加 引号了。这种使用 ? 问号的，就没有碰到这种问题。\nNSString *str = [NSString stringWithFormat:@\u0026ldquo;insert into %@(uid, dev_id, created_at, status) values (?, ?, ?, ?)\u0026quot;,TBNAME_User_Dev];\n","date":"2016-02-17T14:52:50Z","permalink":"https://blog.iostao.com/2016/02/ios-db-error-1-unrecognized-token/","title":"DB Error 1 unrecognized token"},{"content":" # Git Overview Git Profile\n1)远程仓库相关命令 检出仓库：$ git clone git://github.com/jquery/jquery.git\n查看远程仓库：$ git remote -v 获取远程分支信息到本地：$ git fetch (查看远程分支显示不全时，执行这个命令) 添加远程仓库：$ git remote add [name] [url] 删除远程仓库：$ git remote rm [name] 拉取远程仓库：$ git pull [remoteName] [localBranchName] 推送远程仓库：$ git push [remoteName] [localBranchName] 2)分支(branch)操作相关命令 查看本地分支：$ git branch 查看远程分支：$ git branch -r 创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支 切换分支：$ git checkout [name] 创建新分支并立即切换到新分支：$ git checkout -b [name] 迁出远程分支\t$ git checkout -b dev origin/dev 删除分支：$ git branch -d [name] -d 选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name] 删除远程分支：$ git push origin --delete [name] $ git push origin :[name] 列出分支图 git config --global alias.lg \u0026quot;log --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit --date=relative\u0026quot; git lg (设置了别名后，就可以使用别名进行查看) 3）版本(tag)操作相关命令 查看版本：$ git tag 创建版本：$ git tag [name] 删除版本：$ git tag -d [name] 查看远程版本：$ git tag -r 创建远程版本(本地版本push到远程)：$ git push origin [name] 删除远程版本：$ git push origin :refs/tags/[name] 拉取tag版本：git checkout -b branch_name tag_name 4) 子模块(submodule)相关操作命令 添加子模块：$ git submodule add [url] [path] 初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下 删除子模块：$ git rm --cached [path] 5）忽略一些文件、文件夹不提交 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 target, bin, *.db,\n代码提交 命令操作详情:\n1、查看修改文件 git status 2、暂存修改的文件 git add . 3、提交已暂存的文件 git commit 4、拉取远程修改内容 git pull -p 如果有冲突，这里修改，修改之后，从1步骤重新开始 5、提交代码到远程分支 git push 如果没有创建远程分支， 则使用如下命令 git push origin 分支名 //如果是从远程分支拉取的，但是没有建立关系，使用以下命令 git branch --set-upstream my_branch origin/my_branch 以下内容比较多，不容易理解\n代码提交一般有五个步骤：\n1.查看目前代码的修改状态\n2.查看代码修改内容\n3.暂存需要提交的文件\n4.提交已暂存的文件\n5.同步到服务器\ngit config --global push.default matching git config --global push.default simple 建立关系\ngit branch --set-upstream my_branch origin/my_branch 1. 查看目前代码的修改状态 提交代码之前，首先应该检查目前所做的修改，运行git status命令\na) 已暂存 （changes to be committed）\nnew file //表示新建文件\nmodified //表示修改文件\ndeleted //表示删除文件\nb) 已修改 （changed but not updated）\nmodified //表示修改文件\ndeleted //表示删除文件\n另外，git 给出了可能需要的操作命令，git add/rm, gitcheckout -- c) 未跟踪 （untracked files）\n2. 查看代码修改的内容 git diff 比较某文件与最近提交节点的差异。\n注意：如果该文件已暂存，那么应该使用git diff –cached\ngit diff 比较某文件在提交节点a，节点b的差异。\n技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。（也可以利用^运算符）\n3. 暂存需要提交的文件 如果是新建的文件\n则git add 如果是修改的文件\n则git add 如果是删除的文件\n则 git rm 4. 提交已暂存的文件 git commit 注意注释填写规范。 git commit --amend 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。 5. 同步到服务器 同步到服务器前先需要将服务器代码同步到本地\n命令： git pull 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 命令：git checkout \u0026ndash; \u0026lt;有冲突的文件路径\u0026gt;\n同步到服务器\n命令： git push origin \u0026lt;本地分支名\u0026gt; 远程如果暂时没有分支（即初始，没有master分支），同步本地master分支到远程\ngit push -u origin master 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。\n新仓库处理 $ touch README.md $ git init $ git add README.md $ git commit -m \u0026quot;first commit\u0026quot; $ git remote add origin https://github.com/****.git $ git -u origin master 未整理 git remote prune origin\ngit pull\ngit branch -a\ngit tag git clone https://xxx.xx.xx \u0026ndash;depth 1 ","date":"2016-02-16T11:49:03Z","permalink":"https://blog.iostao.com/2016/02/git-command/","title":"Git命令"}]
[{"content":"转载\n使用brew 安装node 首先先对 brew 进行检查 brew update brew doctor 创建目录，并修改权限 因为权限问题，我这里是手动创建的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 sudo mkdir /usr/local/Cellar sudo chown -R $(whoami) /usr/local/Cellar sudo mkdir /usr/local/opt sudo chown -R $(whoami) /usr/local/opt/ sudo mkdir /usr/local/opt/icu4c sudo chown -R $(whoami) /usr/local/opt/ sudo mkdir /usr/local/include sudo chown -R $(whoami) /usr/local/include/ sudo mkdir /usr/local/share sudo chown -R $(whoami) /usr/local/share 然后进行安装 brew link node brew uninstall node brew install node 我这里失败了啊 1 2 3 4 5 node -v dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.67.dylib Referenced from: /usr/local/bin/node Reason: image not found zsh: abort node -v 1 2 3 4 5 6 7 8 9 brew uninstall --force node brew uninstall icu4c \u0026amp;\u0026amp; brew install icu4c brew unlink icu4c \u0026amp;\u0026amp; brew link icu4c --force # 这里可能会提示设置 ~/.zshrc。 看底部 icu4c ~/.zshrc 这个模块 echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc # 如果执行了上面那条命令，需要更新资源文件 source ~/.zshrc brew install node icu4c ~/.zshrc If you need to have icu4c first in your PATH run:\n1 2 echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc echo \u0026#39;export PATH=\u0026#34;/usr/local/opt/icu4c/sbin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc For compilers to find icu4c you may need to set:\n1 2 export LDFLAGS=\u0026#34;-L/usr/local/opt/icu4c/lib\u0026#34; export CPPFLAGS=\u0026#34;-I/usr/local/opt/icu4c/include\u0026#34; 常用命令 npm install \u0026lt;module\u0026gt; //安装 npm uninstall \u0026lt;module\u0026gt; //卸载 npm search \u0026lt;module\u0026gt; //搜索 npm update \u0026lt;module\u0026gt; //更新 npm npm 是node.js自带的功能。\n","date":"2021-01-24T14:43:16Z","permalink":"https://blog.iostao.com/2021/01/mac-brew-install-node_npm/","title":"brew 安装 node 及 npm用法"},{"content":"一、安装 Commitizen 工具 需要提前安装node。\n1. 安装 commitizen node 模块 npm install -g commitizen 2. 初始化 commitizen 的适配器 cz-customizable npm install -g cz-customizable 3. 安装生成log日志的模块 npm install -g conventional-changelog-cli 报错可以重新执行命令尝试一下\n1 2 3 4 5 6 7 8 9 10 npm ERR! code ECONNRESET npm ERR! network aborted npm ERR! network This is a problem related to network connectivity. npm ERR! network In most cases you are behind a proxy or have bad network settings. npm ERR! network npm ERR! network If you are behind a proxy, please make sure that the npm ERR! network \u0026#39;proxy\u0026#39; config is set properly. See: \u0026#39;npm help config\u0026#39; npm ERR! A complete log of this run can be found in: npm ERR! /Users/tao/.npm/_logs/2021-01-23T10_12_59_442Z-debug.log 二、使用 1. 生成 package.json # cd 到项目目录，执行命令 $ npm init #然后根据提示填写相关的项目信息 #完成后会生成package.json 2. 在 package.json中添加脚本 在 scripts中添加：\n$ \u0026quot;changelog\u0026quot;: \u0026quot;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026quot; 1 2 3 4 5 #不会覆盖以前的 Change log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动 $ conventional-changelog -p angular -i CHANGELOG.md -s # 生成所有发布的 Change log，会覆盖以前的 Change log $ conventional-changelog -p angular -i CHANGELOG.md -w -r -s 0 示例如下：\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; }, 这个脚本可以在通过在终端输入 npm run changelog 生成 CHANGELOG.md 日志文档。\n2. 加载node_modules依赖组件 (cz) $ commitizen init cz-conventional-changelog —save —save-exact 执行完以后，项目中就可以一律使用 git cz 代替 git commit来提交代码。\n同时会显示type选项来自动生成符合格式的 commit message。\n三、代码提交 git add . git cz\t//使用 git cz 代替之前的 git commit 代码提交流程 1.Select the type of change that you\u0026rsquo;re committing 选择改动类型\n2.What is the scope of this change (e.g. component or file name)? 填写改动范围\n3.Write a short, imperative tense description of the change: 写一个精简的描述\n4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述\n5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n\n6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n\n类型说明\nfeat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi- colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing tests or correcting existing tests build: Changes that affect the build system or external dependencies (example scopes: gulp, brocc oli, npm) ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, Browser Stack, SauceLabs) chore: Other changes that don\u0026rsquo;t modify src or test files revert: Reverts a previous commit 四、Jira 设置gitlab Network配置\n进入要配置的项目，点击设置。（这里和上面那个设置不同，这里是设置项目里的配置）\n往下滑动一点儿，有个保存。保存。保存。不要忘记保存。\n配置 Jira\n","date":"2021-01-23T18:49:03Z","permalink":"https://blog.iostao.com/2021/01/git-commitizen/","title":"Git Commitizen 规范化commit工具"},{"content":"转载来源\n1、删除旧的安装 1 2 3 sudo rm -rf /usr/local/Homebrew sudo rm -f /usr/local/bin/brew sudo rm -rf /usr/local/var/homebrew 2、创建新的安装目录 sudo mkdir /usr/local/Homebrew\n3、下载brew sudo git clone https://mirrors.ustc.edu.cn/brew.git /usr/local/Homebrew 地址可更换为清华源https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git。\n如提示没有git，可通过xcode-select \u0026ndash;install安装。\n4、创建执行文件链接 sudo mkdir /usr/local/bin sudo ln -s /usr/local/Homebrew/bin/brew /usr/local/bin/brew 5、创建brew-core目录 sudo mkdir -p /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core 6、下载brew-core sudo git clone https://mirrors.ustc.edu.cn/homebrew-core.git /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core 地址可更换为清华源https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git。\n7、权限配置 1 2 3 sudo mkdir -p /usr/local/var/homebrew sudo chown -R $(whoami) /usr/local/var/homebrew sudo chown -R $(whoami) /usr/local/Homebrew 8、执行更新 brew update 提示Already up-to-date即为成功。如有问题可通过brew doctor自检命令检查一下。\n9、设置环境变量\necho 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' \u0026gt;\u0026gt; ~/.zshrc 地址可更换为https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-bottles。 ","date":"2021-01-23T17:22:24Z","permalink":"https://blog.iostao.com/2021/01/mac-brew-install-national/","title":"使用国内源安装 Homebrew"},{"content":"这篇文章是很早以前转载的，这两天做了重新接触的时候，发现了自己碰到的一些问题，然后做了一下修改。\n本文前三部分都是介绍。从第四部分开始是如何安装和使用。\n一、介绍 Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n$ git commit -m \u0026quot;hello world\u0026quot; 上面代码的-m参数，就是用来指定 commit mesage 的。\n如果一行不够，可以只执行git commit，就会跳出文本编译器，让你写多行。\n$ git commit 基本上，你写什么都行，可参考如下文章：\nhttp://www.commitlogsfromlastnight.com\nhttp://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/\nhttp://whatthecommit.com\n但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。\n目前，社区有多种 Commit message 的写法规范(http://whatthecommit.com)。本文介绍Angular 规范（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。\n二、Commit message 的作用 格式化的Commit message，有几个好处。\n2.1 提供更多的历史信息，方便快速浏览。 比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。\n$ git log \u0026lt;last tag\u0026gt; HEAD --pretty=format:%s 2.2 可以过滤某些commit（比如文档改动），便于快速查找信息。 比如，下面的命令仅仅显示本次发布新增加的功能。\n$ git log \u0026lt;last release\u0026gt; HEAD --grep feature 2.3 可以直接从commit生成Change log。 Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。\n三、Commit message 的格式 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; // 空一行 \u0026lt;body\u0026gt; // 空一行 \u0026lt;footer\u0026gt; 其中，Header 是必需的，Body 和 Footer 可以省略。\n不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\n3.1 Header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 （1）type type用于说明 commit 的类别，只允许使用下面7个标识。\nfeat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。\n（2）scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n（3）subject subject是 commit 目的的简短描述，不超过50个字符。\n以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） 3.2 Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\nMore detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。 （1）使用第一人称现在时，比如使用change而不是changed或changes。 （2）应该说明代码变动的动机，以及与以前行为的对比。\n3.3 Footer Footer 部分只用于两种情况。\n3.1.1 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\nBREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. 3.1.2 关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\nCloses #234 也可以一次关闭多个 issue 。\nCloses #123, #245, #992 3.4 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\nrevert: feat(pencil): add 'graphiteWidth' option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit ，其中的hash是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。\n四、Commitizen 安装 4.1 安装 commitizen node 模块 Commitizen是一个撰写合格 Commit message 的工具。 安装命令如下。\n$ npm install -g commitizen 4.2 初始化 commitizen 的适配器 cz-customizable $ npm install -g cz-customizable 4.3 安装生成log日志的模块 $ npm install -g conventional-changelog-cli 4.4 初始化 cd 到项目目录，执行命令以下命令，然后根据提示填写相关的项目信息\n完成后会在项目目录下生成package.json\n$ npm init 4.5 commitizen init 在项目目录里，运行下面的命令，使其支持Angular的 Commit Message 格式。\n$ commitizen init cz-conventional-changelog-cli —save —save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。\nLaoTao@taobotongdeMacBook-Pro:~/Documents/CIM/cim-ios$ git add . LaoTao@taobotongdeMacBook-Pro:~/Documents/CIM/cim-ios$ git cz cz-cli@2.5.0, cz-conventional-changelog@1.1.5 Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters. ? Select the type of change that you're committing: (Use arrow keys) ❯ feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug or adds a feature perf: A code change that improves performance (Move up and down to reveal more choices) 五、validate-commit-msg validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。\n它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。\n接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行。\n\u0026quot;config\u0026quot;: { \u0026quot;ghooks\u0026quot;: { \u0026quot;commit-msg\u0026quot;: \u0026quot;./validate-commit-msg.js\u0026quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。\n$ git add -A $ git commit -m \u0026quot;edit markdown\u0026quot; INVALID COMMIT MSG: does not match \u0026quot;\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt;\u0026quot; ! was: edit markdown 六、生成 Change log 6.1 生成 change log日志 如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。\n例1：https://github.com/karma-runner/karma/blob/master/CHANGELOG.md\n例2：https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md\n生成的文档包括以下三个部分。\nNew features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\nconventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。\n（这个工具我们上面的步骤有安装，这里只是再提示一下，已经安装的，执行第三步即可）\n$ npm install -g conventional-changelog-cli $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -s 0 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。\n如果你想生成所有发布的 Change log，要改为运行下面的命令。\n$ conventional-changelog -p angular -i CHANGELOG.md -w -r -s 0 有的文章里面，命令没有 -s ，每次执行只是在终端打印所有的日志，并没有在本地生成文件。这里需要注意一下。\n6.2 配置changelog生成命令 为了方便使用，可以将生成命令其写入package.json的scripts字段。\n1 $ \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; 示例如下：\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;changelog\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s 0\u0026#34; }, 七、关于日志生成的问题 1 2 3 4 5 6 我自己碰到的问题，增量生成日志文件，发现每一次都会把所有的日志打印出来了。 研究了好久才发现，每一个版本需要设置一个tag才可以。 比如我master分支切出来一个 1.0.0 的分支，修改完合并到 master分支上。 这个时候我需要 git tag v1.0.0 (这个tag名字不能和 分支 1.0.0 相同，不然生成日志的时候会提示错误， 或者是tag名字相同，然后把1.0.0分支删除）。 等我2.0.0 合并的时候，生成log日志，就可以看到日志 文件中，会显示出不同版本的不同提交信息日志了。 ","date":"2020-12-31T11:46:29Z","permalink":"https://blog.iostao.com/2020/12/gitcommit-message-and-change-log/","title":"Git提交的正确姿势：Commit message 和 Change log 编写指南"},{"content":"一、校验数字的表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\u0026#34;*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 二、校验字符的表达式 1 2 3 4 5 6 7 8 9 10 11 12 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%\u0026amp;\u0026#39;,;=?$\\\u0026#34;等字符：[^%\u0026amp;\u0026#39;,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026amp;=]*)?$ 4 手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\\d{8}$ 4.1 var re = /^(1[3-9][0-9]{9})$/;//如： if (re.test(vmData.PHONE) === false) { alert(\u0026#34;手机号格式不正确\u0026#34;); return; } 5 电话号码(\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXXX-XXXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXX\u0026#34;、\u0026#34;XXX-XXXXXXXX\u0026#34;、\u0026#34;XXXXXXX\u0026#34;和\u0026#34;XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7 18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$ 8 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 9 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 10 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 11 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 12 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 13 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 14 钱的输入格式： 15 1.有四种钱的表示形式我们可以接受:\u0026#34;10000.00\u0026#34; 和 \u0026#34;10,000.00\u0026#34;, 和没有 \u0026#34;分\u0026#34; 的 \u0026#34;10000\u0026#34; 和 \u0026#34;10,000\u0026#34;：^[1-9][0-9]*$ 16 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\u0026#34;0\u0026#34;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 17 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 18 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 19 5.必须说明的是,小数点后面至少应该有1位数,所以\u0026#34;10.\u0026#34;是不通过的,但是 \u0026#34;10\u0026#34; 和 \u0026#34;10.2\u0026#34; 是通过的：^[0-9]+(.[0-9]{2})?$ 20 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 21 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 22 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 23 备注：这就是最终结果了,别忘了\u0026#34;+\u0026#34;可以用\u0026#34;*\u0026#34;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 24 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 25 中文字符的正则表达式：[\\u4e00-\\u9fa5] 26 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))27 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 28 HTML标记的正则表达式：\u0026lt;(\\S*?)[^\u0026gt;]*\u0026gt;.*?\u0026lt;/\\1\u0026gt;|\u0026lt;.*? /\u0026gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)29 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 30 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 31 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 32 IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)33 IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) ","date":"2020-06-21T08:06:44Z","permalink":"https://blog.iostao.com/2020/06/ios-js-regular/","title":"常用正则表达式大全--如：数字，字符等"},{"content":"从iOS 13系统开始，开启了App的深色模式的大门。因为AppStore审核指南提出：从2020年4月30日开始，所有提交至App Store的iPhone App都必须使用 iOS 13 SDK或更高版本来构建。以后的app都需要支持暗黑模式了。\n一、暗黑模式 1、 UIUserInterfaceStyle（页面模式的枚举） 1 2 3 4 5 6 @available(iOS 12.0, *) public enum UIUserInterfaceStyle : Int { case unspecified = 0 case light = 1 case dark = 2 } 2、暗黑模式监听： 1 2 3 4 5 6 7 ///监听模式的变化 override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) { super.traitCollectionDidChange(previousTraitCollection) if traitCollection.hasDifferentColorAppearance(comparedTo: previousTraitCollection) { //模式发生变化会回调这里 } } 3、获取当前模式 1 2 3 4 5 6 7 8 9 10 if self.traitCollection.userInterfaceStyle == .dark { // Dark print(\u0026#34;是dark模式、。。。\u0026#34;) } else if self.traitCollection.userInterfaceStyle == .light { // Light print(\u0026#34;是light模式、。。。\u0026#34;) } else { //unspecified print(\u0026#34;是unspecified模式、。。。\u0026#34;) } 二、创建动态颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 extension UIColor { /// 动态颜色 class func color(lightColor: UIColor, darkColor: UIColor) -\u0026gt; UIColor { if #available(iOS 13.0, *) { // UITraitCollection return UIColor { (traitCollection) -\u0026gt; UIColor in //我这里只有两种颜色，所以if，else就可以。如果需要，可以看下面的注释方法 if traitCollection.userInterfaceStyle == .dark { return darkColor } else { return lightColor } //switch traitCollection.userInterfaceStyle { //case .light: //\treturn lightColor //case .dark: //\treturn darkColor //case .unspecified: //\treturn lightColor //如果有需求，这里可以设置 //@unknown default: //\treturn lightColor //} } } return lightColor } } 三、Assets.xcassets Color set/ Image set 1、 设置动态图片。选择右侧第四个标签栏。在下面选择 Appearance，弹出的弹框里，可以根据需求选择 Any, Dark 或 Any, Light, Dary 模式。\n2、设置动态颜色，点击下方的加号，然后选择 Color Set。然后按照设置动态图片的方式，设置动态颜色即可 3、代码的使用 这里只记录颜色，图片的方式还是不变的。\n1 2 3 4 5 6 7 8 //Color Set是ios \u0026gt;= 11才能使用的，如果app仍然支持 iOS 11以下的，需要判断。 //如果支持版本 \u0026gt;= 11，不需要判断 if #available(iOS 11.0, *) {\tself.view.backgroundColor = UIColor(named: \u0026#34;lgl_test\u0026#34;) } else { ///设置低于iOS11系统下展示的颜色 self.view.backgroundColor = UIColor.red } ","date":"2020-05-28T20:26:58Z","permalink":"https://blog.iostao.com/2020/05/ios-dynamic-color/","title":"iOS 深浅模式 颜色 和 图片"},{"content":"我们开发会遇到类似于获取菜单这种情况，架构大体类似如下：\n人事管理 员工资历 员工奖惩 统计管理 统计列表 系统管理 我的设置 权限管理 角色列表 我这里用的是双层结构，我们搜索的时候用的是递归查询，所以理论上可以无限级添加（不考虑数据库的感受的话）。\n数据表如下：\n-- Table structure for tbl_auth_menu\n1 2 3 4 5 6 7 8 9 10 DROP TABLE IF EXISTS `tbl_auth_menu`; CREATE TABLE `tbl_auth_menu` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `pid` int(11) NOT NULL COMMENT \u0026#39;父级菜单id\u0026#39;, `name` char(20) NOT NULL COMMENT \u0026#39;菜单名单\u0026#39;, `sort` tinyint(4) DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;排序值\u0026#39;, `route` varchar(60) DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;跳转链接\u0026#39;, PRIMARY KEY (`id`), KEY `pid` (`pid`) ) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COMMENT=\u0026#39;权限管理_菜单表\u0026#39;; -- Records of tbl_auth_menu\n1 2 3 4 5 6 7 8 9 10 11 BEGIN; INSERT INTO `tbl_auth_menu` VALUES (14, -1, \u0026#39;人事管理\u0026#39;, 1, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (15, -1, \u0026#39;统计管理\u0026#39;, 2, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (16, -1, \u0026#39;系统管理\u0026#39;, 3, \u0026#39;\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (17, 14, \u0026#39;员工资料\u0026#39;, 1, \u0026#39;/user/info\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (18, 14, \u0026#39;员工奖惩\u0026#39;, 2, \u0026#39;/user/award\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (19, 15, \u0026#39;统计列表\u0026#39;, 1, \u0026#39;/statis/list\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (20, 16, \u0026#39;我的设置\u0026#39;, 1, \u0026#39;/sys/setting\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (21, 16, \u0026#39;权限管理\u0026#39;, 2, \u0026#39;/sys/auth\u0026#39;); INSERT INTO `tbl_auth_menu` VALUES (22, 16, \u0026#39;角色列表\u0026#39;, 3, \u0026#39;/sys/role\u0026#39;); COMMIT; 我这里第一级目录的 父菜单 id (pid)使用的是 -1, 因为 id 默认是从 0开始的，使用0的话，这个菜单有可能不是第一级目录，而是 pid = 0 的二级目录了\n父菜单 id = 0 子菜单 pid = 0 (pid=0，它就是二级目录了） 代码 文件 menu.go (使用 beego orm) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Menu struct { Id int `json:\u0026#34;id\u0026#34;` Pid int `json:\u0026#34;pid\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Sort int `json:\u0026#34;sort\u0026#34;` Route string `json:\u0026#34;route\u0026#34;` //这里是子菜单，结构是 menu数组，因为是menu类型，所以数据库不做处理 //用 orm:\u0026#34;-\u0026#34;注解 Children []*Menu `json:\u0026#34;children\u0026#34; orm:\u0026#34;-\u0026#34;`\t} func (m *Menu) TableName() string { return \u0026#34;auth_menu\u0026#34; } 在数据库层，注册模型 1 2 3 4 5 6 7 8 9 //注册 数据库的时候 //我这里数据库都使用了 tbl_ 前缀。 //所以上面的数据库, return auth_menu 表名, 但是实际上使用的时候是 tbl_auth_menu 表, 这里一定要注意， //写代码的时候，提示错误，数据库表 不存在这个的时候，记得来这里看看 func init() { orm.RegisterModelWithPrefix(\u0026#34;tbl_\u0026#34;, new(models.Menu), ) } 递归查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** 递归获取树形菜单 */ //func (m *Menu) GetMenu(pid int) []*TreeList { func GetMenu(pid int) []*Menu { o := orm.NewOrm() var menuList []*Menu //根据 pid 查询数据库 _, _ = o.QueryTable(\u0026#34;tbl_auth_menu\u0026#34;).Filter(\u0026#34;pid\u0026#34;, pid).OrderBy(\u0026#34;sort\u0026#34;).All(\u0026amp;menuList) //查询到结果后，遍历该层菜单 //查询都有哪些菜单是使用自己的id作为pid的， //也就是查询该菜单的子菜单，查询到后赋值就可以了 for _, v := range menuList { child := GetMenu(v.Id) v.Children = child } return menuList } api方法 1 2 3 4 5 6 7 8 9 // 获取所有部门 func (c *DepartmentController) GetAll() { //我方法写在了 models 包里，根据具体情况，引入包， //或者是同级包下，不写包名 // -1 为 第一级部门 的 parentId， departments := models.DepartmentGetAll(-1) c.Data[\u0026#34;json\u0026#34;] = util.NewRespMsg(0, \u0026#34;获取部门成功\u0026#34;, departments) c.ServeJSON() } ","date":"2020-05-18T11:51:10Z","permalink":"https://blog.iostao.com/2020/05/go-mysql-recursion/","title":"Golang实战系列：mysql数据库查询 -- 实现无限级菜单（beego orm)"},{"content":"转载自 超级大柱子（简书）\ngo极简教程 阅读目录\nGo 文件操作 os库：文件\\文件夹创建,读取,移动,复制 io库 : 文件内容的写入,修改,拼接 基本文件操作 文件内容的读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { // 读取文件内容 file, _ := os.OpenFile(\u0026#34;./demo_unicode.html\u0026#34;, 2, 0666) fileByte1, _ = ioutil.ReadAll(file); // 读取文件内容，更简易的方法 fileByte2, _ := ioutil.ReadFile(\u0026#34;./demo_unicode.html\u0026#34;) // byte转string fileString := string(fileByte2) log.Println(fileString) } 文件的常规操作，复制以下代码进main.go, 执行后看看效果, 再逐行阅读代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 设定工作路径, 一般在项目刚开始设定一次即可, 不要在异步过程中修改工作路径 // 默认是程序执行的路径 os.Chdir(\u0026#34;./\u0026#34;) // 创建文件夹 os.MkdirAll(\u0026#34;./aa/bb/c1\u0026#34;, 0777)\t//os.ModePerm 就是0777 os.MkdirAll(\u0026#34;./aa/bb/c2\u0026#34;, 0777) // 创建文件 os.Create(\u0026#34;./aa/bb/c1/file.go\u0026#34;) // 移动文件 os.Rename(\u0026#34;./aa/bb/c1/file.go\u0026#34;, \u0026#34;./aa/bb/c2/file.go\u0026#34;) // 打开文件,得到一个 *File 对象, 用于后续的写入 file, _ := os.OpenFile(\u0026#34;./aa/bb/c2/file.go\u0026#34;, 2, 0666) // 写入文件内容 io.WriteString(file, ` package main func main(){ log.Println(\u0026#34;我是由程序写入的代码\u0026#34;) } `) // 也可以直接调用file里的函数写入内容 file.WriteString(\u0026#34;add string\u0026#34;) // 拷贝文件, 拷贝其实就是创建一个文件, 然后写入文件内容 src1, _ := os.Create(\u0026#34;./aa/bb/c1/file-copy1.go\u0026#34;) io.Copy(file, src1) // 把文件file, 写入src1文件 // 删除文件或文件夹 os.Create(\u0026#34;./aa/bb/c1/file-delete.go\u0026#34;) // 创建一个文件用于删除 os.RemoveAll(\u0026#34;./aa/bb/c1/file-delete.go\u0026#34;) } 文件覆盖判断 os.IsNotExist 当文件已存在时, 不管是os.Rename(), os.Create(), 还是io.WriteString() 都会对已存在的文件进行覆盖\\修改,\n如果需要安全的执行, 可以使用 os.Stat() 配合 os.IsNotExist() 做判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { os.MkdirAll(\u0026#34;aa\u0026#34;, 0777) // 创建了文件 testA, 并且写入了内容 testA, _ := os.Create(\u0026#34;aa/testA\u0026#34;) io.WriteString(testA, \u0026#34;the teatA\u0026#34;) // 如果需要安全判断, 可以使用 os.Stat 配合 os.IsNotExist if _, err := os.Stat(\u0026#34;aa/testA\u0026#34;); os.IsNotExist(err) { // 当文件不存在, 才执行创建 os.Create(\u0026#34;aa/testA\u0026#34;) } os.Chmod(\u0026#34;aa/testA\u0026#34;, 0777) } 遍历文件夹 遍历文件夹可以使用 ioutil库 的ioutil.ReadDir, 会得到一个数组, 数组元素有文件的属性,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { fs, _ := ioutil.ReadDir(\u0026#34;aa\u0026#34;) for _, v := range fs { // 遍历得到文件名 log.Println(v.Name()) log.Println(v.IsDir()) } } 权限 可以使用 os.Chmod() 修改文件权限\n1 2 // 所有人可读写权限 os.Chmod(\u0026#34;aa/testA\u0026#34;, 0666) 1 2 // 只读权限 os.Chmod(\u0026#34;aa/testA\u0026#34;, 0400) Linux权限参考 1 2 3 4 5 6 7 -rw------- (600) 只有拥有者有读写权限。 -rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。 -rwx------ (700) 只有拥有者有读、写、执行权限。 -rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。 -rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。 -rw-rw-rw- (666) 所有用户都有文件读、写权限。 -rwxrwxrwx (777) 所有用户都有读、写、执行权限。 ","date":"2020-03-22T19:23:51Z","permalink":"https://blog.iostao.com/2020/03/go-os-operation/","title":"Golang 文件操作"},{"content":" string转成int： int, err := strconv.Atoi(string) string转成int64： int64, err := strconv.ParseInt(string, 10, 64) int转成string： string := strconv.Itoa(int) int64转成string： string := strconv.FormatInt(int64,10) ","date":"2020-03-16T09:51:36Z","permalink":"https://blog.iostao.com/2020/03/go-type-format/","title":"golang 中string和int类型相互转换"},{"content":"准备 在CentOS 的某个目录下，创建下面的目录形式（也可以本地创建，用ftp上传） /data/fileserver/\ndata fileserver Dockerfile nginx.conf data/ Dockerfile 这里先写 Dockerfile 文件，注意文件名保持一致\n1 2 3 4 5 6 7 8 9 FROM hub.c.163.com/public/nginx:1.2.1 #从镜像中心下载镜像，如果本地已经存在，则使用本地的。这里使用的163镜像中心 MAINTAINER tao ## 作者，可以不写 #COPY nginx.conf /etc/nginx/nginx.conf #这里是将 Dockerfile 同级目录的 nginx.conf 拷贝到 /etc/nginx/nginx.conf # 但是这里吧，后期 nginx.conf 可能会修改，所以我注释掉了 # 我用的是 -v 映射，后期修改的时候，重启一下镜像就可以了 nginx.conf nginx.conf 完整文件\n这里为了方便 ，配置文件中直接使用的是 user root; 最好是新创建一个用户。设置好权限。使用另一个用户，安全性更高一些。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 8080; server_name localhost; charset utf-8; #access_log logs/host.access.log main; location / { #显示的根目录 测试文字 root /usr/share/nginx/html; autoindex on; #开启索引功能 autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb） autoindex_localtime on; # 显示本机时间而非 GMT 时间 } } 镜像+容器 cd 到 fileserver目录下，执行命令，生成一个新的镜像 $ docker build -t fileserver .\n生成并运行容器\ndocker run -itd --restart=always -p 8090:8080 --name fileserver -v /data/fileserver/data:/usr/share/nginx/html/ -v /data/fileserver/nginx.conf:/etc/nginx/nginx.conf fileserver 这里nginx配置的是8080端口，也就是 -p 8090:8080 后面的这个8080，这个是容器内服务的端口，对外没有影响。8090是我们外面映射的端口，远程访问就是用这个8090的端口\n","date":"2020-03-05T09:54:25Z","permalink":"https://blog.iostao.com/2020/03/linux-start-03/","title":"CentOS 使用 Docker 服务搭建 Nginx 文件服务器"},{"content":"搭建mysql + FTP服务 一、安装 mysql 从官方下载mysql 5.7镜像 $ docker pull mysql:5.7 查看下载的镜像\n$ docker image docker安装 Mysql，并映射本地文件目录/data/mysql/data $ docker run -itd --restart=always -p 3306:3306 --name mysql -v /data/mysql/data:/var/lib/mysql -v /data/mysql/etc:/etc/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 options Mean -i 以交互模式运行容器，通常与 -t 同时使用 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 d | 后台运行容器，并返回容器ID \u0026ndash;restart | always 重启docker后，会立即启动服务 -p | 端口映射 3306:3306 前面的端口，代表本机（也就是centOS的端口），后面的端口，是docker容器内部的端口，和外部端口不冲突。比如mysql -p 3306:3306, slave -p 3307:3306。centOS的端口，分别是3306, 3307。mysql容器内部是3306， slave容器内部也是3306 -v | 路径映射，将容器中的数据映射到硬盘磁盘上 \u0026ndash;name | 别名，方便操作 mysql:5.7 | 最后这个是镜像名+镜像版本，docker images查看对比一下就可以了 当然也可以从网易云镜像 或者其他镜像仓库下载镜像。需要登录，然后进入控制台，镜像仓库\n查看运行的容器\n$ docker ps 进入容器，测试\n# 进入mysql容器 # 这个mysql是上面创建容器的时候，--name起的别名。也可以用容器id $ docker exec -it mysql bash $ mysql -u root -p # 输入密码，即可查看本地是否登录成功 远程连接，要注意mysql账号是否开启了远程登录，没有的话，需要设置一下\n二、FTP服务 docker下载 vsftpd镜像 docker pull docker.io/fauria/vsftpd 安装 docker run -d -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -v /data:/home/vsftpd/用户名 -e FTP_USER=用户名 -e FTP_PASS=密码 -e PASV_ADDRESS=服务器ip -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 --name vsftpd --restart=always docker.io/fauria/vsftpd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -p 映射端口 21100-21110 //被动模式随机端口 -v 映射目录，我这里是需要把本地目录映射到这个用户下。 所以需要把用户名加上 该用户在FTP中的目录是 /home/vsftpd/用户名 所以 本地目录: /home/vsftpd/用户名 这里需要把服务器的端口打开，登录腾讯云/阿里云后台 -\u0026gt; 控制台 -\u0026gt; 安全组 -\u0026gt; 修改规则 -\u0026gt; 添加规则 来源 //协议端口 备注 0.0.0.0/0 tcp:20 20 端口 0.0.0.0/0 tcp:21 21 端口 0.0.0.0/0 tcp:22 22 ssh端口 0.0.0.0/0 tcp:21100-21110 21100-21110 这是一个端口范围 远程FTP连接测试就可以了，FTP客户端工具 FileZilla下载\n有连接不上的，点端口扫描，进行一下端口扫描，看看服务端口是否关闭，如果关闭状态，去控制台添加一下规则，将端口打开。\n","date":"2020-02-25T13:12:10Z","permalink":"https://blog.iostao.com/2020/02/linux-start-02/","title":"CentOS 服务器 + mysql + vsftpd服务"},{"content":"docker网络命令 查看网络命令帮助 docker network help \u0026ndash; 各种网络命令Command \u0026ndash; connect Connect a container to a network 将一个容器连接到一个网络 create Create a network 创建一个网络 disconnect Disconnect a container from a network 从网络断开一个容器 inspect Display detailed information on one or more networks 在一个或多个网络上显示详细信息 ls List networks 网络列表 prune Remove all unused networks 删除所有未使用的网络 rm Remove one or more networks 删除一个或多个网络 docker查看命令 ###查看容器详细信息 docker inspect [容器id]\n查看容器端口信息 docker port [容器id] docker网络模式 从1.7.0版本开始，Docker正式把网络跟存储这两个部分的功能实现都以插件化的形式剥离出来，允许用户通过指令来选择不同的后端实现。这也就是Docker希望构建围绕着容器的强大生态系统的一些积极尝试。剥离出来的独立网络项目叫做libnetwork, libnetwork中的网络模型（Container Networking Model, CNM）十分简洁，可以让上层的大量应用容易最大程度上不去关心底层实现。\ndocker的常用的网络模式 ###bridge模式 简单来说：就是穿马甲，打着宿主机的旗号，做自己的事情。Docker的默认模式，它会在docker容器启动时候，自动配置好自己的网络信息，同一宿主机的所有容器都在一个网络下，彼此间可以通信。类似于我们vmware虚拟机的桥接模式。利用宿主机的网卡进行通信，因为涉及到网络转换，所以会造成资源消耗，网络效率会低。\n端口映射\n宿主机 公网ip:198.x.x.x ---\u0026gt; 容器ip: 172.17.0.x docker network create --driver [网络类型][网络名称] #参数 create 创建一个网络 --driver 指定网络类型 #命令演示 docker network create --driver bridge bridge-test host模式：简单来说，就是鸠占鹊巢，用着宿主机的东西，干自己的事情。容器使用宿主机的ip地址进行通信。特点：容器和宿主机共享网络\n容器使用宿主机的ip地址进行对外提供服务，本身没有ip地址。\ncontainer模式：新创建的容器间使用，使用已创建的容器网络，类似一个局域网。特点：容器和容器共享网络\nnone模式：这种模式最纯粹，不会帮你做任何网络配置，可以最大限度的定制化。不提供网络服务，容器启动后无网络链接。\noverlay模式：容器彼此不在同一个网络，而且能互相通信。\n自定义网段与网关 #自定义网段与网关 #查看关羽网段和网关的相关命令 docker network create --help --gateway strings IPv4 or IPv6 Gateway for the master subnet 主子网的IPv4或IPv6网关 --subnet strings\tSubnet in CIDR format that represents a network segment 表示网络段的CIDR格式的子网 #查看刚刚创建的网络信息 docker network inspect bridge-test docker network create --driver bridge --gateway 172.99.0.1 --subnet 172.99.0.0/16 bridge-test","date":"2019-07-19T14:37:55Z","permalink":"https://blog.iostao.com/2019/07/docker-net-shell/","title":"docker网络命令与基本查看命令"},{"content":"转载自Ca0Gu0\nLinux 登陆服务器敲命令太多,某时候确实不便，但是如果使用脚本就会简便很多\n脚本下载 so.zip\n一、说明 支持密码和密钥两种格式 用户名和密码都是写文件的 二、配置 密码文件配置:\n序号:IP:端口:用户:密码:说明 1:192.168.88.128:22:root:toor:虚拟机web服务器\n密钥文件放在keys文件夹下,密码位置写成密钥文件名,文件名必须以.pem结尾\n如下所示：\n1:104.194.71.144:26999:root:WaFHwZm1AM3L5:搬瓦工 2:47.94.208.55:8080:root:aliyun.pem:阿里云 3:104.194.71.144:3306:ca0gu0:toor:虚拟机mysql数据库服务器 4:103:192.168.88.4:22:root:sellercube:本地开发服务器 ","date":"2019-04-05T11:55:55Z","permalink":"https://blog.iostao.com/2019/04/linux-shell-ssh/","title":"Linux Shell ssh登录脚本"},{"content":"CentOS 服务器 + Docker 1、可以通过阿里云、腾讯云购买一个服务器\n2、自己搭建一个本地服务器\n（我们这里以云服务器为例）\n一、登录服务器 ssh root@服务器ip -p 22 因为每次登录都需要输入一行带有ip的命令，比较麻烦。所以这里我用的脚本登录，每次登录的时候很方便，也方便管理多个服务器。\nLinux Shell ssh登录脚本 二、Cent OS操作 这里先记录一条命令 \u0026ndash; 开启，重启，停止命令 (这里以ftp服务命令为例）\nsudo systemctl start vsftpd sudo systemctl restart vsftpd sudo systemctl stop vsftpd 把yum包更新到最新\n$sudo yum update 安装各种服务 本人这里使用的是docker容器服务，mysql，redis，vsftpd服务，以及项目部署都是使用的docker。所以这里先安装 docker\ndocker最低支持的内核好像是3.0\n查看版本以及内核\n$ uname -a # 下面是输入命令后，返回的信息 Linux VM_0_7_centos 3.10.0-1062.9.1.el7.x86_64 #1 SMP Fri Dec 6 15:49:49 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装Docker容器服务 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\nyum install -y yum-utils device-mapper-persistent-data lvm2 安装 docker\nyum install docker -y 启动Docker\n启动Docker,设置开机启动, sudo systemctl start docker sudo systemctl enable docker #停止Docker sudo systemctl stop docker 验证是否安装成功\nsudo docker info 配置 docker 加速器\ncurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io Docker 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #查找Docker Hub上的镜像 $ docker search imageName/ID #获取Docker Hub上的镜像 $ docker pull ImageName/ID #显示本地主机上的镜像列表 $ docker images #运行本地主机上的镜像 $ docker run ImageName/ID #列出正在运行的容器 $ docker ps #查看正在运行容器的网络端口映射情况 $ docker port ContainerID #查看正在运行容器的内部正在进程运行 $ docker top ContainerID #查看正在运行容器的内部底层信息 $ docker inspect ContainerID #停止正在运行容器 $ docker stop ContainerID/ #重启已经停止的容器 $ docker start ContainerID #删除不需要的容器（必须在容器已经停止的情况下） $ docker rm ContainerimageID #移除本地镜像，移除前需要把该镜像下所有的容器删除 $ docker rmi ImageName/ID #登录docker $ docker login #运行ubuntu:16.04镜像并创建容器和启动bash终端 $ docker run -t -i ubuntu:16.04 /bin/bash #重命名容器名 $ docker rename wonderful_kepler Ubuntu16.04 #构建镜像 $ docker commit -m=\u0026#34;has update\u0026#34; -a=\u0026#34;SpiffyEight77\u0026#34; ff5d623e2d61 spiffyeight77/ubuntu:16.04 #提交镜像到docker hub 需要登录 $ docker push spiffyeight77/ubuntu 部分参数说明\n1 2 3 4 5 6 7 8 9 10 11 12 -d: 守护模式 后台运行 -p: 是容器内部端口绑定到指定的主机端口 -P: 是容器内部端口随机映射到主机的高端口 -f : 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出 -l : 查询最后一次创建的容器 -t : 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -i : 则让容器的标准输入保持打开 -m:提交的描述信息 -a: 指定镜像作者 --rm: 停止容器后移除容器 ff5d623e2d61: 容器ID spiffyeight77/ubuntu:16.04: 指定要创建的目标镜像名 编写 Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 不会写Dockerfile的话请自行Google FROM alpine:latest #使用了镜像大小体积只有5MB的alpine镜像 WORKDIR / #设置工作路径 ADD main / #把上文编译好的main文件添加到镜像里 EXPOSE 3000 #暴露容器内部端口 ENTRYPOINT [\u0026#34;./main\u0026#34;] #入口 ","date":"2019-02-20T12:22:27Z","permalink":"https://blog.iostao.com/2019/02/linux-start-01/","title":"CentOS 第一步"},{"content":"转载自简书\n1、AUAudioSession 概述 苹果官方图 可以看到AVAudioSession就是用来管理多个APP对音频硬件设备（麦克风，扬声器）的资源使用。\n举例一下AVAudioSession可以做这些事情\n设置自己的APP是否和其他APP音频同时存在，还是中断其他APP声音 在手机调到静音模式下，自己的APP音频是否可以播放出声音 电话或者其他APP终端自己APP的音频的事件处理 指定音频输入和输出的设备（比如是听筒输出声音，还是扬声器输出声音） 是否支持录音，录音同时是否支持音频播放 2、AVAudioSession Category AVAudioSession的接口比较简单。APP启动的时候会自动帮激活AVAudioSession，当然我们可以手动激活，代码如下：\n//导入头文件 #import \u0026lt;AVFoundation/AVFoundation.h\u0026gt; //AVAudioSession是一个单例类 AVAudioSession *session = [AVAudioSession sharedInstance]; //AVAudioSessionCategorySoloAmbient是系统默认的category [session setCategory:AVAudioSessionCategorySoloAmbient error:nil]; //激活AVAudioSession [session setActive:YES error:nil]; 可以看到设置session这里有两个参数，category和options\nCatogory iOS下目前有七种，每种Category都对应是否支持下面四种能力\nInterrupts non-mixable apps audio: 是否打断不支持混音播放的APP Silenced by the Silent switch: 是否会响应手机静音键开关 Supports audio input: 是否支持音频录入 Supports audio output: 是否支持音频播放 下面用图表来直观的看下每种category具体的能力集\nCategory 是否允许音频播放/录音 是否打断其他不支持混音APP 是否会被静音键或锁屏键静音 AVAudioSessionCategoryAmbient 只支持播放 否 是 AVAudioSessionCategoryAudioProcessing 不支持播放，不支持录制 是 否 AVAudioSessionCategoryMultiRoute 支持播放，支持录制 是 否 AVAudioSessionCategoryPlayAndRecord 支持播放，支持录制 默认YES，可以重写为NO 否 AVAudioSessionCategoryPlayback 只支持播放 默认YES,可以重写为NO 否 AVAudioSessionCategoryRecord 只支持录制 是 否（锁屏下仍可录制） AVAudioSessionCategorySoloAmbient 只支持播放 是 是 AVAudioSessionCategoryAmbient，只支持音频播放。这个 Category，音频会被静音键和锁屏键静音。并且不会打断其他应用的音频播放。\nAVAudioSessionCategorySoloAmbient，这个是系统默认使用的 Category，只支持音频播放。音频会被静音键和锁屏键静音。和AVAudioSessionCategoryAmbient不同的是，这个会打断其他应用的音频播放\nAVAudioSessionCategoryPlayback，只支持音频播放。你的音频不会被静音键和锁屏键静音。适用于音频是主要功能的APP，像网易云这些音乐app，锁屏后依然可以播放。\n需要注意一下，选择支持在静音键切到静音状态以及锁屏键切到锁屏状态下仍然可以播放音频 Category 时，必须在应用中开启支持后台音频功能，详见 UIBackgroundModes。\nAVAudioSessionCategoryRecord，只支持音频录制。不支持播放。\nAVAudioSessionCategoryPlayAndRecord，支持音频播放和录制。音频的输入和输出不需要同步进行，也可以同步进行。需要音频通话类应用，可以使用这个 Category。\nAVAudioSessionCategoryAudioProcessing，只支持本地音频编解码处理。不支持播放和录制。\nAVAudioSessionCategoryMultiRoute，支持音频播放和录制。允许多条音频流的同步输入和输出。（比如USB连接外部扬声器输出音频，蓝牙耳机同时播放另一路音频这种特殊需求）\n我们也可以通过AVAudioSession的属性来读取当前设备支持的Category ``` @property(readonly) NSArray\u0026lt;NSString *\u0026gt; *availableCategories;\n``` 这样可以保证设备兼容性\n设置Category的代码实例如下：\n``` NSError *setCategoryError = nil; BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:\u0026amp;setCategoryError]; if (!success) { //这里可以读取setCategoryError.localizedDescription查看错误原因 } ``` 3、AVAudioSession Mode\u0026amp;\u0026amp;Options 刚刚介绍的Category定义了七种主场景，实际开发需求中有时候需要对Category进行微调整，我们发现这个接口还有两个参数Mode和Options。\n``` /* set session category and mode with options */ - (BOOL)setCategory:(NSString *)category mode:(NSString *)mode options:(AVAudioSessionCategoryOptions)options error:(NSError **)outError API_AVAILABLE(ios(10.0), watchos(3.0), tvos(10.0)); ``` AVAudioSession Mode 我们通过读取下面这条属性获取当前设备支持的Mode\n1 @property(readonly) NSArray\u0026lt;NSString *\u0026gt; *availableModes; iOS下有其中mode 来定制我们的Category行为：\n模式 兼容的Category 场景 AVAudioSessionModeDefault All 默认模式 AVAudioSessionModeVoiceChat AVAudioSessionCategoryPlayAndRecord VoIP AVAudioSessionModeGameChat AVAudioSessionCategoryPlayAndRecord 游戏录制，GKVoiceChat自动设置 AVAudioSessionModeVideoRecording AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord 录制视频 AVAudioSessionModeMoviePlayback AVAudioSessionCategoryPlayback 视频播放 AVAudioSessionModeMeasurement AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback 最小系统 AVAudioSessionModeVideoChat AVAudioSessionCategoryPlayAndRecord 视频通话 下面逐一介绍下每个Mode\nAVAudioSessionModeDefault，默认模式,与所有的 Category 兼容\nAVAudioSessionModeVoiceChat，适用于VoIP 类型的应用。只能是 AVAudioSessionCategoryPlayAndRecord Category下。在这个模式系统会自动配置AVAudioSessionCategoryOptionAllowBluetooth 这个选项。系统会自动选择最佳的内置麦克风组合支持语音聊天。\nAVAudioSessionModeVideoChat，用于视频聊天类型应用，只能是 AVAudioSessionCategoryPlayAndRecord Category下。适在这个模式系统会自动配置 AVAudioSessionCategoryOptionAllowBluetooth 和 AVAudioSessionCategoryOptionDefaultToSpeaker 选项。系统会自动选择最佳的内置麦克风组合支持视频聊天。\nAVAudioSessionModeGameChat，适用于游戏类应用。使用 GKVoiceChat 对象的应用会自动设置这个模式和 AVAudioSessionCategoryPlayAndRecord Category。实际参数和AVAudioSessionModeVideoChat一致\nAVAudioSessionModeVideoRecording，适用于使用摄像头采集视频的应用。只能是 AVAudioSessionCategoryPlayAndRecord 和 AVAudioSessionCategoryRecord 这两个 Category下。这个模式搭配 AVCaptureSession API 结合来用可以更好地控制音视频的输入输出路径。(例如，设置 automaticallyConfiguresApplicationAudioSession 属性，系统会自动选择最佳输出路径。\nAVAudioSessionModeMeasurement，最小化系统。只用于 AVAudioSessionCategoryPlayAndRecord、AVAudioSessionCategoryRecord、AVAudioSessionCategoryPlayback 这几种 Category。\nAVAudioSessionModeMoviePlayback，适用于播放视频的应用。只用于 AVAudioSessionCategoryPlayback 这个Category。\nAVAudioSession Options 我们还可以使用options去微调Category行为，如下表\nOption Option功能说明 兼容的 Category AVAudioSessionCategoryOptionMixWithOthers 支持和其他APP音频 mix AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute AVAudioSessionCategoryOptionDuckOthers 系统智能调低其他APP音频音量 AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute AVAudioSessionCategoryOptionAllowBluetooth 支持蓝牙音频输入 AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryOptionDefaultToSpeaker 设置默认输出音频到扬声器 AVAudioSessionCategoryPlayAndRecord 调优我们的Category 通过Category和合适的Mode和Options的搭配我们可以调优出我们的效果，下面举两个应用场景:\n用过高德地图的都知道，在后台播放QQ音乐的时候，如果导航语音出来，QQ音乐不会停止，而是被智能压低和混音，等导航语音播报完后，QQ音乐正常播放，这里我们需要后台播放音乐，所以Category使用AVAudioSessionCategoryPlayback，需要混音和智能压低其他APP音量，所以Options选用 AVAudioSessionCategoryOptionMixWithOthers和AVAudioSessionCategoryOptionDuckOthers\n代码示例如下：\n1 2 3 4 5 BOOL isSuccess = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback withOptions: AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryOptionDuckOthers error:\u0026amp;setCategoryError]; 又或者我希望AVAudioSessionCategoryPlayAndRecord这个Category默认的音频由扬声器播放，那么可以调用这个接口去调整Category\n1 2 3 4 - (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError 通过选择合适和Category，mode和options，就可以调优音频的输入输出，来满足日常开发需求（需要注意的是Category，mode，option是搭配使用的，而不是简单组合，也就是说某种Category支持某些mode和option，从上面的表中也可以看出这一点）\n4. 音频中断处理 其他APP或者电话会中断我们的APP音频，所以相应的我们要做出处理。 我们可以通过监听AVAudioSessionInterruptionNotification这个key获取音频中断事件\n回调回来Userinfo有键值：\nAVAudioSessionInterruptionTypeKey： AVAudioSessionInterruptionTypeBegan: 表示中断开始 AVAudioSessionInterruptionTypeEnded: 表示中断结束 中断开始：我们需要做的是保存好播放状态，上下文，更新用户界面等 中断结束：我们要做的是恢复好状态和上下文，更新用户界面，根据需求准备好之后选择是否激活我们session。\n选择不同的音频播放技术，处理中断方式也有差别，具体如下:\nSystem Sound Services：使用 System Sound Services 播发音频，系统会自动处理，不受APP控制，当中断发生时，音频播放会静音，当中断结束后，音频播放会恢复。\nAV Foundation framework：AVAudioPlayer 类和 AVAudioRecorder 类提供了中断开始和结束的 Delegate 回调方法来处理中断。中断发生，系统会自动停止播放，需要做的是记录播放时间等状态，更新用户界面，等中断结束后，再次调用播放方法，系统会自动激活session。\nAudio Queue Services, I/O audio unit：使用aduio unit这些技术需要处理中断，需要做的是记录播放或者录制的位置，中断结束后自己恢复audio session。\nOpenAL：使用 OpenAL 播放时，同样需要自己监听中断。管理 OpenAL上下文，用户中断结束后恢复audio session。\n需要注意的是：1. 有中断开始事件，不一定对应有中断结束事件，所以需要在用户进入前台，点击UI操作的时候，需要保存好播放状态和对Audio Session管理，以便不影响APP的音频功能。2.音频资源竞争上，一定是电话优先。3. AVAudioSession同样可以监听外设音频状态，比如耳机拔入拔出。这里不做累述\n5. AVAudioSession总结 AVAudioSession的作用就是管理音频这一唯一硬件资源的分配，通过调优合适的AVAudioSession来适配我们的APP对于音频的功能需求。切换音频场景时候，需要相应的切换AVAudioSession。\n","date":"2018-07-27T11:10:43Z","permalink":"https://blog.iostao.com/2018/07/ios-avaudiosession/","title":"iOS-AVAudio"},{"content":"【SpriteKit】 在iOS7中内置了新的SpriteKit框架，该框架主要用来开发2D游戏。是开发iOS和OS X 下的2D游戏引擎，可以使用OC或者Swift来进行开发。目前已经支持的内容包括：精灵、很酷的特效（例如视频、滤镜和遮罩），并且还集成了物理库等许多东西。首先指出在iOS中开发2D游戏SpriteKit并不是唯一的选择，我们先来看看SpriteKit的特点和优缺点：\n1.特点： （1）提供了游戏引擎必备的图形渲染和动画API，可以通过这些API让精灵动起来； （2）使用传统的渲染和动画，允许在渲染每一帧之前处理该帧； （3）提供了声音播放； （4）提供的物理引擎； （5）与Xcode集成，可以更容易的创建基于Sprite Kit的游戏工程，调试也很方便； （6）可以使用Swift语言；\n2.优点： （1）它是内置到iOS中的，因此并不需要下载额外的库或者其他的外部依赖，并且它是由苹果开发的，所以对他的支持和更新我们可以放心； （2）它内置的工具支持纹理和粒子； （3）它可以让你做一些其他框架难以做到的事情，例如把视频当做精灵一样处理，或者使用很酷的图形效果和遮罩。 3.缺点： （1）如果使用了SpriteKit，那么你将被iOS生态圈绑架，导致很难把游戏移植到Android等其他平台； （2）SpriteKit现在还处于初始阶段，提供的内容还不够丰富，例如Cocos2D，暂不支持自定义的OpenGL代码；\n【SceneKit】 SceneKit(SK)是WWDC12推出的OS X平台的cocos 3D渲染引擎框架。支持粒子效果，物理模拟，脚本事件，多程渲染，支持iOS平台。SceneKit整合了Core Image，Core Animation之类的图形框架，现在还整合进了SpriteKit。 SceneKit是基于OpenGL构建的。\n【Metal】 在iOS8中，苹果发布了一个新的接口叫做Metal，它是一个支持GPU加速的3D绘图API。Metal和OpenGL ES类似，也是一个底层API，负责和3D绘图硬件交互。可惜的是，Metal不是跨平台的。\n","date":"2016-12-18T22:08:49Z","permalink":"https://blog.iostao.com/2016/12/ios-spritekit-scenekit/","title":"iOS SpriteKit/SceneKit/Metal浅析"},{"content":"\n内存和活动管理选项( memory and activity management options)是今年苹果在OS发布的新技术(包括 OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0).这个包括用.initiallyInactive在非活动的状态启动一个队列,或者为你的线程设置一个自动释放属性(.autoreleaseInherit, .autoreleaseNever, .autoreleaseWorkItem)\nswift 3中对C层级的GCD的API进行了彻头彻尾的改变。本文将从实际使用场景来了解一下新的api使用。\ndispatch_async 一个常见的场景就是在一个全局队列进行一些操作后切换到主线程配置UI。现在是这么写：\nDispatchQueue.global().async { // code DispatchQueue.main.async { // 主线程中 } } global()是一个有着默认参数的静态函数：\nclass DispatchQueue : DispatchObject { public class var main: DispatchQueue public class func global(qos: DispatchQoS.QoSClass = default) -\u0026gt; DispatchQueue } sync\n如果想同步执行操作，和async类似，调用sync就可以了：\nDispatchQueue.global().sync { // 同步执行 } 优先级：DispatchQoS 我们知道，GCD 的默认队列优先级有四个：\nDISPATCH_QUEUE_PRIORITY_HIGH DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND 现在则改为了QoSClass枚举\npublic enum QoSClass { case background case utility case `default` case userInitiated case userInteractive case unspecified public init?(rawValue: qos_class_t) public var rawValue: qos_class_t { get } } 这些命名比原先的更加友好，能更好表达这个操作的意图。\n和原有的对应关系是：\nDISPATCH_QUEUE_PRIORITY_HIGH: .userInitiated DISPATCH_QUEUE_PRIORITY_DEFAULT: .default DISPATCH_QUEUE_PRIORITY_LOW: .utility DISPATCH_QUEUE_PRIORITY_BACKGROUND: .background 创建队列 DispatchQueue的默认初始化方法创建的就是一个同步队列，如果要创建并发的队列，在attributes中声明concurrent。\n// 同步队列\nlet serialQueue = DispatchQueue(label: \u0026quot;queuename\u0026quot;) // 并发队列\nlet concurrentQueue = DispatchQueue(label: \u0026quot;queuename\u0026quot;, attributes: .concurrent) 推迟时间后执行\n原先的dispatch_time_t现在由DispatchTime对象表示。可以用静态方法now获得当前时间，然后再通过加上一个DispatchTimeInterval枚举来获得一个需要延迟的时间。\nlet delay = DispatchTime.now() + DispatchTimeInterval.seconds(60)DispatchQueue.main.asyncAfter(deadline: delay) { // 延迟执行} 这里也可以直接加上一个秒数。\nlet three = DispatchTime.now() + 3.0 因为DispatchTime中自定义了+号。\npublic func +(time: DispatchTime, seconds: Double) -\u0026gt; DispatchTime DispatchGroup\n如果想在dispatch_queue中所有的任务执行完成后再做某种操作可以使用DispatchGroup。原先的dispatch_group_t由现在的DispatchGroup对象代替。\nlet group = DispatchGroup() let queueBook = DispatchQueue(label: \u0026quot;book\u0026quot;) queueBook.async(group: group) { // 下载图书 } let queueVideo = DispatchQueue(label: \u0026quot;video\u0026quot;) queueVideo.async(group: group) { // 下载视频 } group.notify(queue: DispatchQueue.main) { // 下载完成 } DispatchGroup会在组里的操作都完成后执行notify。\n如果有多个并发队列在一个组里，我们想在这些操作执行完了再继续，调用wait\ngroup.wait() DispatchWorkItem\n使用DispatchWorkItem代替原来的dispatch_block_t。 在DispatchQueue执行操作除了直接传了一个() -\u0026gt; Void类型的闭包外，还可以传入一个DispatchWorkItem。\npublic func sync(execute workItem: DispatchWorkItem) public func async(execute workItem: DispatchWorkItem) DispatchWorkItem的初始化方法可以配置Qos和DispatchWorkItemFlags，但是这两个参数都有默认参数，所以也可以只传入一个闭包。\npublic init(qos: DispatchQoS = default, flags: DispatchWorkItemFlags = default, block: @escaping @convention(block) () -\u0026gt; ()) let workItem = DispatchWorkItem { // TODO: } DispatchWorkItemFlags枚举中assignCurrentContext表示QoS根据创建时的context决定。\n值得一提的是DispatchWorkItem也有wait方法，使用方式和group一样。调用会等待这个workItem执行完。\nlet myQueue = DispatchQueue(label: \u0026quot;my.queue\u0026quot;, attributes: .concurrent) let workItem = DispatchWorkItem { sleep(1) print(\u0026quot;done\u0026quot;) } myQueue.async(execute: workItem) print(\u0026quot;before waiting\u0026quot;) workItem.wait() print(\u0026quot;after waiting\u0026quot;) barrier\n假设我们有一个并发的队列用来读写一个数据对象。如果这个队列里的操作是读的，那么可以多个同时进行。如果有写的操作，则必须保证在执行写入操作时，不会有读取操作在执行，必须等待写入完成后才能读取，否则就可能会出现读到的数据不对。在之前我们用dipatch_barrier实现。 现在属性放在了DispatchWorkItemFlags里。\nlet wirte = DispatchWorkItem(flags: .barrier) { // write data}let dataQueue = DispatchQueue(label: \u0026quot;data\u0026quot;, attributes: .concurrent) dataQueue.async(execute: wirte) 信号量\n为了线程安全的统计数量，我们会使用信号量作计数。原来的dispatch_semaphore_t现在用DispatchSemaphore对象表示。 初始化方法只有一个，传入一个Int类型的数。\nlet semaphore = DispatchSemaphore(value: 5) // 信号量减一 semaphore.wait() //信号量加一 semaphore.signal() dispatch_once在swift 3中已经被废弃了。\n简单的建议就是一些初始化场景就用懒加载吧。\n// Examples of dispatch_once replacements with global or static constants and variables. // In all three, the initialiser is called only once. // Static properties (useful for singletons). class Object { static let sharedInstance = Object() } // Global constant. let constant = Object() // Global variable. var variable: Object = { let variable = Object() variable.doSomething() return variable }()","date":"2016-10-30T15:45:13Z","permalink":"https://blog.iostao.com/2016/10/swift3-gcd-dispatch-async/","title":"Swift3中dispatch_once废弃的解决办法"},{"content":"git push代码的时候，可能会遇到下面的提示：\n$ git push warning: push.default is unset; its implicit value is changing in Git 2.0 from 'matching' to 'simple'. To squelch this message and maintain the current behavior after the default changes, use: git config --global push.default matching To squelch this message and adopt the new behavior now, use:\ngit config --global push.default simple When push.default is set to 'matching', git will push local branches to the remote branches that already exist with the same name. Since Git 2.0, Git defaults to the more conservative 'simple' behavior, which only pushes the current branch to the corresponding remote branch that 'git pull' uses to update the current branch. See 'git help config' and search for 'push.default' for further information. (the 'simple' mode was introduced in Git 1.7.11. Use the similar mode 'current' instead of 'simple' if you sometimes use older versions of Git) 事实上这并不会影响你push的结果，最终push还会成功，因为这只是一个”warning“。会在后面看到push成功的结果。\nCounting objects: 10, done. Delta compression using up to 4 threads. Compressing objects: 100% (10/10), done. Writing objects: 100% (10/10), 1.10 KiB | 0 bytes/s, done. Total 10 (delta 9), reused 0 (delta 0) 你可以按照他说的那样运行： $ git config \u0026ndash;global push.default matching\n或者\n$ git config --global push.default simple 命令，以后再push就不会有警告了。\n下面说一下 push.default matching 和 push.default simple 的区别：\npush.default设置maching的意思是：git push 会把你本地所有分支push到名称相对应的远程主机上。这意味着可能你会在不经意间push一些你原本没打算push的分支。\npush.default设置成simple的意思是：git push仅仅把当前所在分支push到从当初git pull pull下来的那个对应分支上，另外，这个过程也会同时检查各个分支的名称是否相对应。\n","date":"2016-08-04T22:01:33Z","permalink":"https://blog.iostao.com/2016/08/git-warning-default/","title":"Git Warning push.default is unset"},{"content":"如果你在一台机器使用两个github账号，或者是使用github的同时，还有bitbucket等代码管理仓库。 例如github，默认情况下，这个秘钥是在你账户的.ssh目录生成id_rsa文件，对应一个id_rsa.pub公钥文件，但是，我可能会有两个github帐号，一个个人，一个办公用（或者是多个仓库管理），这时，我就需要生成多个密钥。\n$ ls ~/.ssh/ config github_rsa github_rsa.pub\npersonalid personalid.pub\n以上是我的密钥列表，那么我的github如何使用多个密钥呢。\n需要编辑一下配置文件~/.ssh/config： 如果没有这个文件，可以创建一个(切换到 ~/.ssh\t目录下)\n$ touch config 编辑 config文件\n1 2 3 4 5 6 7 8 9 Host github.com Hostname github.com User username IdentityFile ~/.ssh/github_rsa Host bitbucket.org Hostname bitbucket.org User username IdentityFile ~/.ssh/personalid 只是用一个公钥 也可以几个账号都上传同一个公钥，配置的时候，使用同一个公钥文件就可以了。为了安全性考虑，不建议这么做\n1 2 3 4 5 6 7 8 9 Host github.com Hostname github.com User username IdentityFile ~/.ssh/github_rsa Host bitbucket.org Hostname bitbucket.org User username IdentityFile ~/.ssh/github_rsa 解释此配置文件：\nHost: \u0026quot;github.com\u0026quot;是一个『别名』，可以随意命名，也可以直接写github Hostname:\t仓储地址：例如git@github.com，这里要的就是 github.com IdentityFile: 所使用的公钥文件 配置完毕，用下面的命令测试一下：\n$ ssh -T git@bitbucket.com logged in as beyond521t. You can use git or hg to connect to Bitbucket. Shell access is disabled. 可以使用如下命令，进行debug查看：\n$ ssh -vv git@bitbucket.com ","date":"2016-07-18T15:43:04Z","permalink":"https://blog.iostao.com/2016/07/git-sshkey-multi/","title":"管理多个SSH Key"},{"content":"本文主要介绍如何使用终端，生成ssh key。 SSH只是一种协议，用于计算机之间的加密登录，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。\n生成SSH KEY： $ ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; , 然后会要求你输入公钥的名字： Enter file in which to save the key (/Users/LaoTao/.ssh/id_rsa): ssh_rsa 接下来要求输入密码，以及确认密码： Enter passphrase (empty for no passphrase): Enter same passphrase again: 以下是整个终端命令流程： $ ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/LaoTao/.ssh/id_rsa): ssh_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ssh_rsa. Your public key has been saved in ssh_rsa.pub. The key fingerprint is: SHA256:m4+0RNpNoAgjjpmtIrQhmwvQHsGnOIoikVkJ/tVqHXM your_email@example.com The key's randomart image is: +---[RSA 2048]----+ |. | |.o . . | |..B .. +.E | |o@.*..o.+. | |%+=..o..S . | |*Bo.. + = | |%.. . * . | |*. o + | |. o . | +----[SHA256]-----+\t可以使用cat命令查看公钥： $ cat ~/.ssh/ssh_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCuX2Zbre+4kPLkolvWXXtmvehFoO/LYVe+/EDA3j4NLX+6GZYXqAG6IEDAKzDKUzaUoxfuWZFk8ZyHhjfViD3FC90Yh9xuIXGYua4xyy6/7CC/HK2mS3Ha0SGW/QKMJ+QrLyeCpUeNiGDbH12DvUJpgp1vwTIIi0Pkykz6SP2mWkgpAKsBYExg+PkY2aLzopw2GpW0JApqQ9Jz/yMZQ5T7yh/k7iYZNWQ/ch9UxmM58gEQjw1qHiC7QZU9JvJsbh+qusNcIjcKLjMrwhw6q21jeGtn+7It4hKo9YL76OR/QRi1OWUJzqOaTY4ssUBEU15f3OGxVT03emJ556hFyVLn your_email@example.com 拷贝命令： Windows:\nclip \u0026lt; ~/.ssh/id_rsa.pub Mac:\npbcopy \u0026lt; ~/.ssh/id_rsa.pub GNU/Linux (requires xclip):\nxclip -sel clip \u0026lt; ~/.ssh/id_rsa.pub 然后将复制的ssh_rsa.pub 公钥粘贴到git服务器的SSH配置中。例如github:\n","date":"2016-07-17T13:42:55Z","permalink":"https://blog.iostao.com/2016/07/git-sshkey/","title":"生成SSH Key"},{"content":"执行 git pull 的时候，提示(When I do the \u0026ldquo;git pull\u0026rdquo;)\nssh_exchange_identification: read: Connection reset by peer fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 经过各种研究，发现了一个比较坑的问题（至少目前我遇到的就是），问题就是服务端有问题，具体是什么，不清楚，因为我不负责这块内容。只说一下，临时解决吧，因为需要，所以不能够等待服务端解决之后再去提交。 (I found this is because the)\n这种问题是因为使用SSH提交导致的，但是发现使用HTTPS这种提交没有问题。git clone代码的时候，大家肯定会看到，给了两个选项，一个是SSH的地址， 一个是HTTPS的地址。\n//输入命令\n$ git remote -v //输出 SSH的origin配置 origin\tgit@git.******.com:ict/project.git (fetch) origin\tgit@git.******.com:ict/project.git (push) //添加一个HTTPs origin //这里使用的是 HTTPS地址 git remote add origin2 https://git.******.com/ict/project.git //输入命令\n$ git remote -v //输出 origin配置 origin\tgit@git.******.com:ict/project.git (fetch) origin\tgit@git.******.com:ict/project.git (push) origin2\thttps://git.******.com/ict/project.git (fetch) origin2\thttps://git.******.com/ict/project.git (push) //然后进行一下操作实时 //这里使用HTTPS 的话，使用 配置的 origin2 进行配置\n$ git pull origin2 develop //发现执行成功 remote: Counting objects: 22, done. remote: Compressing objects: 100% (22/22), done. remote: Total 22 (delta 12), reused 0 (delta 0) Unpacking objects: 100% (22/22), done. ","date":"2016-07-11T11:43:06Z","permalink":"https://blog.iostao.com/2016/07/git-ssh-exchange-identification/","title":"ssh exchange identification"},{"content":"LTPickerView - Swift 连接地址 GitHub LTPickerView-Swift 关于 VERSION 1.0.1\nSwift 2.2\nTIME 2016-07-09 11:41:07\nCreate By 老陶\n效果图 一维数组 二维数组 时间选择器 要求 因为使用了元组等返回结果，所以不允许在Objective-C中混编使用 使用 返回数据类型 resultValue 是一个元组类型\n/** 返回数据的结果类型 */ typealias pickerResultType = (first: AnyObject, second: AnyObject, third: AnyObject, fourth: AnyObject, fifth: AnyObject) UIPickerView 一、一维数组\nlet array = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;] let pickerView = LTPickerView.pickerView(array, title: \u0026quot;一维数组\u0026quot;) pickerView.setSelectedRow(2)\t//选中某一行 pickerView.show()\t//显示界面 //点击 确定/取消 的回调方法 pickerView.resultClosure({ (pickerView, resultValue) in print(\u0026quot;\\(resultValue)\u0026quot;) }) { (pickerView) in } 二、多维数组\nlet array = [[\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;], [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;]] let pickerView = LTPickerView.pickerView(array, title: \u0026quot;多维数组\u0026quot;) //选中行数，这里必须使用(0, 0, 0, 0, 0) 这种元组格式，5个元素 pickerView.setSelectedRows((0, 1, 2, 3, 0)) pickerView.show() //点击 确定/取消 的回调方法 pickerView.resultClosure({ (pickerView, resultValue) in }) { (pickerView) in } UIDatePicker let pickerView = LTPickerView.datePickerView(NSDate(), datePickerMode: UIDatePickerMode.Date, title: \u0026quot;时间选择器\u0026quot;) pickerView.show() pickerView.resultClosure({ (pickerView, resultValue) in //resultValue.first 是输出的`String`类型 //resultValue.second 是输出的`NSDate`类型 print(\u0026quot;\\(resultValue.first), \\(resultValue.second)\u0026quot;) }) { (pickerView) in } 版本更新 ####V1.0.0\n2016-07-09 11:41:40\nFirst Version\n####V1.0.1 2016-07-09 11:41:45\n增加时间选择器，默认选中时间功能 修复已知bug\n","date":"2016-07-08T23:08:08Z","permalink":"https://blog.iostao.com/2016/07/swift-ltpickerview/","title":"LTPickerView.swift"},{"content":"swift 判断String里面包含的中、英文、数字、符号。并附汉字Unicode字符编码表。 Unicode字符编码表\u0026ndash;下载\nlet text = \u0026ldquo;文字内容text123😄\u0026rdquo; for commitChar in text.unicodeScalars { //字符串只有一个字符，这个循环只会执行1次 print(Int(commitChar.value))\nif ((commitChar.value\u0026gt;=0x4e00)\u0026amp;\u0026amp;(commitChar.value\u0026lt;=0x9FA5)) { //字符为中文 print(\u0026quot;字符为中文\u0026quot;) } else if((commitChar.value\u0026gt;64)\u0026amp;\u0026amp;(commitChar.value\u0026lt;91)){ print(\u0026quot;字符为大写英文字母\u0026quot;) }else if((commitChar.value\u0026gt;96)\u0026amp;\u0026amp;(commitChar.value\u0026lt;123)){ print(\u0026quot;字符为小写英文字母\u0026quot;) }else if((commitChar.value\u0026gt;47)\u0026amp;\u0026amp;(commitChar.value\u0026lt;58)){ print(\u0026quot;字符为数字\u0026quot;) }else{ print(\u0026quot;其他字符\u0026quot;) } } ","date":"2016-06-22T15:01:36Z","permalink":"https://blog.iostao.com/2016/06/swift-unicodescalars/","title":"判断中、英文、数字、符号"},{"content":"5月30号参加的APS审核，然后大概第三天查了一下成绩，很高兴通过了。周末趁着有时间，在这里简单写一下关于APS的一些心得吧。\n我是元旦的时候，寄出去的审核材料，到审核一共差不多是半年整。期间因为工作的原因，也就是下班或者周末的时候，简单的整理了一下各科的资料，整理资料，写翻译。但是效率并不高。上个月接到审核电话之后，就有点慌了，因为只有整理了资料，并没有记住。所以就开始准备认真学习了。周末的时候，先去的中国传媒大学教学楼学习，后来去的北京第二外国语学院，发现二外学习还是不错的，去餐厅也近一些。\n期间各种学习，然后审核的前一个周末，我朋友说帮我模拟面试一下，结果我发现虽然东西我都记住了，但是张口说不出来，因为平时看东西都是小声的说并记忆，导致正常说的时候，说不出来，然后最后三天时间就重点练习口语。张开口，自问自答。\n我是周二审核，周一那天请了一天假，在家练习了一天。我住的地方到亮马桥那边有点儿远，所以下午去那边附近酒店，提前入住，这样第二天可以省很多时间。\n到了那边报道之后，前台会让你去等候室等待，好多人在里面，如果自信的话，可以和旁边的和小伙伴聊聊天。我是比较紧张，就自己坐在那里，然后等了几个人之后，就看到一个头发有些红色，然后像熊猫的那位过来叫人，念的我的名字，然后我走过去的时候，就听到好多人说红灭啊。\n主审核官是红灭，自我感觉人还是不错的。过去的时候把包放到了柜子里，然后口袋里也不要放什么东西，当时我口袋里放了张房卡。她看到我口袋有东西，就问我是什么，我刚开始没听出来，她就脾气暴躁的又问了两次，然后我反应过来，掏出来给她看了一下，她就让我去笔试的那个小房间里了。\n小房间里有笔，词典这些，当然不要想着中英、中德词典了。而且时间有限，尽量提前背熟词汇，翻词典挺浪费时间的。\n我的笔试题是两道大题，不清楚其他人的题是什么样的题型，因为保密问题，不能在这里写出来了。不过我第二个有几个单词想不起来了，因为有几个点，那几个单词的影响，这道题只回答了一半。\n到时间了，红灭把我领导对面的办公室里，还有一个副审核官，进去之后打了招呼入座。然后红灭可能脾气暴躁还是什么影响吧，坐下之后，又确认了一下我的名字。我以为接下来会是自我介绍什么的，结果都没有，直接就是问了专业知识。虽然我工作一年了，但是并没有问毕业论文的东西。我是计算机专业的，中间有几门课是实践课，问到了之后，我告诉她是实践内容，但是有一些词汇没准备好，回答的并不是很好。另外就是我英语没有过四级，所以语言也不好。\n后面就是问了一下我为什么想去德国，想去什么学校。简单聊了一下，红灭送我出来的时候，对我说了一句你的语言很差，我以为挂了呢，不过幸运的是通过了。\n我是毕业工作了之后审核的APS，网上很多说的毕业了之后，很多是问你自我介绍 为什么想出国学习、毕业论文这些，专业课知识问的少，这种话不要相信，我是自我介绍、毕业论文都没有问，基本都是专业知识。所以准备一定要充分。\n","date":"2016-06-11T10:46:18Z","permalink":"https://blog.iostao.com/2016/06/aps-pass/","title":"APS过审了，开心"},{"content":"版权声明：本文为博主原创文章，未经博主允许不得转载。 -- 老陶 刚工作的时候做了多语言，发现网上方法很多都是关于跟随系统语言设置的，而系统内部设置的确比较少。\n所以今天闲来没事，写一写总结，供大家参考。\n当然做的时候，也会百度搜索，所以项目中可能会看到网上一些比较熟悉的东西。\n大家做这一步，相信项目工程是有的了吧（因为本人做独立开发，所以一般新功能几乎都是在项目中做的，很少有写demo，就不考虑demo的情况了）\n在项目文件的Supporting Files中的InfoPlist.strings中，右键(或command + N)\u0026ndash;\u0026gt;新建一个string文件。\n（如果没有这个文件，在xcode6中创建，好像没有看到，可以自己创建一个文件，名字可以随便取，后面会给一个方法，获取这个文件的。） 如图1-1所以\n创建完文件之后，点击项目—\u0026gt;选择Project—\u0026gt;选择Info—\u0026gt;点击“+”号。（画线隐藏） 在右下方有个Language的选项，默认进来是只有English的，点击+号之后可以看到各种语言选项\n在这里选择Chinese(Simplified)。下面会出现一个选项，选择InfoPlist.string文件，那个是语言设置的。（如果是自定义的文件，就选择自定义的那个）\n//\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\n到这里，基本配置就完成了。然后后面就是设置需要的字符，以及调用方法了\n在相应的string文件中，写入需要的字符。前面相当于key。后面是value。\nCFBundleDisplayName是app的名字，技术不够，暂时不知道如何手动切换语言，改变桌面的名字，这一步，只是根据系统语言来的。\n如果默认根据系统语言更改语言，那么调用的时候只需要NSLocalizedString(\u0026lt;#key#\u0026gt;, \u0026lt;#comment#\u0026gt;)用这一句就可以了。其他的不需要做处理。\n如果是想自定义的话，那么需要写一个类：\n//.h头文件： #import \u0026lt;Foundation/Foundation.h\u0026gt;\n@interface InternationalController : NSObject\n(NSBundle *)bundle; //获取当前资源文件 (void)initUserLanguage; //初始化语言文件 (NSString *)userLanguage; //获取应用当前语言 (void)setUserLanguage:(NSString *)language; //设置当前语言 @end\n//.m类体文件\n// // InternationalController.m // mworkingHaier // // Created by LaoTao on 14-10-20. // Copyright (c) 2014年 CaiGaoBaDou. All rights reserved. //\n#import \u0026ldquo;InternationalController.h\u0026rdquo; #import \u0026lt;UIKit/UIKit.h\u0026gt;\n@implementation InternationalController\n//创建静态变量bundle，以及获取方法bundle（此处不要使用getBundle). static NSBundle *bundle = nil;\n(NSBundle *)bundle { return bundle; } //初始化方法:\n(void)initUserLanguage { NSUserDefaults *def = [NSUserDefaults standardUserDefaults]; NSString *string = [def valueForKey:kLanguage];\nif (string.length == 0) { //获取系统当前语言版本（中文zh-Hans,英文en) NSArray *languages = [def objectForKey:@\u0026ldquo;AppleLanguages\u0026rdquo;]; NSString *current =[languages objectAtIndex:0]; string = current; [def setValue:current forKey:kLanguage]; [def synchronize]; //持久化，不加的话不会保存 }\n//获取文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:string ofType:@\u0026ldquo;lproj\u0026rdquo;]; // NSLog(@\u0026quot;%@\u0026quot;,path); bundle = [NSBundle bundleWithPath:path]; //生成bundle }\n//获得当前语言的方法\n(NSString *)userLanguage { NSUserDefaults *def = [NSUserDefaults standardUserDefaults]; NSString *language = [def valueForKey:kLanguage]; return language; } //设置语言\n(void)setUserLanguage:(NSString *)language { NSUserDefaults *def = [NSUserDefaults standardUserDefaults];\n//1.第一步改变bundle的值 NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@\u0026ldquo;lproj\u0026rdquo;]; bundle = [NSBundle bundleWithPath:path];\n//2.持久化 [def setValue:language forKey:kLanguage]; [def synchronize]; }\n@end\n把\u0026quot;InternationalController.h\u0026quot;这个在.pch文件中引用，这样全局就都可以调用了\n在AppDelegate.m的didFinishLaunchingWithOptions方法中，加一句：\n[InternationalController initUserLanguage]; //初始化应用语言\n然后设置个全局的宏变量，系统的是NSLocalizedString.这里就设置了LTlocalizedString（LT是老陶的首字母，beyond521t这个t同理，嘿嘿）\nself.title = LTLocalizedString(@\u0026ldquo;TitleName\u0026rdquo;, nil);\n如此就可以使用了。切换语言，请看头文件，直接方法名 + 方法，以及语言就OK了。\n注：英文在iOS中为\u0026quot;en\u0026quot;,简体中文\u0026quot;zh-Hans\u0026quot;.\n切换语言后：处理方法是，再次跳转到根视图即可。（更多处理方式，请看本人另一篇日志，根视图处理）\n","date":"2016-05-25T17:26:36Z","permalink":"https://blog.iostao.com/2016/05/ios-multilanguage/","title":"iOS多语言，支持app内部设置"},{"content":"根据苹果开发者网站的声明，大部分现有应用程序已经通过NSURLSession和CFNetwork APIs兼容该协议。依然使用IPv4 APIs的或者硬件编码IP地址的开发者将需要手工调整应用代码来适应苹果的最新策略。\nIPv6比IPv4更有效： 避免了网络地址转换的需要(NAT: Network Address Translation) 通过使用简单的Headers，通过网络提供更快的路由 防止网络碎片 Avoids broadcasting for neighbor address resolution （避免广播 \u0026hellip;.，请自行翻译好了） DNS64/NAT64 过渡工作流程 为了帮助减缓IPv4地址耗尽，NAT在许多IPv4网络实现。虽然这个解决方案暂时工作，它证明了昂贵和脆弱。今天，随着越来越多的客户使用IPv6，供应商现在必须同时支持IPv4和IPv6。这是一个代价高昂的努力。 图1-1蜂窝网络提供独立的IPv4和IPv6连接 理想的情况下，供应商要降为IPv4网络支持。然而，这样做可以防止客户端访问IPv4的服务器，这是互联网的一个重要部分。为了解决这个问题，最主要的网络供应商实施 DNS64/NAT64 过渡工作。这是一个纯IPv6网络，继续提供访问IPv4内容通过翻译。 图1-2蜂窝网络的部署与 DNS64 和 NAT64 的IPv6网络 在这种类型的工作流中，客户端发送DNS查询到DNS64服务器，它要求从DNS服务器获取 IPv6 地址。当一个IPv6地址被发现，它会立即传回到客户端。然而，当没有找到IPv6地址时，DNS64服务器请求一个IPv4地址代替。然后DNS64服务器通过为IPv4添加地址前缀合成一个IPv6地址，并传递回客户端。在这方面，客户端总是收到一个IPv6-ready地址（In this regard, the client always receives an IPv6-ready address.最后一句原文 By 老陶2016-05-22 12:29:56）。\n图1-3处理IPv4向IPv6的转换过程 当客户端像服务器发送一个请求，任何IPv6数据包\nWhen the client sends a request to a server, any IPv6 packets destined for synthesized addresses are automatically routed by the network through a NAT64 gateway. The gateway performs the IPv6-to-IPv4 address and protocol translation for the request. It also performs the IPv4 to IPv6 translation for the response from the server. See Figure 1-4.\n图1-4 DNS64/NAT64过渡方案工作流程 IPv6 和 App Store 的要求 IPv6 DNS64/NAT64的网络兼容性处理将成为 App Store 的一个提交要求，所以应用程序兼容性不可少的。好消息是大部分软件都兼容IPv6.对于这些应用，定期回归测试你的应用程序仍然是有必要的。不兼容IPv6的应用在操作DNS64/NAT64网络时可能会遇到问题。幸运的是，解决这些问题通常很简单，就像是本章节所讨论的。\n支持IPv6的常见问题 几种阻止一个应用支持IPv6的情况。下面的章节描述如何解决这些问题。\n协议中包含IP地址的文字。 在配置文件中包含IP地址。 网络检测。 使用地级别的网络API. Using small address family storage containers.（请自行翻译 add By 老陶 2016-05-22 15:15:36） 此部分原文：\nSeveral situations can prevent an app from supporting IPv6. The sections that follow describe how to resolve these problems. IP address literals embedded in protocols. Many communications protocols, such as Session Initiation Protocol (SIP), File Transfer Protocol (FTP), WebSockets, and Peer-to-Peer Protocol (P2PP), include IP address literals in protocol messages. For example, the FTP parameter commands DATA PORT and PASSIVE exchange information that includes IP address literals. Similarly, IP address literals may appear in the values of SIP header fields, such as To, From, Contact, Record-Route, and Via. See Use High-Level Networking Frameworks and Don’t Use IP Address Literals. IP address literals embedded in configuration files. Configuration files often include IP address literals. See Don’t Use IP Address Literals. Network preflighting. Many apps attempt to proactively check for an Internet connection or an active Wi-Fi connection by passing IP address literals to network reachability APIs. See Connect Without Preflight. Using low-level networking APIs. Some apps work directly with sockets and other raw network APIs such as gethostbyname, gethostbyname2, and inet_aton. These APIs are prone to misuse or they only support IPv4—for example, resolving hostnames for the AF_INET address family, rather than the AF_UNSPEC address family. See Use High-Level Networking Frameworks. Using small address family storage containers. Some apps and networking libraries use address storage containers—such as uint32_t, in_addr, and sockaddr_in—that are 32 bits or smaller. See Use Appropriately Sized Storage Containers. 确保IPv6 DNS64/NAT64兼容性 遵循以下的知道以确保IPv6 DNS64/NAT64在你的应用程序的兼容性。\n使用高级的网络框架 应用需要可以建立在`高级网络框架` 或 `低级POSIX socket API网络框架`。在大多数情况下，高层次框架是足够的。它们有能力，易于使用，相比低级API拥有更少的缺陷。 图 1-5 网络框架和API图 WebKit. This framework provides a set of classes for displaying web content in windows, and implements browser features such as following links, managing a back-forward list, and managing a history of pages recently visited. WebKit simplifies the complicated process of loading webpages—that is, asynchronously requesting web content from an HTTP server where the response may arrive incrementally, in random order, or partially due to network errors. For more information, see WebKit Framework Reference.\nCocoa URL loading system. This system is the easiest way to send and receive data over the network without providing an explicit IP address. Data is sent and received using one of several classes—such as NSURLSession, NSURLRequest, and NSURLConnection—that work with NSURL objects. NSURL objects let your app manipulate URLs and the resources they reference. Create an NSURL object by calling the initWithString: method and passing it a URL specifier. Call the checkResourceIsReachableAndReturnError: method of the NSURL class to check the reachability of a host. For more information, see URL Session Programming Guide.\nCFNetwork. This Core Services framework provides a library of abstractions for network protocols, which makes it easy to perform a variety of network tasks such as working with BSD sockets, resolving DNS hosts, and working with HTTP/HTTPS. To target a host without an explicit IP address, call the CFHostCreateWithName method. To open a pair of TCP sockets to the host, call the CFStreamCreatePairWithSocketToCFHost method. For more information, see [CFNetwork Concepts](CFNetwork Concepts) in CFNetwork Programming Guide. If you do require the low-level socket APIs, follow the guidelines in RFC4038: Application Aspects of IPv6 Transition.\n","date":"2016-05-22T11:58:16Z","permalink":"https://blog.iostao.com/2016/05/ios-requireipv6/","title":"6 月 1 日起所有提交的 app 都需要支持 IPv6 网络"},{"content":"自今年6月1日开始，所有提交至苹果App Store的应用申请必须要兼容面向硬件识别和网络路由的最新互联网协议\u0026ndash;IPv6-only标准。在去年的全球开发者大会上苹果就率先宣布iOS9会向IPv6-only网络服务过渡。(Supporting IPv6 DNS64/NAT64 Networks)\nApple 在这里给出了适配 IPv6 的指南\n根据苹果开发者网站的声明，大部分现有应用程序已经通过NSURLSession和CFNetwork APIs兼容该协议。依然使用IPv4 APIs的或者硬件编码IP地址的开发者将需要手工调整应用代码来适应苹果的最新策略。\n随着IPv4地址用完，转移到地址更丰富的IPv6协议正在变得越来越重要。对于苹果来说，切换至IPv6能够带来更广泛的行业接受协议，尤其是那些负责销售iPhone和iPad的网络运营商们。此外伴随物联网的迅速普及，能够加速智能手机的迅猛发展。\n其实早在2012年6月的IPv6日，世界范围内就开始全面启动IPv6。在中国，移动、联通和电信大范围开展现网IPv6试点。随着IPv6研究工作和实际部署的不断开展，网络迟早会进入纯IPv6（IPv6-only）的时代。目前很多的资源还在IPv4环境中，因此IPv6和IPv4网络之间的互通尤为重要。\n苹果这么急着进入IPv6-only网络领域，估计是想改变一下如今的环境，更好的支持下一代的苹果产品和系统。 在此之前，苹果曾在WWDC2015就率先宣布iOS9会向IPv6-only网络服务过渡，随着IPv4地址用完，转移到地址更丰富的IPv6协议也是大势所趋。\n","date":"2016-05-05T13:50:19Z","permalink":"https://blog.iostao.com/2016/05/ios-require-allappipv6-only/","title":"苹果:所有应用必须支持IPv6-only网络"},{"content":"点击下载代码\n多设备其实和单设备并没有什么太大的变化。至少初级写的时候，只是代码量多了一些。但是后面各种状态还有代码的优化工作挺多。\n@interface CentralManager ()\u0026lt;CBCentralManagerDelegate, CBPeripheralDelegate,CentralManagerDelegate\u0026gt; { /** 这里只做多设备简单介绍。如果设备很多，或者设备不固定，可以考虑使用数组等进行优化 */ CBPeripheral *_devicePeripheral; //硬件设备 (设备1) CBPeripheral *_wristbandPeripheral; //手环设备 (设备2)\nCBCharacteristic *_deviceCharacteristic; //硬件设备服务特征 （用来发送指令） CBCharacteristic *_wristbandCharacteristic; //手环设备服务特征 (发送指令，用来和手环进行数据交换，读取手环数据等) //蓝牙管理类，这就是蓝牙Boss呀，没有他，你就别想做蓝牙 CBCentralManager *_manager; } 这里添加了两个 CBPeripheral *成员变量。 每一个 CBPeripheral对应一个硬件设备，如果硬件过多，建议使用数组进行优化。 如果只是两个设备倒还不会有影响。另外建议使用swift，做起来会更快速一些。\n#pragma mark - \u0026raquo; 发现蓝牙设备\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)advertisementData RSSI:(NSNumber *)RSSI { if (!peripheral.name) { return; } //连接设备可以根据需求，写到两个方法里面，可以根据点击操作分别连接不同的设备。 我这里是直接进行了同时连接 //里面的字符串是硬件设备的名称。 也可以根据 广播等内容进行判断连接 //连接硬件设备 if ([peripheral.name rangeOfString:@\u0026quot;Device\u0026quot;].location != NSNotFound) { [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } //连接手环设备 if ([peripheral.name rangeOfString:@\u0026quot;wristband\u0026quot;].location != NSNotFound) { [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } } #pragma mark - \u0026raquo; 连接成功\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { NSLog(@\u0026quot;连接成功:%@\u0026quot;, peripheral.name); if (_devicePeripheral == peripheral) { _deviceBleState = BleManagerStateConnect; _devicePeripheral = peripheral; }else if (_wristbandPeripheral == peripheral) { _wristbandBleState = BleManagerStateConnect; _wristbandPeripheral = peripheral; } for (id listener in _listener) { if ([listener respondsToSelector:@selector(didConnectDevicePeripheral:)]) { [listener didConnectDevicePeripheral:peripheral]; } } /* 1、连接成功 2、发现服务 3、发现特征值 4、特征值 是用来 和蓝牙设备做交互使用的。如设置设备时间，或者读取设备数据。设置通知等 */ //因为在后面我们要从外设蓝牙那边再获取一些信息，并与之通讯，这些过程会有一些事件可能要处理，所以要给这个外设设置代理 peripheral.delegate = self; //找到该设备上的指定服务 调用完该方法后会调用代理CBPeripheralDelegate（现在开始调用另一个代理的方法了） // [peripheral discoverServices:@[[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]]; // [peripheral discoverServices:@[[CBUUID UUIDWithString:@\u0026quot;7480\u0026quot;]]]; [peripheral discoverServices:nil]; //发现服务 } #pragma mark - \u0026raquo; CBPeripheralDelegate #pragma mark - \u0026raquo; 发现服务\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { if (error == nil) { NSLog(@\u0026quot;发现服务\u0026quot;); for (CBService *service in peripheral.services) { NSLog(@\u0026quot;服务:%@\u0026quot;, service); //发现服务，然后去查找该服务的特征值 ,然后请转到下面的那个代理方法 [peripheral discoverCharacteristics:nil forService:service]; // if ([service.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]) { // //查询服务所带的特征值 // // [peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:@\u0026quot;FFE0\u0026quot;]] forService:service]; // [peripheral discoverCharacteristics:nil forService:service]; // } } } } #pragma mark - \u0026raquo; 发现特征值\n(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { NSLog(@\u0026quot;\u0026mdash;\u0026ndash;发现特征值\u0026quot;); //在这里给 蓝牙设备写数据， 或者将 peripheral 和 characteristic 拿出去，可以在其他地方，发送命令 if (error == nil) { for (CBCharacteristic *characteristic in service.characteristics) {\nNSLog(@\u0026quot;发现特征值:%@\u0026quot;, characteristic); //这里只写了 devicePeripheral 的特征值。 手环的 方法同理，代码几乎一样 if (_devicePeripheral == peripheral) { [peripheral setNotifyValue:YES forCharacteristic:characteristic]; //以下宏定义的UUID 请根据自己当前的硬件设备做调整。 不同的设备会有不同的定义。 //另外，读写的，也会的也会不同。 可以使用 第三方蓝牙工具，进行设备上的服务和特征值查看一下。 //或者是直接参阅 贵公司的蓝牙设备 协议文档 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_1]]) { //如果是指定的特征值，设置NotifyValue [peripheral setNotifyValue:YES forCharacteristic:characteristic]; }else if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_2]]) { _deviceCharacteristic = characteristic; for (id listener in _listener) { if ([listener respondsToSelector:@selector(didDiscoverDevicePeripheral:service:)]) { [listener didDiscoverDevicePeripheral:peripheral service:service]; } } } }else if (_wristbandPeripheral == peripheral) { } } } }\n#pragma mark - \u0026raquo; 如果一个特征的值被更新，然后周边代理接收\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { } #pragma mark - \u0026raquo; 读数据\n//这里是接收到蓝牙数据。 但是蓝牙数据都是一堆 16进制数据，需要根据协议去解析 //数据协议，请参阅协议文档，如果没有，就去找吧。 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSLog(@\u0026quot;接收到数据:%@,%@\u0026quot;, peripheral.name, characteristic.value); } - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error { NSLog(@\u0026quot;did write value For Characteristic\u0026quot;); NSLog(@\u0026quot;%@\u0026quot;, characteristic.value); } - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error { NSLog(@\u0026quot;did Write Value For Descriptor\u0026quot;); } ","date":"2016-04-30T16:51:37Z","permalink":"https://blog.iostao.com/2016/04/ios-bledevelopmultidevice/","title":"iOS-BLE蓝牙开发(二) -- 多设备"},{"content":"iOS开发蓝牙入门 简单来说，iOS蓝牙就是有一个中心角色（可以理解为管理蓝牙的一个对象 CBCentralManager） 就像是创建UITableView一样，需要先初始化 中心角色(CBCentralManager) 既然存在了蓝牙管理对象，那么想要连接蓝牙，一般都是先去搜索设备。所以下一步，搜索设备（暂时不要看代码，先把思路理清楚。下面是代码，会按照这个思路再走一遍）\n搜索到一个设备 - didDiscoverPeripheral\n你就会在delegate方法中，得到这个设备。然后判断，如果这个设置是你需要的，那么就进行连接。如果没有特别情况，这里最好是停止设备搜索，因为你已经找到它了。\n连接自然会有两个结果，所以对应两个代理方法\n连接成功\tdidConnectPeripheral 连接失败\tdidFailToConnectPeripheral 连接成功 在这里去搜索服务，服务里会有特征值。特征值，是用来和蓝牙设备，做读写命令交互用的。\n发现服务 - didDiscoverServices 发现到服务，然后去查找这个服务中的特征值\n发现特征值 - didDiscoverCharacteristicsForService 这里去设置读写数据。或者是把特征值，做一个成员变量接收，这样就可以，选择什么时刻发送命令了。\n获取到蓝牙设备发送过来的数据 - didUpdateValueForCharacteristic 蓝牙数据一般为一堆16进制数据，然后自己根据协议去解析就好了。\n总结中心模式的用法 引入CoreBluetooth.framework 引入蓝牙协议，如 @protocol CBCentralManagerDelegate; @protocol CBPeripheralDelegate; 创建 CBCentralManager //定义一个中心角色对象 @property (strong, nonatomic) CBCentralManager *centralManager; //建立中心角色 _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; //搜索蓝牙设备 [_centralManager scanForPeripheralsWithServices:nil options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; //发现蓝牙设备 - 代理方法 - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary\u0026lt;NSString *,id\u0026gt; *)advertisementData RSSI:(NSNumber *)RSSI { //这里peripheral 就是搜索到的蓝牙设备对象了。 //advertisementData 是广播消息。 //RSSI 信号强度 //这里名字 我随便写的。可以根据需求，来作判断。比如利用广播判断 if ([peripheral.name isEqualToString:@\u0026quot;小米手环\u0026quot;]) { //连接设备 ， 这里会有 连接成功， 和 连接失败两个代理方法 [_manager connectPeripheral:peripheral options:@{CBCentralManagerScanOptionAllowDuplicatesKey:[NSNumber numberWithBool:NO]}]; } } #pragma mark - \u0026gt;\u0026gt; 连接成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral { [_centralManager stopScan]; //停止扫描 //因为在后面我们要从外设蓝牙那边再获取一些信息，并与之通讯，这些过程会有一些事件可能要处理，所以要给这个外设设置代理 peripheral.delegate = self; //找到该设备上的指定服务 调用完该方法后会调用代理CBPeripheralDelegate（现在开始调用另一个代理的方法了） // [peripheral discoverServices:@[[CBUUID UUIDWithString:@\u0026quot;7480\u0026quot;]]]; //这个是发现所有服务， 上面的是发现指定服务 [peripheral discoverServices:nil]; } #pragma mark - \u0026gt;\u0026gt; CBPeripheralDelegate #pragma mark - \u0026gt;\u0026gt; 发现服务 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error { if (error == nil) { NSLog(@\u0026quot;发现服务\u0026quot;); for (CBService *service in peripheral.services) { NSLog(@\u0026quot;服务:%@\u0026quot;, service); //设备 发现所有特征 [peripheral discoverCharacteristics:nil forService:service]; //下面代码，是用来查找特定服务的 特征，如果能确定只用哪个服务的，就可以用下面的方法 //if ([service.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_0]]) { //查询服务所带的特征值 //[peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:@\u0026quot;FFE0\u0026quot;]] forService:service]; //[peripheral discoverCharacteristics:nil forService:service]; // } } } #pragma mark - \u0026gt;\u0026gt; 发现特征值 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error { if (error == nil) { for (CBCharacteristic *characteristic in service.characteristics) { NSLog(@\u0026quot;发现特征值:%@\u0026quot;, characteristic); //这个FFE1是我随便写的。需要根据你们自己的硬件给的来填写. if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\u0026quot;FFE1\u0026quot;]]) { //我的这个特征是用来读取数据的。这里设置通知 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; }else if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:UUID_DEVICE_SERVER_2]]) { //给蓝牙设备发送数据， 写数据 [peripheral writeValue:(NSData *) forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse]; } } } }","date":"2016-04-28T16:41:43Z","permalink":"https://blog.iostao.com/2016/04/ios-bledevelop/","title":"iOS-BLE蓝牙开发"},{"content":"let insets = UIEdgeInsetsMake(30, 0, 10, 0) //top: CGFloat, _ left: CGFloat, _ bottom: CGFloat, _ right: CGFloat 其中Insets这个参数的格式是 (top, left, bottom, right)，从上、左、下、右分别在图片上画了一道线，这样就给一个图片加了一个框。\n只有在框里面的部分才会被拉伸，而框外面的部分则不会改变。 4个参数是上边界，左边界，下边界，右边界距离，也可以为负值。\nlet image = UIImage(named: \u0026quot;icon.png\u0026quot;) //iOS5之前，端盖(end cap)概念，用来指定图片中的哪一部分不用拉伸。上下左右不需要被拉伸的边缘就称为端盖。\n//iOS5 + 方法 bodyImage.image = image?.resizableImageWithCapInsets(insets) //iOS6 + 方法 bodyImage.image = image?.resizableImageWithCapInsets(insets, resizingMode: UIImageResizingMode.Stretch) resizingMode 用来指定拉伸模式: UIImageResizingMode.Stretch 拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片 UIImageResizingMode.Tile 平铺模式，通过重复显示UIEdgeInsets指定的矩形区域来填充图片 ","date":"2016-04-27T10:53:54Z","permalink":"https://blog.iostao.com/2016/04/uiimage-resizableimagewithcapinsets/","title":"UIImage 拉伸图片 resizableImageWithCapInsets"},{"content":"OSI/RM (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型\n应用层 Application layer 表示层 Presentation layer 会话层 Session layer 传输层 Transport layer 网络层 Network layer 数据链路层 Data link layer 物理层 Physical layer 用图说话\n","date":"2016-03-23T07:17:48Z","permalink":"https://blog.iostao.com/2016/03/aps-osi_tcp-ip/","title":"OSI、TCP/IP"},{"content":"计算机专业词汇 reuse 重用，复用 recall\tcallback 回调 override 重写 recursion 递归 encapsulation 封装 inheritance\t继承 interface 接口 delegationg 委托 entity 实体 schema n.模式，概要，图表 scheme\tn.方案 relational schema 关系模式 design 设计 optimize vt.使最优化，使尽可能有效 redundancy 冗余 Redundant adj.冗余\t的 abnormal\t异常 interface 接口 host\t主机 Atomic 原子的，原子能的；微粒子的 relation model 关系模式 durable\t持久的\ntwo to the fourth power 2的4次方 message\t报文 frame\t框架，帧 SQL Data\t数据 Data Base\t数据库 Data Base Management System (DBMS)\t数据库管理系统 Data Definition Language (DDL) 数据定义语言 Data Manipulation Language (DML) 数据库操作语言 （增删查改） Data Base System (DBS) 数据库系统 Data Base Administrator (DBA) 数据库管理员 Schematic diagram of database system\t数据库系统示意图 Security\t安全性 Integrity\t完整性 Concurrency\t并发 Recovery\t恢复 Entity-Relationship Approach (E-R)\t实体-联系方法 Entity\t实体 Attribute\t属性 Relationship\t联系 Relation\t关系 Tuple\t元组 Attribute and Attribute Value\t属性和属性值 Domain\t域 Relation Mode\t关系模式 Key\t键 Candidate Key\t候选键 Primary Key\t主键 Non Primary Key\t非主属性/非键属性 Foreign Key\t外键 Normal Form\t范式 Boyce-Codd Normal Form (BCNF) Boyce-Codd范式 Index\t索引 Cluster Index\t聚集索引 Non-cluster Index\t非聚集索引 algorithms\t运算法则 add / plus\t加 minus\t减 multiplied\t乘 divide\t除 compiler design principles machine language\t机器语言 object program\t目标程序 object code\t目标代码 process\t进程 thread\t线程 queue\t队列 synchrony\t同步 asynchronism\t异步 superclass\t父类 subclass\t子类 ","date":"2016-03-22T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-computervocabulary/","title":"Computer English Vocabulary"},{"content":"Encapsulation 封装 Encapsulation is hide the internal implementation, and stabilize the external interface. It can hide the implementation details and make the code modular.\neg.\npublic int max(int a, int b) { return a \u0026gt; b ? a : b; } int a = max(1, 5); int b = max(10, 15); int max = max(a, b); Inheritance Inheritance can expand the code modular, it used for resue code.\neg.\npublic class Person { String ID; String Name; Boolean Gender; String Birthday; } public class Student extends Person { String SID; String major; String Department; } The Student inherit attributes from the SuperClass -- PersonClass. Polymorphism 1、overload\nThe functions have the same method name, but they have different parameters.\neg.\npublic int max(int a, int b) { return a \u0026gt; b ? a : b; } public int max(int a, int b, int c) { int max = a \u0026gt; b ? a : b; return = max \u0026gt; c ? max : c; } 2、 It just happened in the case of inheritance.\neg.\npublic class Person { String ID; String Name; Boolean Gender; String Birthday; public void introduction() { System.out.println(\u0026quot;My name is \u0026quot; + Name \u0026quot;, my Birthday is \u0026quot; + Birthday + \u0026quot;.\u0026quot;); } } public class Student extends Person { String SID; String major; String Department; //override the function public void introduction() { System.out.println(\u0026quot;My name is \u0026quot; + Name + \u0026quot;.\u0026quot;); } } Delegation The delegation has two functions: one is transmit values, and one is transmit the event. It can reduce the complex of the code.\neg.\npublic class A { B b = new B(); } public class B { //B want to transmit a value to A. //But B can't communicate with A by directory. //so here use the delegation to help transmit value. } ","date":"2016-03-18T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-encapsulation-inheritance-polymorphism-delegation/","title":"Encapsulation, Inheritance, Polymorphism, Delegation"},{"content":"统一建模语言\n模型种类 十种图形 建模机制 用例模型 用例图 静态建模 静态模型 类图、对象图、包图 静态建模 行为模型 状态图、活动图 动态建模 交互模型 顺序图、协作图 动态建模 实现模型 构件图、配置图 静态建模 ","date":"2016-03-15T17:46:18Z","permalink":"https://blog.iostao.com/2016/03/aps-uml/","title":"APS-UML"},{"content":"What is the Normal Form? Normal Form is a set that with a particular level. （范式是符合某一种级别的关系模式的集合。） Create database must follow certain rules. In the relational database, this rule is the Normal Form. What is the Normal Form used to do? / What is the role of Normal Form? Database that meet these Normal Form are concise and clear stuctured. At the same time, there are no exceptions when insert, delete and update. Generally, the Relationship is divided into 5 Normal Form. 1NF, 2NF, 3NF, Boyce-Codd NF, 4NF, 5NF. In generally, the database only to meet the 3NF. 1NF In any relational database, the 1NF is the basic requirement. If the database that does not meet the 1NF, it isn't a relational database. The 1NF is a non repeating column. * There must have primary key. * Primary key cannot be empty. * The Primary Key can't be repeated * the column can't be divided. StudentNo Name Sex Email Phone 001 LaoTao Mail laotao@m.com 18866688688 2NF Meeting the 2NF must meeting the 1NF. Each non key attribute is not part dependent on the Primary Key attribute. So the main task of the 2NF is to meet the 1NF, and eliminate some dependence of the function. StudentNo Name Sex Email Phone ClassNo classAddress 001 LaoTao Mail lt@m.cn 18866688688 1003 67#A205 This table is fully satisfied with the 1NF. The primary key is consisting of the \u0026quot;StudentNo\u0026quot; and \u0026quot;ClassNO\u0026quot;. But the \u0026quot;ClassAddress\u0026quot; depends on the key(ClassNo -\u0026gt; ClassAddress), so it must be divided into two tables. Table 1\nStudentNo Name Sex Email Phone ClassNo 001 LaoTao Mail lt@m.cn 18866688688 1003 Table 2\nClassNO ClassAddress 1003 67#205 3NF 如果关系模型R是第二范式， 且没有一个非键属性传递依赖于键，则称R是3NF. The 3NF requires a database table does not contain the non primary key information that has benn included in other tables. StudentNo Name Sex Email bounsLevel bouns 001 LaoTao Mail lt@m.cn Good £1000 This table is fully satisfied with the 2NF.But boundsLevel and bounds has a transitive dependency(传递依赖). StudentNo Name Sex Email boundsNo 001 LaoTao Mail lt@m.cn 01 boundsNo bounsLevel bouns 01 Good £1000 I'd love using the boundsNo as the Primary Key, There are two reasons: * 1)don't use the characters as Primary Key. * 2)Generally, use the unrelated key in preference as the primary Key. BCNF Boyce-Codd Normal Formal\n三层模式模型 E-R图 ","date":"2016-03-14T21:36:38Z","permalink":"https://blog.iostao.com/2016/03/aps-sql2005/","title":"APS-SQL2005"},{"content":"(分层，各层作用，协议)\nWhat\u0026rsquo;s the purpose of this course? - basic knowledge of computer network - focus on the structure and behavior of network Details Introduction 简介 - the architecture of newtork is based on different protocols. =\u0026gt; Protocol: an agreement between the communicating parties on how communication is to proceed. - Network Model of hierarchy =\u0026gt; 5 Layers 5 Layers OSI/RM (Open Systems Interconnection Reference Model) 开发系统互连基本参考模型\n5 Layers Function Application Layer message Transport Layer segment Network Layer datagram Data Link Layer frame Physical Layer bit each layer contains several protocals in s sense, each layer offers certain service to the layer above it. each layer communicates with the corresponding(相应的) layer, using specific message header to distinguish(区别). Application Layer 应用层 (HTTP, FTP, SMTP, DNS) * deal with the problems how network applications work and communicate with each other. * famour protocols: - HTTP, HyperText Transfer Protocol =\u0026gt; defines how the web clients ask for web pages and how the server transfer the web pages to clients. - kinds of connection non-persistent connection persistent connection =\u0026gt; won't shut down till specific time. Client Server |\tStart TCP | |----------------\u0026gt;| | | | Confirm | |\u0026lt;----------------| | | | ask for files | |----------------\u0026gt;| | | | get files | |-----------------| |-----------------| HTTP Request request line -\u0026gt;\nGET/HTTP/1.1 | Host: www.devtao.com header line -| connection: close | user-agent: Mozilla / 4.0 |\tAccept-language: cn HTTP Respond:\nstatus line -\u0026gt;\n(status code: 200, 404) header line entity body\nCookie\n=\u0026gt; a special file to distinguish the clients\nSam login to Amazon, PC send cookie 1000 to server, server will store this cookie in the backend database. next time Sam login to Amazon, the server will recognise him.\nFTP, File Transfer Protocol =\u0026gt; Users can upload or download files from the FTP server =\u0026gt; in LAN\nuser \u0026lt;\u0026ndash;\u0026gt; FTP Interface FTP Client \u0026lt;\u0026ndash;\u0026gt; FTP Server II II local file system remote file system 对照下图\n------ --------------- ------------ ------------ | user |\u0026lt;--\u0026gt; | FTP Interface | | FTP Client |\u0026lt;--\u0026gt; | FTP Server | ------ --------------- ------------ ------------ ||\t|| ------------------- -------------------- | local file system | | remote file system | ------------------- -------------------- SMTP (Simple Main Transfer Protocol)\n=\u0026gt; define how the E-mainl system works.\n----------- ----------------- SMTP --------------- | A's agent | -\u0026gt; | A's mail Server | ----\u0026gt; |B's mail Server| ----------- ----------------- --------------- || || ----------- | B's agent | ----------- define the message format =\u0026gt; header\n=\u0026gt; Only ASCII code is legal in SMTP.\nDNS (Domain Name Server Protocol)\n=\u0026gt; use DNS to get the internet IP address.\npeople prefer to rememter the web address, or say URL rather than the IP address. -use DNS to find the corresponding IP address of a specific web URL(Uniform Resource Locator). www.google.com \u0026lt;=\u0026gt; 8.8.8.8\nusing a distributed database. Network A computer network is a group of interconnected computers. Networks may be classified(划分) according to a wide kind of characteristics. The most common division is \u0026ldquo;LAN\u0026rdquo; and \u0026ldquo;WAN\u0026rdquo;.\n\u0026ldquo;WAN\u0026rdquo;(Wide Area Network), is connect computer within a very wide Region. \u0026ldquo;LAN\u0026rdquo;(Local Area Network), is a Network in l limited region and computers belonging to it, will enter the net when they get switched on. Network-Topologys Network toplogy is the study of the arrangement(排列) or mapping(映射) of the elements of a network, especially the physical and logical interconnections between nodes(结点).\nLine-Topology\nBus-Topology\nAll computers are connected in a line. When a line is broken, the whole network doesn\u0026rsquo;t work.\nRing-Topology\nIt\u0026rsquo;s like a Bus or Line Topology and has the same advantages and disadvantages.\nStar-Topology\nIn Star-Topology, all computers are connected to Central-Stations like Hub, Switch or Router. This topology is very quick and safe and also easy to maintenance.\n","date":"2016-03-13T22:15:01Z","permalink":"https://blog.iostao.com/2016/03/aps-network/","title":"APS-Network"},{"content":"毛爷爷说过，不能打无准备的仗。\n复习时，可按照下面的方针进行知识点的整理：\n1、必修类课程每门课提炼3-4个知识点，4个最优 2、选修课课程每门课提炼2-3个知识点，3个最优 3、其他课程一句话，讲清楚学了啥干了啥就行 课程复习 C语言 (数组、结构、指针) 编程语言 （语言分类[机器，汇编，高级], 共同点，不同点，OOP, 流程图） 数据结构 （顺序表、链表、队列和栈、树、图） 数字逻辑 （逻辑门、卡诺图） 数据库原理 （三层模式模型、关系数据库、E-R图、范式）（事务原子最好也看一下） 计算机网络 （网络分层模型、DNS、TCP三次握手、UDP） 计算机组成原理 （CPU内部结构、存储分层结构、寻址） 计算机操作系统 （进程状态图，死锁及其解决方法，虚拟存储器） 计算机系统结构 （流水线结构、实现、可能出现的问题以及解决方法） 编译原理 （词法分析、语法分析、语义分析） 自我介绍 自我介绍方面，在准备时一定要包括下面几个方面，尽量精简（否则据说红灭这种审核官可能会很不耐烦） 1、姓名 2、年龄+年纪 3、来自哪所院校 4、专业 留学计划 留学计划这也是一个多半会被问到的问题，一定要事先想清楚大概的计划，比如城市、学校、每个月生活费等等 （英审的注意。 Notice: 你为什么不用德语来面试？ （红灭可能问到的蛋疼的问题))\n","date":"2016-03-12T06:37:24Z","permalink":"https://blog.iostao.com/2016/03/aps-start/","title":"APS-Start"},{"content":"1.单线程：禁用所有的mutex锁，并发使用时会出错。当SQLite编译时加了SQLITE_THREADSAFE=0参数，或者在初始化SQLite前调用sqlite3_config(SQLITE_CONFIG_SINGLETHREAD)时启用。\n2.多线程：只要一个数据库连接不被多个线程同时使用就是安全的。源码中是启用bCoreMutex，禁用bFullMutex。实际上就是禁用数据库连接和prepared statement（准备好的语句）上的锁，因此不能在多个线程中并发使用同一个数据库连接或prepared statement。当SQLite编译时加了SQLITE_THREADSAFE=2参数时默认启用。若SQLITE_THREADSAFE不为0，可以在初始化SQLite前，调用sqlite3_config(SQLITE_CONFIG_MULTITHREAD)启用；或者在创建数据库连接时，设置SQLITE_OPEN_NOMUTEX flag。\n3.串行：启用所有的锁，包括bCoreMutex和bFullMutex。因为数据库连接和prepared statement都已加锁，所以多线程使用这些对象时没法并发，也就变成串行了。当SQLite编译时加了SQLITE_THREADSAFE=1参数时默认启用。若SQLITE_THREADSAFE不为0，可以在初始化SQLite前，调用sqlite3_config(SQLITE_CONFIG_SERIALIZED)启用；或者在创建数据库连接时，设置SQLITE_OPEN_FULLMUTEX flag。\n在iOS上，默认使用的是第2种方式编译的，也就是只有一个线程能够打开数据库操作，其他线程要操作数据库必须等数据库关闭后才能打开操作。多线程时：每个线程独立打开数据库，操作数据库，操作完后关闭数据库。打开和关闭都比较费时间，而且要手动控制打开关闭锁，在每个线程操作不频率时可用该方法。\n如果多个线程频繁操作数据库，使用以上方法很容易造成系统崩溃，解决方案：开启第3种串行模式，使用一个类（单例方式）操作数据库。 -(BOOL)open { sqlite3_shutdown(); NSLog(@\u0026quot;sqlite3 lib version: %s\u0026quot;, sqlite3_libversion()); int err=sqlite3_config(SQLITE_CONFIG_SERIALIZED); if (err == SQLITE_OK) { NSLog(@\u0026quot;Can now use sqlite on multiple threads, using the same connection\u0026quot;); } else { NSLog(@\u0026quot;setting sqlite thread safe mode to serialized failed!!! return code: %d\u0026quot;, err); } err = sqlite3_open([VersionDBPath UTF8String], \u0026amp;hSqlite3DB); if(err != SQLITE_OK) { NSLog(@\u0026quot;datebase open error: %d\u0026quot;, err); return NO; } return YES; }","date":"2016-03-11T11:56:53Z","permalink":"https://blog.iostao.com/2016/03/ios-sqlitemultithreading/","title":"iOS上Sqlite多线程问题"},{"content":"在bitbucket上使用https协议，经常会在提交代码的时候出错，让人很着急上火，但是用ssh就要方便很多。\n下面介绍一下设置ssh的方法：\n1.在终端中运行ssh-keygen。\n2.然后一路enter，直接到结束。不要理会中间的输入。\n3 打开用户目录下.ssh/id_rsa.pub文件，复制其内容。(服务器操作，可以用vi打开，进行复制) 4.Bitbucket上点右上角的小头像，然后选择Manage account.\n5.左边目录选择SSH Keys， 然后选择add key。将刚才复制的内容粘贴进去，保存。\n回到工程页面，将使用的协议选择为SSH。\n现在就可以使用SSH了。\n","date":"2016-02-21T12:43:34Z","permalink":"https://blog.iostao.com/2016/02/git-deploy-ssh-of-bitbucket/","title":"如何配置Bitbucket的ssh"},{"content":"版权声明：本文为博主原创文章，未经博主允许不得转载。 最近才注意到NSArray,NSDictionary,NSNumber有一种字面量方式声明。瞬间感觉写代码又省了好多事情。\n只是百度了一下，从Xcode4.4就已经存在这种方式了，但是自己居然一直在使用Previously那些方法。\n于是现在在这里做一次整理，方便自己记忆（其实是当初说要写博客，但是好久没写了，来补个数量尴尬)\n借鉴:http://cocoaheads.tumblr.com/post/17757846453/objective-c-literals-for-nsdictionary-nsarray\n也看了一下官方文档，但是上面那个链接给的非常详细。大家如果有愿意看的话，看上面那个地址就可以了，以下，只是为了自己学习。\nObjective-C literals: one can now create literals for NSArray, NSDictionary, and NSNumber (just like one can create literals for NSString)\nString Value\nstring_value ::= \u0026ldquo;text\u0026rdquo; | \u0026rsquo;text'\nNSArray:\nPreviously:\narray = [[NSArray alloc] initWithObjects: a, b, c, nil ];\narray = [NSArray arrayWithObjects: a, b, c, nil ];\nNow: array = @[ a, b, c ];\nNSDictionary:\nPreviously:\nNSDictionary *dict;\ndict = [[NSDictionary alloc] initWithObjectsAndKeys:@[ o1, o2, o3 ],@[ k1, k2, k3 ], nil ];\ndict = [NSDictionary dictionaryWithObjects:@[ o1, o2, o3] forKeys:@[ k1, k2, k3]];\nNow:\ndict = @{ k1 : o1, k2 : o2, k3 : o3 };\nNSNumber:\nPreviously:\nNSNumber * number;\nnumber = [NSNumber numberWithInt:12345];\n//同理，这种初始化还有Char,Long,Float,Double,Bool等类型，不再一一列举\nNow:\nNSNumber *number;\nnumber = @\u0026lsquo;X\u0026rsquo;;\nnumber = @12345;\nnumber = @12345ul;\nnumber = @12345ll;\nnumber = @123.45f;\nnumber = @123.45;\nnumber = @YES;\n","date":"2016-02-17T15:59:01Z","permalink":"https://blog.iostao.com/2016/02/ios-objective-c-literal-value/","title":"字面量声明方式 Objective-C Literal Value"},{"content":" # Git Overview Git Profile\n1)远程仓库相关命令 检出仓库：$ git clone git://github.com/jquery/jquery.git\n查看远程仓库：$ git remote -v 获取远程分支信息到本地：$ git fetch (查看远程分支显示不全时，执行这个命令) 添加远程仓库：$ git remote add [name] [url] 删除远程仓库：$ git remote rm [name] 拉取远程仓库：$ git pull [remoteName] [localBranchName] 推送远程仓库：$ git push [remoteName] [localBranchName] 2)分支(branch)操作相关命令 查看本地分支：$ git branch 查看远程分支：$ git branch -r 创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支 切换分支：$ git checkout [name] 创建新分支并立即切换到新分支：$ git checkout -b [name] 迁出远程分支\t$ git checkout -b dev origin/dev 删除分支：$ git branch -d [name] -d 选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name] 删除远程分支：$ git push origin --delete [name] $ git push origin :[name] 列出分支图 git config --global alias.lg \u0026quot;log --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit --date=relative\u0026quot; git lg (设置了别名后，就可以使用别名进行查看) 3）版本(tag)操作相关命令 查看版本：$ git tag 创建版本：$ git tag [name] 删除版本：$ git tag -d [name] 查看远程版本：$ git tag -r 创建远程版本(本地版本push到远程)：$ git push origin [name] 删除远程版本：$ git push origin :refs/tags/[name] 拉取tag版本：git checkout -b branch_name tag_name 4) 子模块(submodule)相关操作命令 添加子模块：$ git submodule add [url] [path] 初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下 删除子模块：$ git rm --cached [path] 5）忽略一些文件、文件夹不提交 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 target, bin, *.db,\n代码提交 命令操作详情:\n1、查看修改文件 git status 2、暂存修改的文件 git add . 3、提交已暂存的文件 git commit 4、拉取远程修改内容 git pull -p 如果有冲突，这里修改，修改之后，从1步骤重新开始 5、提交代码到远程分支 git push 如果没有创建远程分支， 则使用如下命令 git push origin 分支名 //如果是从远程分支拉取的，但是没有建立关系，使用以下命令 git branch --set-upstream my_branch origin/my_branch 以下内容比较多，不容易理解\n代码提交一般有五个步骤：\n1.查看目前代码的修改状态\n2.查看代码修改内容\n3.暂存需要提交的文件\n4.提交已暂存的文件\n5.同步到服务器\ngit config --global push.default matching git config --global push.default simple 建立关系\ngit branch --set-upstream my_branch origin/my_branch 1. 查看目前代码的修改状态 提交代码之前，首先应该检查目前所做的修改，运行git status命令\na) 已暂存 （changes to be committed）\nnew file //表示新建文件\nmodified //表示修改文件\ndeleted //表示删除文件\nb) 已修改 （changed but not updated）\nmodified //表示修改文件\ndeleted //表示删除文件\n另外，git 给出了可能需要的操作命令，git add/rm, gitcheckout -- c) 未跟踪 （untracked files）\n2. 查看代码修改的内容 git diff 比较某文件与最近提交节点的差异。\n注意：如果该文件已暂存，那么应该使用git diff –cached\ngit diff 比较某文件在提交节点a，节点b的差异。\n技巧：如果省略后面一个hashcode，则默认表示与上一提交节点比较。（也可以利用^运算符）\n3. 暂存需要提交的文件 如果是新建的文件\n则git add 如果是修改的文件\n则git add 如果是删除的文件\n则 git rm 4. 提交已暂存的文件 git commit 注意注释填写规范。 git commit --amend 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。 5. 同步到服务器 同步到服务器前先需要将服务器代码同步到本地\n命令： git pull 如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。 命令：git checkout \u0026ndash; \u0026lt;有冲突的文件路径\u0026gt;\n同步到服务器\n命令： git push origin \u0026lt;本地分支名\u0026gt; 远程如果暂时没有分支（即初始，没有master分支），同步本地master分支到远程\ngit push -u origin master 如果执行失败，一般是没有将服务器代码同步到本地导致的，先执行上面的git pull命令。\n新仓库处理 $ touch README.md $ git init $ git add README.md $ git commit -m \u0026quot;first commit\u0026quot; $ git remote add origin https://github.com/****.git $ git -u origin master 未整理 git remote prune origin\ngit pull\ngit branch -a\ngit tag git clone https://xxx.xx.xx \u0026ndash;depth 1 ","date":"2016-02-16T11:49:03Z","permalink":"https://blog.iostao.com/2016/02/git-command/","title":"Git命令"}]